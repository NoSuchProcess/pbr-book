
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
        
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Primitive Interface and Geometric Primitives</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Primitives_and_Intersection_Acceleration.html">Primitives and Intersection Acceleration</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Primitive Interface and Geometric Primitives</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Primitives_and_Intersection_Acceleration.html">(Previous: Primitives and Intersection Acceleration)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:primitives"></span><h2>4.1 Primitive Interface and Geometric Primitives</h2><p>



</p>
<p>

</p>
<p>The abstract <a href="#Primitive"><tt>Primitive</tt></a> base class is the bridge between the
geometry processing and shading subsystems of <tt>pbrt</tt>.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-PrimitiveDeclarations-0"></span><div class="fragmentname">&lt;&lt;Primitive Declarations&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="Primitive"></span>Primitive {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-PrimitiveInterface-0">Primitive Interface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-502" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-502"><i></i></a><div id="fragbit-502" class="collapse"><div class="fragmentcode">       virtual ~<a href="#Primitive" class="code">Primitive</a>();
       virtual <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> WorldBound() const = 0;
       virtual bool Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *) const = 0;
       virtual bool IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r) const = 0;
       virtual const <a href="../Light_Sources/Area_Lights.html#AreaLight" class="code">AreaLight</a> *GetAreaLight() const = 0;
       virtual const <a href="../Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a> *GetMaterial() const = 0;
       virtual void ComputeScatteringFunctions(<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect,
           <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, TransportMode mode,
           bool allowMultipleLobes) const = 0;</div></div>
};</div><p>


</p>
<p>

</p>
<p>There are a number of geometric routines in the <tt>Primitive</tt> interface,
all of which are similar to a corresponding <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> method.  The first,
<a href="#Primitive::WorldBound"><tt>Primitive::WorldBound()</tt></a>, returns a box that encloses the primitive&rsquo;s
geometry in world space.  There are many uses for such a bound; one of the
most important is to place the <a href="#Primitive"><tt>Primitive</tt></a> in the acceleration data
structures.

</p>
<p></p>
<span class="anchor" id="fragment-PrimitiveInterface-0"></span><div class="fragmentname">&lt;&lt;Primitive Interface&gt;&gt;=&nbsp;<a href="#fragment-PrimitiveInterface-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="Primitive::WorldBound"></span>WorldBound() const = 0;</div><p>


</p>
<p>The next two methods provide ray intersection tests.
One difference between the two base classes is that
<a href="../Shapes/Basic_Shape_Interface.html#Shape::Intersect"><tt>Shape::Intersect()</tt></a> returns the parametric distance along the ray to
the intersection in a <tt>Float *</tt> output variable, while
<a href="#Primitive::Intersect"><tt>Primitive::Intersect()</tt></a> is responsible for updating <a href="../Geometry_and_Transformations/Rays.html#Ray::tMax"><tt>Ray::tMax</tt></a>
with this value if an intersection is found.

</p>
<p></p>
<span class="anchor" id="fragment-PrimitiveInterface-1"></span><div class="fragmentname">&lt;&lt;Primitive Interface&gt;&gt;+=&nbsp;<a href="#fragment-PrimitiveInterface-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-PrimitiveInterface-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual bool <span class="anchor" id="Primitive::Intersect"></span>Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *) const = 0;
virtual bool <span class="anchor" id="Primitive::IntersectP"></span>IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r) const = 0;</div><p>


</p>
<p>

</p>
<p>Upon finding an intersection, the <tt>Primitive</tt>&rsquo;s <tt>Intersect()</tt> method is
also responsible for initializing additional <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a>
member variables, including a
pointer to the <a href="#Primitive"><tt>Primitive</tt></a> that the ray hit.

</p>
<p></p>
<span class="anchor" id="fragment-SurfaceInteractionPublicData-2"></span><div class="fragmentname">&lt;&lt;SurfaceInteraction Public Data&gt;&gt;+=&nbsp;<a href="../Geometry_and_Transformations/Interactions.html#fragment-SurfaceInteractionPublicData-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-SurfaceInteractionPublicData-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">const <a href="#Primitive" class="code">Primitive</a> *<span class="anchor" id="SurfaceInteraction::primitive"></span>primitive = nullptr;</div><p>


</p>
<p><a href="#Primitive"><tt>Primitive</tt></a> objects have a few methods related to non-geometric
properties as well.  The first, <a href="#Primitive::GetAreaLight"><tt>Primitive::GetAreaLight()</tt></a>,
returns a pointer to the <a href="../Light_Sources/Area_Lights.html#AreaLight"><tt>AreaLight</tt></a> that describes the primitive&rsquo;s
emission distribution, if the primitive is itself a light source.  If the 
primitive is not emissive, this method should return <tt>nullptr</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-PrimitiveInterface-2"></span><div class="fragmentname">&lt;&lt;Primitive Interface&gt;&gt;+=&nbsp;<a href="#fragment-PrimitiveInterface-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-PrimitiveInterface-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual const <a href="../Light_Sources/Area_Lights.html#AreaLight" class="code">AreaLight</a> *<span class="anchor" id="Primitive::GetAreaLight"></span>GetAreaLight() const = 0;</div><p>


</p>
<p><tt>GetMaterial()</tt> returns a pointer to the material instance assigned to
the primitive. If <tt>nullptr</tt> is returned, ray intersections with the
primitive should be ignored; the primitive only serves to delineate a
volume of space for participating media.  This method is also used to check if two
rays have intersected the same object by comparing their <a href="../Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a>
pointers.

</p>
<p></p>
<span class="anchor" id="fragment-PrimitiveInterface-3"></span><div class="fragmentname">&lt;&lt;Primitive Interface&gt;&gt;+=&nbsp;<a href="#fragment-PrimitiveInterface-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-PrimitiveInterface-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual const <a href="../Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a> *<span class="anchor" id="Primitive::GetMaterial"></span>GetMaterial() const = 0;</div><p>


</p>
<p>The third material-related method, <tt>ComputeScatteringFunctions()</tt>,
initializes representations of the light-scattering properties of the
material at the intersection point on the surface.  The <a href="../Materials/BSDFs.html#BSDF"><tt>BSDF</tt></a> object
(introduced in Section&nbsp;<a href="../Materials/BSDFs.html#sec:bsdf">9.1</a>) describes local light-scattering
properties at the intersection point.  If applicable, this method also
initializes a <a href="../Volume_Scattering/The_BSSRDF.html#BSSRDF"><tt>BSSRDF</tt></a>, which describes subsurface scattering inside
the primitive&mdash;light that enters the surface at points far from where it
exits.  While subsurface light transport has little effect on the
appearance of objects like metal, cloth, or plastic, it is the dominant
light-scattering mechanism for biological materials like skin, thick
liquids like milk, etc.  The <a href="../Volume_Scattering/The_BSSRDF.html#BSSRDF"><tt>BSSRDF</tt></a> is supported by an extension of
the path tracing algorithm discussed in
Section&nbsp;<a href="../Light_Transport_II_Volume_Rendering.html#chap:volume-integration">15</a>.

</p>
<p>In addition to a <tt>MemoryArena</tt> to allocate memory for the <a href="../Materials/BSDFs.html#BSDF"><tt>BSDF</tt></a>
and/or <a href="../Volume_Scattering/The_BSSRDF.html#BSSRDF"><tt>BSSRDF</tt></a>, this method takes a <a href="../Light_Transport_III_Bidirectional_Methods/The_Path-Space_Measurement_Equation.html#TransportMode"><tt>TransportMode</tt></a> enumerant that
indicates whether the ray path that found this intersection point started
from the camera or from a light source; as will be discussed further in
Section&nbsp;<a href="../Light_Transport_III_Bidirectional_Methods/The_Path-Space_Measurement_Equation.html#sec:adjoint-transport">16.1</a>, this detail has important implications
for how some parts of material models are evaluated.  The
<tt>allowMultipleLobes</tt> parameter controls a detail of how some types of
BRDFs are represented; it is discussed further in
Section&nbsp;<a href="../Materials/Material_Interface_and_Implementations.html#sec:material-interface">9.2</a>.
Section&nbsp;<a href="../Materials/BSDFs.html#sec:bsdf-memory-management">9.1.1</a> discusses the use of the
<a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> for <a href="../Materials/BSDFs.html#BSDF"><tt>BSDF</tt></a> memory allocation in more detail.

</p>
<p></p>
<span class="anchor" id="fragment-PrimitiveInterface-4"></span><div class="fragmentname">&lt;&lt;Primitive Interface&gt;&gt;+=&nbsp;<a href="#fragment-PrimitiveInterface-3"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">virtual void <span class="anchor" id="Primitive::ComputeScatteringFunctions"></span>ComputeScatteringFunctions(<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect,
    <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, TransportMode mode,
    bool allowMultipleLobes) const = 0;</div><p>


</p>
<p>The <a href="../Materials/BSDFs.html#BSDF"><tt>BSDF</tt></a> and <a href="../Volume_Scattering/The_BSSRDF.html#BSSRDF"><tt>BSSRDF</tt></a> pointers for the point are stored in the
<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> passed to <tt>ComputeScatteringFunctions()</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-SurfaceInteractionPublicData-3"></span><div class="fragmentname">&lt;&lt;SurfaceInteraction Public Data&gt;&gt;+=&nbsp;<a href="#fragment-SurfaceInteractionPublicData-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="../Texture/Sampling_and_Antialiasing.html#fragment-SurfaceInteractionPublicData-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="../Materials/BSDFs.html#BSDF" class="code">BSDF</a> *<span class="anchor" id="SurfaceInteraction::bsdf"></span>bsdf = nullptr;
BSSRDF *<span class="anchor" id="SurfaceInteraction::bssrdf"></span>bssrdf = nullptr;</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#GeometricPrimitives"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:gprim"></span><span id="GeometricPrimitives"></span><h3>4.1.1  Geometric Primitives</h3><p>



</p>
<p>The <a href="#GeometricPrimitive"><tt>GeometricPrimitive</tt></a> class represents a single shape (e.g., a sphere) in
the scene.  One <a href="#GeometricPrimitive"><tt>GeometricPrimitive</tt></a> is allocated for each shape in the
scene description provided by the user. This class is implemented in the files
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/primitive.h"><tt>core/primitive.h</tt></a><span class="anchor" id="coreprimitive.h"></span> and
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/primitive.cpp"><tt>core/primitive.cpp</tt></a><span class="anchor" id="coreprimitive.cpp"></span>.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-GeometricPrimitiveDeclarations-0"></span><div class="fragmentname">&lt;&lt;GeometricPrimitive Declarations&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="GeometricPrimitive"></span>GeometricPrimitive : public <a href="#Primitive" class="code">Primitive</a> {
public:
    &lt;&lt;<span class="fragmentname">GeometricPrimitive Public Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-503" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-503"><i></i></a><div id="fragbit-503" class="collapse"><div class="fragmentcode">       virtual <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> WorldBound() const;
       virtual bool Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect) const;
       virtual bool IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r) const;
       GeometricPrimitive(const std::shared_ptr&lt;<a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a>&gt; &amp;shape,
               const std::shared_ptr&lt;<a href="../Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>&gt; &amp;material,
               const std::shared_ptr&lt;<a href="../Light_Sources/Area_Lights.html#AreaLight" class="code">AreaLight</a>&gt; &amp;areaLight,
               const MediumInterface &amp;mediumInterface)
           : shape(shape), material(material), areaLight(areaLight),
             mediumInterface(mediumInterface) {
       }
       const <a href="../Light_Sources/Area_Lights.html#AreaLight" class="code">AreaLight</a> *GetAreaLight() const;
       const <a href="../Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a> *GetMaterial() const;
       void ComputeScatteringFunctions(<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena,
           TransportMode mode, bool allowMultipleLobes) const;</div></div>
private:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-GeometricPrimitivePrivateData-0">GeometricPrimitive Private Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-504" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-504"><i></i></a><div id="fragbit-504" class="collapse"><div class="fragmentcode">       std::shared_ptr&lt;<a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a>&gt; shape;
       std::shared_ptr&lt;<a href="../Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>&gt; material;
       std::shared_ptr&lt;<a href="../Light_Sources/Area_Lights.html#AreaLight" class="code">AreaLight</a>&gt; areaLight;
       MediumInterface mediumInterface;</div></div>
};</div><p>


</p>
<p>

</p>
<p>Each <a href="#GeometricPrimitive"><tt>GeometricPrimitive</tt></a> holds a reference to a <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> and its
<a href="../Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a>.  In addition, because primitives in <tt>pbrt</tt> may be
area light sources, it stores a pointer to an <a href="../Light_Sources/Area_Lights.html#AreaLight"><tt>AreaLight</tt></a> object
that describes its emission characteristics (this pointer is set
to <tt>nullptr</tt> if the primitive does not emit light).  Finally, the
<a href="../Volume_Scattering/Media.html#MediumInterface"><tt>MediumInterface</tt></a> attribute encodes information about the participating media on
the inside and outside of the primitive.

</p>
<p></p>
<span class="anchor" id="fragment-GeometricPrimitivePrivateData-0"></span><div class="fragmentname">&lt;&lt;GeometricPrimitive Private Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::shared_ptr&lt;<a href="../Shapes/Basic_Shape_Interface.html#Shape" class="code">Shape</a>&gt; <span class="anchor" id="GeometricPrimitive::shape"></span>shape;
std::shared_ptr&lt;<a href="../Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a>&gt; <span class="anchor" id="GeometricPrimitive::material"></span>material;
std::shared_ptr&lt;<a href="../Light_Sources/Area_Lights.html#AreaLight" class="code">AreaLight</a>&gt; <span class="anchor" id="GeometricPrimitive::areaLight"></span>areaLight;
MediumInterface <span class="anchor" id="GeometricPrimitive::mediumInterface"></span>mediumInterface;</div><p>


</p>
<p>The <tt>GeometricPrimitive</tt> constructor just initializes these variables
from the parameters passed to it. It&rsquo;s straightforward, so we don&rsquo;t include
it here.

</p>
<p>

</p>
<p>Most of the methods of the <a href="#Primitive"><tt>Primitive</tt></a> interface related to geometric
processing are simply forwarded to the corresponding <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> method.
For example, <a href="#GeometricPrimitive::Intersect"><tt>GeometricPrimitive::Intersect()</tt></a> calls the
<a href="../Shapes/Basic_Shape_Interface.html#Shape::Intersect"><tt>Shape::Intersect()</tt></a> method of its enclosed <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> to do the
actual intersection test and initialize a <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> 
to describe the intersection, if any.  It also uses the returned parametric
hit distance to update the <a href="../Geometry_and_Transformations/Rays.html#Ray::tMax"><tt>Ray::tMax</tt></a> member.  The advantage
of storing the distance to the closest hit in <a href="../Geometry_and_Transformations/Rays.html#Ray::tMax"><tt>Ray::tMax</tt></a> is that this
makes it easy to avoid performing intersection tests with any primitives
that lie farther along the ray than any already-found intersections.

</p>
<p></p>
<span class="anchor" id="fragment-GeometricPrimitiveMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;GeometricPrimitive Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-GeometricPrimitiveMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">bool GeometricPrimitive::<span class="anchor" id="GeometricPrimitive::Intersect"></span><a href="../Shapes/Basic_Shape_Interface.html#Shape::Intersect" class="code">Intersect</a>(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r,
        <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect) const {
    Float tHit;
    if (!<a href="#GeometricPrimitive::shape" class="code">shape</a>-&gt;<a href="../Shapes/Basic_Shape_Interface.html#Shape::Intersect" class="code">Intersect</a>(r, &amp;tHit, isect))
        return false;
    r.<a href="../Geometry_and_Transformations/Rays.html#Ray::tMax" class="code">tMax</a> = tHit;
    isect-&gt;<a href="#SurfaceInteraction::primitive" class="code">primitive</a> = this;
    &lt;&lt;<span class="fragmentname"><a href="../Volume_Scattering/Media.html#fragment-InitializemonoSurfaceInteraction::mediumInterfaceaftermonoShapeintersection-0">Initialize <tt>SurfaceInteraction::mediumInterface</tt> after <tt>Shape</tt> intersection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-505" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-505"><i></i></a><div id="fragbit-505" class="collapse"><div class="fragmentcode">       if (<a href="../Geometry_and_Transformations/Interactions.html#Interaction::mediumInterface" class="code">mediumInterface</a>.<a href="../Volume_Scattering/Media.html#MediumInterface::IsMediumTransition" class="code">IsMediumTransition</a>())
           isect-&gt;<a href="../Geometry_and_Transformations/Interactions.html#Interaction::mediumInterface" class="code">mediumInterface</a> = <a href="../Geometry_and_Transformations/Interactions.html#Interaction::mediumInterface" class="code">mediumInterface</a>;
       else
           isect-&gt;<a href="../Geometry_and_Transformations/Interactions.html#Interaction::mediumInterface" class="code">mediumInterface</a> = <a href="../Volume_Scattering/Media.html#MediumInterface" class="code">MediumInterface</a>(r.<a href="../Geometry_and_Transformations/Rays.html#Ray::medium" class="code">medium</a>);</div></div>
    return true;
}</div><p>


</p>
<p><span class="anchor" id="GeometricPrimitive::WorldBound"></span>
<span class="anchor" id="GeometricPrimitive::IntersectP"></span> We won&rsquo;t include the
implementations of the <a href="#GeometricPrimitive"><tt>GeometricPrimitive</tt></a>&rsquo;s <tt>WorldBound()</tt> or
<tt>IntersectP()</tt> methods here; they just forward these requests on to
the <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> in a similar manner.  Similarly,
<tt>GetAreaLight()</tt><span class="anchor" id="GeometricPrimitive::GetAreaLight"></span> just
returns the <a href="#GeometricPrimitive::areaLight"><tt>GeometricPrimitive::areaLight</tt></a> member.

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p>Finally, the <tt>ComputeScatteringFunctions()</tt> method just forwards the
request on to the <a href="../Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a>.

</p>
<p></p>
<span class="anchor" id="fragment-GeometricPrimitiveMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;GeometricPrimitive Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-GeometricPrimitiveMethodDefinitions-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="GeometricPrimitive::ComputeScatteringFunctions"></span>GeometricPrimitive::<a href="../Materials/Material_Interface_and_Implementations.html#Material::ComputeScatteringFunctions" class="code">ComputeScatteringFunctions</a>(
        <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, TransportMode mode,
        bool allowMultipleLobes) const {
    if (<a href="#GeometricPrimitive::material" class="code">material</a>)
        <a href="#GeometricPrimitive::material" class="code">material</a>-&gt;<a href="../Materials/Material_Interface_and_Implementations.html#Material::ComputeScatteringFunctions" class="code">ComputeScatteringFunctions</a>(isect, arena, mode,
            allowMultipleLobes);
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#TransformedPrimitive:ObjectInstancingandAnimatedPrimitives"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:prim-instance-animated"></span><span id="TransformedPrimitive:ObjectInstancingandAnimatedPrimitives"></span><h3>4.1.2  TransformedPrimitive: Object Instancing and Animated Primitives</h3><p>



</p>
<p><a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a> holds a single <a href="#Primitive"><tt>Primitive</tt></a> and also includes an
<a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform"><tt>AnimatedTransform</tt></a> that is injected in between the
underlying primitive and its representation in the scene.  This extra
transformation enables two useful features: object instancing and
primitives with animated transformations.

</p>
<p>Object instancing is a classic technique in rendering that reuses
transformed copies of a single collection of geometry at multiple positions
in a scene.  For example, in a model of a concert hall with thousands of
identical seats, the scene description can be compressed substantially if
all of the seats refer to a shared geometric representation of a single
seat.  The ecosystem scene in Figure&nbsp;<a href="../Primitives_and_Intersection_Acceleration.html#fig:ecosys-instancing">4.1</a> has 23,241
individual plants of various types, although only 31 unique plant models.
Because each plant model is instanced multiple times with a different
transformation for each instance, the complete scene has a total of 3.1
billion triangles, although only 24 million triangles are stored in memory,
thanks to primitive reuse through object instancing.  <tt>pbrt</tt> uses just over
7&nbsp;GB of memory when rendering this scene with object instancing (1.7&nbsp;GB for
BVHs, 2.3&nbsp;GB for triangle meshes, and 3&nbsp;GB for texture maps), but would
need upward of 516&nbsp;GB to render it without instancing.

</p>
<p>Animated transformations enable rigid-body animation of primitives in the
scene via the <a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform"><tt>AnimatedTransform</tt></a> class.  See
Figure&nbsp;<a href="../Geometry_and_Transformations/Animating_Transformations.html#fig:spinning-spheres">2.15</a> for an image that exhibits motion blur
due to animated transformations.

</p>
<p>Recall that the <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a>s of Chapter&nbsp;<a href="../Shapes.html#chap:shapes">3</a> themselves had object-to-world
transformations applied to them to place them in the scene.  If a shape is
held by a <a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a>, then the shape&rsquo;s notion of world
space isn&rsquo;t the actual scene world space&mdash;only after the
<a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a>&rsquo;s transformation is also applied is the shape
actually in world space.  For the applications here, it makes sense for the
shape to not be at all aware of the additional transformations being
applied.  For animated shapes, it&rsquo;s simpler to isolate all of the handling
of animated transformations to a single class here, rather than require all
<a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a>s to support <a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform"><tt>AnimatedTransform</tt></a>s.  Similarly, for instanced
primitives, letting <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a>s know all of the instance transforms is of
limited utility: we wouldn&rsquo;t want the <a href="../Shapes/Triangle_Meshes.html#TriangleMesh"><tt>TriangleMesh</tt></a> to make a copy of
its vertex positions for each instance transformation and
transform them all the way to world space, since this would negate the
memory savings of object instancing.

</p>
<p></p>
<span class="anchor" id="fragment-TransformedPrimitiveDeclarations-0"></span><div class="fragmentname">&lt;&lt;TransformedPrimitive Declarations&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="TransformedPrimitive"></span>TransformedPrimitive : public <a href="#Primitive" class="code">Primitive</a> {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-TransformedPrimitivePublicMethods-0">TransformedPrimitive Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-506" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-506"><i></i></a><div id="fragbit-506" class="collapse"><div class="fragmentcode">       TransformedPrimitive(std::shared_ptr&lt;<a href="#Primitive" class="code">Primitive</a>&gt; &amp;<a href="#TransformedPrimitive::primitive" class="code">primitive</a>,
               const <a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform" class="code">AnimatedTransform</a> &amp;<a href="#TransformedPrimitive::PrimitiveToWorld" class="code">PrimitiveToWorld</a>)
           : <a href="#TransformedPrimitive::primitive" class="code">primitive</a>(<a href="#TransformedPrimitive::primitive" class="code">primitive</a>), <a href="#TransformedPrimitive::PrimitiveToWorld" class="code">PrimitiveToWorld</a>(<a href="#TransformedPrimitive::PrimitiveToWorld" class="code">PrimitiveToWorld</a>) { }
       bool Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *in) const;
       bool IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r) const;
       const <a href="../Light_Sources/Area_Lights.html#AreaLight" class="code">AreaLight</a> *GetAreaLight() const { return nullptr; }
       const <a href="../Materials/Material_Interface_and_Implementations.html#Material" class="code">Material</a> *GetMaterial() const { return nullptr; }
       void ComputeScatteringFunctions(<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena,
           TransportMode mode, bool allowMultipleLobes) const {
           Severe("TransformedPrimitive::ComputeScatteringFunctions() shouldn't be called");
       }
       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <a href="#Primitive::WorldBound" class="code">WorldBound</a>() const { 
           return <a href="#TransformedPrimitive::PrimitiveToWorld" class="code">PrimitiveToWorld</a>.<a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform::MotionBounds" class="code">MotionBounds</a>(<a href="#TransformedPrimitive::primitive" class="code">primitive</a>-&gt;<a href="#Primitive::WorldBound" class="code">WorldBound</a>());
       }</div></div>
private:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-TransformedPrimitivePrivateData-0">TransformedPrimitive Private Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-507" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-507"><i></i></a><div id="fragbit-507" class="collapse"><div class="fragmentcode">       std::shared_ptr&lt;<a href="#Primitive" class="code">Primitive</a>&gt; primitive;
       const <a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform" class="code">AnimatedTransform</a> PrimitiveToWorld;</div></div>
};</div><p>


</p>
<p>The <a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a> constructor takes a reference to the
<a href="#Primitive"><tt>Primitive</tt></a> that represents the model, and the transformation that
places it in the scene.  If the geometry is described by multiple
<a href="#Primitive"><tt>Primitive</tt></a>s, the calling code is responsible for placing them in an
<a href="../Primitives_and_Intersection_Acceleration/Aggregates.html#Aggregate"><tt>Aggregate</tt></a> implementation so that only a single <a href="#Primitive"><tt>Primitive</tt></a> needs
to be stored here. For the code that creates aggregates as needed, see the
<a href="../Scene_Description_Interface/Scene_Definition.html#pbrtObjectInstance"><tt>pbrtObjectInstance()</tt></a> function in
Section&nbsp;<a href="../Scene_Description_Interface/Scene_Definition.html#sec:api-object-instance">A.3.6</a> of Appendix&nbsp;B for the case of
primitive instances, and see the <a href="../Scene_Description_Interface/Scene_Definition.html#pbrtShape"><tt>pbrtShape()</tt></a> function in
Section&nbsp;<a href="../Scene_Description_Interface/Scene_Definition.html#sec:api-api-shapes-regions">A.3.5</a> for animated shapes.

</p>
<p></p>
<span class="anchor" id="fragment-TransformedPrimitivePublicMethods-0"></span><div class="fragmentname">&lt;&lt;TransformedPrimitive Public Methods&gt;&gt;=&nbsp;<a href="#fragment-TransformedPrimitivePublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">TransformedPrimitive(std::shared_ptr&lt;<a href="#Primitive" class="code">Primitive</a>&gt; &amp;primitive,
        const <a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform" class="code">AnimatedTransform</a> &amp;PrimitiveToWorld)
    : primitive(primitive), PrimitiveToWorld(PrimitiveToWorld) { }</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-TransformedPrimitivePrivateData-0"></span><div class="fragmentname">&lt;&lt;TransformedPrimitive Private Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::shared_ptr&lt;<a href="#Primitive" class="code">Primitive</a>&gt; <span class="anchor" id="TransformedPrimitive::primitive"></span>primitive;
const <a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform" class="code">AnimatedTransform</a> <span class="anchor" id="TransformedPrimitive::PrimitiveToWorld"></span>PrimitiveToWorld;</div><p>


</p>
<p>The key task of the <a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a> is to bridge the
<a href="#Primitive"><tt>Primitive</tt></a> interface that it implements and the <a href="#Primitive"><tt>Primitive</tt></a> that
it holds a pointer to, accounting for the effects of the additional
transformation that it holds.  The <a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a>&rsquo;s
<tt>PrimitiveToWorld</tt> transformation defines the transformation from the
coordinate system of this particular instance of the geometry to world
space.  If the <tt>primitive</tt> member has its own transformation, that
should be interpreted as the transformation from object space to the
<a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a>&rsquo;s coordinate system.  The complete
transformation to world space requires both of these transformations
together.

</p>
<p>

</p>
<p>As such, the <a href="#TransformedPrimitive::Intersect"><tt>TransformedPrimitive::Intersect()</tt></a> method transforms the
given ray to the primitive&rsquo;s coordinate system and passes the
transformed ray to its <tt>Intersect()</tt> routine.
If a hit is found, the <tt>tMax</tt> value from the transformed ray needs to be
copied into the ray <tt>r</tt> originally passed to the <tt>Intersect()</tt>
routine.

</p>
<p></p>
<span class="anchor" id="fragment-TransformedPrimitiveMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;TransformedPrimitive Method Definitions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bool TransformedPrimitive::<span class="anchor" id="TransformedPrimitive::Intersect"></span><a href="#Primitive::Intersect" class="code">Intersect</a>(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;r, 
        <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputemonorayaftertransformationbymonoPrimitiveToWorld-0">Compute <tt>ray</tt> after transformation by <tt>PrimitiveToWorld</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-508" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-508"><i></i></a><div id="fragbit-508" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> InterpolatedPrimToWorld;
       <a href="#TransformedPrimitive::PrimitiveToWorld" class="code">PrimitiveToWorld</a>.<a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform::Interpolate" class="code">Interpolate</a>(<a href="../Geometry_and_Transformations/Applying_Transformations.html#Transform::operator" class="code">r</a>.<a href="../Geometry_and_Transformations/Rays.html#Ray::time" class="code">time</a>, &amp;InterpolatedPrimToWorld);
       <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Utilities/Mathematical_Routines.html#Inverse" class="code">Inverse</a>(InterpolatedPrimToWorld)(<a href="../Geometry_and_Transformations/Applying_Transformations.html#Transform::operator" class="code">r</a>);</div></div>
    if (!<a href="#TransformedPrimitive::primitive" class="code">primitive</a>-&gt;<a href="#Primitive::Intersect" class="code">Intersect</a>(ray, isect))
        return false;
    r.<a href="../Geometry_and_Transformations/Rays.html#Ray::tMax" class="code">tMax</a> = ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::tMax" class="code">tMax</a>;
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Transforminstancesintersectiondatatoworldspace-0">Transform instance&rsquo;s intersection data to world space</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-509" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-509"><i></i></a><div id="fragbit-509" class="collapse"><div class="fragmentcode">       if (!InterpolatedPrimToWorld.<a href="../Geometry_and_Transformations/Transformations.html#Transform::IsIdentity" class="code">IsIdentity</a>())
           *isect = InterpolatedPrimToWorld(*isect);</div></div>
    return true;
}</div><p>


</p>
<p>To transform the ray, we need to interpolate the transformation based on
the ray&rsquo;s time.  Although we want to transform the ray <tt>r</tt> from world
space to primitive space, here we actually interpolate
<tt>PrimitiveToWorld</tt> and then invert the resulting <tt>Transform</tt> to
get the transformation.  This surprising approach is necessary because of
how the polar decomposition-based transformation interpolation algorithm in
Section&nbsp;<a href="../Geometry_and_Transformations/Animating_Transformations.html#sec:animated-transform-class">2.9.3</a> works: interpolating
<tt>PrimitiveToWorld</tt> to some time and inverting it doesn&rsquo;t necessarily
give the same result as interpolating its inverse, the animated world to
primitive transformation, directly.  Because <a href="#Primitive::WorldBound"><tt>Primitive::WorldBound()</tt></a>
uses <tt>PrimitiveToWorld</tt> to compute the primitive&rsquo;s bounding box, we
must also interpolate <tt>PrimitiveToWorld</tt> here for consistency.

</p>
<p></p>
<span class="anchor" id="fragment-ComputemonorayaftertransformationbymonoPrimitiveToWorld-0"></span><div class="fragmentname">&lt;&lt;Compute <tt>ray</tt> after transformation by <tt>PrimitiveToWorld</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Transformations.html#Transform" class="code">Transform</a> InterpolatedPrimToWorld;
<a href="#TransformedPrimitive::PrimitiveToWorld" class="code">PrimitiveToWorld</a>.<a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform::Interpolate" class="code">Interpolate</a>(<a href="../Geometry_and_Transformations/Applying_Transformations.html#Transform::operator" class="code">r</a>.<a href="../Geometry_and_Transformations/Rays.html#Ray::time" class="code">time</a>, &amp;InterpolatedPrimToWorld);
<a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray = <a href="../Utilities/Mathematical_Routines.html#Inverse" class="code">Inverse</a>(InterpolatedPrimToWorld)(<a href="../Geometry_and_Transformations/Applying_Transformations.html#Transform::operator" class="code">r</a>);</div><p>


</p>
<p>Finally, the <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> at the intersection point needs to be
transformed to world space; the <tt>primitive</tt>&rsquo;s intersection member will already have
transformed the <tt>SurfaceInteraction</tt> to its notion of world space, so
here we only need to apply the effect of the additional transformation held
here.

</p>
<p></p>
<span class="anchor" id="fragment-Transforminstancesintersectiondatatoworldspace-0"></span><div class="fragmentname">&lt;&lt;Transform instance&rsquo;s intersection data to world space&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (!InterpolatedPrimToWorld.<a href="../Geometry_and_Transformations/Transformations.html#Transform::IsIdentity" class="code">IsIdentity</a>())
    *isect = InterpolatedPrimToWorld(*isect);</div><p>


</p>
<p>

</p>
<p><span class="anchor" id="TransformedPrimitive::IntersectP"></span>
The rest of the geometric <a href="#Primitive"><tt>Primitive</tt></a> methods are forwarded on to the
shared instance, with the results similarly transformed as needed by
the <a href="#TransformedPrimitive"><tt>TransformedPrimitive</tt></a>&rsquo;s transformation.

</p>
<p></p>
<span class="anchor" id="fragment-TransformedPrimitivePublicMethods-1"></span><div class="fragmentname">&lt;&lt;TransformedPrimitive Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-TransformedPrimitivePublicMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="TransformedPrimitive::WorldBound"></span><a href="#Primitive::WorldBound" class="code">WorldBound</a>() const { 
    return <a href="#TransformedPrimitive::PrimitiveToWorld" class="code">PrimitiveToWorld</a>.<a href="../Geometry_and_Transformations/Animating_Transformations.html#AnimatedTransform::MotionBounds" class="code">MotionBounds</a>(<a href="#TransformedPrimitive::primitive" class="code">primitive</a>-&gt;<a href="#Primitive::WorldBound" class="code">WorldBound</a>());
}</div><p>


</p>
<p>The <tt>TransformedPrimitive</tt> <tt>GetAreaLight()</tt>,
<tt>GetMaterial()</tt>, and <tt>ComputeScattering Functions()</tt> methods
should never be called. The corresponding methods of the primitive that the
ray actually hit should always be called instead.  Therefore, any attempt to
call the <tt>TransformedPrimitive</tt> implementations of these methods (not shown
here) results in a run-time error.
<span class="anchor" id="TransformedPrimitive::GetAreaLight"></span>
<span class="anchor" id="TransformedPrimitive::Material"></span>
<span class="anchor" id="TransformedPrimitive::ComputeScatteringFunctions"></span>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <div class="container-fluid-nav">
    <!--  <ul class="nav navbar-nav navbar-center"> -->
      <span class="navbar-text" style="text-align: center;">
        Thanks to Enrico and 34 others for generously supporting <i>Physically
        Based Rendering</i> online
        through <a href="https://patreon.com/pbrbook">Patreon</a>.
    </span>
  </div>
</nav>

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>, &copy; 2004-2021 Matt Pharr, Wenzel Jakob, and Greg Humphreys under the <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a> license. (<a href="https://github.com/mmp/pbr-book-website/">github</a>)</span>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Primitives_and_Intersection_Acceleration/Aggregates.html">Primitives and Intersection Acceleration / Aggregates</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
