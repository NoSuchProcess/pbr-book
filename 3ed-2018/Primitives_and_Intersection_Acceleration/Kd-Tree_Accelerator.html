
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link href="https://fonts.googleapis.com/css?family=Domine|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
        
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <title>Kd-Tree Accelerator</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Primitives_and_Intersection_Acceleration.html">Primitives and Intersection Acceleration</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Kd-Tree Accelerator</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html">(Previous: Bounding Volume Hierarchies)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:accel-kd-tree"></span><h2>4.4 Kd-Tree Accelerator</h2><p>



</p>
<p><em>Binary space partitioning</em> (BSP) trees adaptively subdivide space
with planes.  A BSP tree starts with a bounding box that encompasses the
entire scene.  If the number of primitives in the box is greater than some
threshold, the box is split in half by a plane.  Primitives are then
associated with whichever half they overlap, and primitives that lie in both
halves are associated with both of them.  (This is in contrast to BVHs,
where each primitive is assigned to only one of the two subgroups after a
split.)

</p>
<p>The splitting process continues recursively either until each leaf region
in the resulting tree contains a sufficiently small number of primitives or
until a maximum depth is reached.  Because the splitting planes can be
placed at arbitrary positions inside the overall bound and because
different parts of 3D space can be refined to different degrees, BSP trees
can easily handle uneven distributions of geometry.

</p>
<p>Two variations of BSP trees are <em>kd-trees</em> and <em>octrees</em>.  A kd-tree
simply restricts the splitting plane to be perpendicular to one of the
coordinate axes; this makes both traversal and construction of the tree more
efficient, at the cost of some flexibility in how space is subdivided.  The
octree uses three axis-perpendicular planes to simultaneously
split the box into eight regions at each step (typically by splitting down
the center of the extent in each direction).  In this section, we will
implement a kd-tree for ray intersection acceleration in the <a href="#KdTreeAccel"><tt>KdTreeAccel</tt></a>
class.  Source code for this class can be found in the files
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/kdtreeaccel.h"><tt>accelerators/kdtreeaccel.h</tt></a><span class="anchor" id="acceleratorskdtreeaccel.h"></span> and
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/kdtreeaccel.cpp"><tt>accelerators/kdtreeaccel.cpp</tt></a>.
<span class="anchor" id="acceleratorskdtreeaccel.cpp"></span>

</p>
<p>

</p>
<p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelDeclarations-0"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Declarations&gt;&gt;=&nbsp;<a href="#fragment-KdTreeAccelDeclarations-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">class <span class="anchor" id="KdTreeAccel"></span>KdTreeAccel : public Aggregate {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-KdTreeAccelPublicMethods-0">KdTreeAccel Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-596" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-596"><i></i></a><div id="fragbit-596" class="collapse"><div class="fragmentcode">       KdTreeAccel(const std::vector&lt;std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt;&gt; &amp;p,
               int isectCost = 80, int traversalCost = 1, Float emptyBonus = 0.5,
               int maxPrims = 1, int maxDepth = -1);
       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> WorldBound() const { return bounds; }
       ~KdTreeAccel();
       bool Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect) const;
       bool IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray) const;</div></div>
private:
    &lt;&lt;<span class="fragmentname">KdTreeAccel Private Methods</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-597" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-597"><i></i></a><div id="fragbit-597" class="collapse"><div class="fragmentcode">       void buildTree(int nodeNum, const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;bounds,    
           const std::vector&lt;<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>&gt; &amp;primBounds, int *primNums, int nprims, int depth,
           const std::unique_ptr&lt;BoundEdge[]&gt; edges[3], int *prims0, int *prims1, int badRefines = 0);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-KdTreeAccelPrivateData-0">KdTreeAccel Private Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-598" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-598"><i></i></a><div id="fragbit-598" class="collapse"><div class="fragmentcode">       const int isectCost, traversalCost, maxPrims;
       const Float emptyBonus;
       std::vector&lt;std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt;&gt; primitives;
       std::vector&lt;int&gt; primitiveIndices;
       KdAccelNode *nodes;
       int nAllocedNodes, nextFreeNode;
       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> bounds;</div></div>
};</div><p>


</p>
<p>

</p>
<p>In addition to the primitives to be stored, the <a href="#KdTreeAccel"><tt>KdTreeAccel</tt></a>
constructor takes a few parameters that are used to guide the decisions
that will be made as the tree is built; these parameters are stored in
member variables (<tt>isectCost</tt>, <tt>traversalCost</tt>,
<tt>maxPrims</tt>,
<tt>maxDepth</tt>, and <tt>emptyBonus</tt>) for later use.  See
Figure&nbsp;<a href="#fig:kd-accel-basic">4.14</a> for an overview of how the tree is built.

</p>
<p></p>
<span class="anchor" id="fig:kd-accel-basic"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="kd%20tree%20splits.svg" title=""><img src="kd%20tree%20splits.svg" width=300 height=255 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 4.14: <span class="legend"> The kd-tree is built by recursively
splitting the bounding box of the scene geometry along one of the
coordinate axes.  Here, the first split is along the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> axis; it is placed
so that the triangle is precisely alone in the right region and the rest of
the primitives end up on the left.  The left region is then
refined a few more times with axis-aligned splitting planes.  The details
of the refinement criteria&mdash;which axis is used to split space at each step,
at which position along the axis the plane is placed, and at what point
refinement terminates&mdash;can all substantially affect the performance of the
tree in practice.</span>
</figcaption><p>
  

</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-KdTreeAccelMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">KdTreeAccel::KdTreeAccel(
        const std::vector&lt;std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt;&gt; &amp;p,
        int isectCost, int traversalCost, Float emptyBonus,
        int maxPrims, int maxDepth)
    : isectCost(isectCost), traversalCost(traversalCost),
      maxPrims(maxPrims), emptyBonus(emptyBonus), primitives(p) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Buildkd-treeforaccelerator-0">Build kd-tree for accelerator</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-599" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-599"><i></i></a><div id="fragbit-599" class="collapse"><div class="fragmentcode">       nextFreeNode = nAllocedNodes = 0;
       if (maxDepth &lt;= 0)
           maxDepth = std::round(8 + 1.3f * <a href="../Utilities/Main_Include_File.html#Log2Int" class="code">Log2Int</a>(primitives.size()));
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeboundsforkd-treeconstruction-0">Compute bounds for kd-tree construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-600" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-600"><i></i></a><div id="fragbit-600" class="collapse"><div class="fragmentcode">          std::vector&lt;<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>&gt; primBounds;
          for (const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;prim : <a href="#KdTreeAccel::primitives" class="code">primitives</a>) {
              <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> b = prim-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::WorldBound" class="code">WorldBound</a>();
              bounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(bounds, b);
              primBounds.push_back(b);
          }</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Allocateworkingmemoryforkd-treeconstruction-0">Allocate working memory for kd-tree construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-601" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-601"><i></i></a><div id="fragbit-601" class="collapse"><div class="fragmentcode">          std::unique_ptr&lt;BoundEdge[]&gt; edges[3];
          for (int i = 0; i &lt; 3; ++i)
              edges[i].reset(new BoundEdge[2 * <a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);
          std::unique_ptr&lt;int[]&gt; prims0(new int[<a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);
          std::unique_ptr&lt;int[]&gt; prims1(new int[(maxDepth+1) * <a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoprimNumsforkd-treeconstruction-0">Initialize <tt>primNums</tt> for kd-tree construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-602" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-602"><i></i></a><div id="fragbit-602" class="collapse"><div class="fragmentcode">          std::unique_ptr&lt;int[]&gt; primNums(new int[primitives.size()]);
          for (size_t i = 0; i &lt; primitives.size(); ++i)
              primNums[i] = i;</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Startrecursiveconstructionofkd-tree-0">Start recursive construction of kd-tree</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-603" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-603"><i></i></a><div id="fragbit-603" class="collapse"><div class="fragmentcode">          <a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(0, bounds, primBounds, primNums.get(), primitives.size(), 
                    maxDepth, edges, prims0.get(), prims1.get());</div></div></div></div>
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelPrivateData-0"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Private Data&gt;&gt;=&nbsp;<a href="#fragment-KdTreeAccelPrivateData-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">const int <span class="anchor" id="KdTreeAccel::isectCost"></span>isectCost, <span class="anchor" id="KdTreeAccel::traversalCost"></span>traversalCost, <span class="anchor" id="KdTreeAccel::maxPrims"></span>maxPrims;
const Float <span class="anchor" id="KdTreeAccel::emptyBonus"></span>emptyBonus;
std::vector&lt;std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt;&gt; <span class="anchor" id="KdTreeAccel::primitives"></span>primitives;</div><p>


</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#TreeRepresentation"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="TreeRepresentation"></span><h3>4.4.1  Tree Representation</h3><p>


</p>
<p>The kd-tree is a binary tree, where each interior node always has both 
children and where leaves of the tree store the primitives that overlap
them.  Each interior node must provide access to three pieces of
information:
</p>
<ul>
<li> Split axis: which of the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg>, or <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.086ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 467.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">z</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D467" d="M467 432c0 -4 -22 -52 -117 -145c-36 -36 -98 -90 -98 -90c-36 -31 -65 -56 -119 -114c9 3 27 3 27 3c21 0 36 -4 70 -17c21 -7 39 -13 59 -13c33 0 97 19 120 84c3 7 5 13 14 13c8 0 12 -5 12 -10c0 -27 -58 -154 -157 -154c-29 0 -47 16 -64 37c-25 29 -35 38 -58 38 c-32 0 -62 -27 -85 -62c-6 -11 -8 -13 -16 -13c0 0 -12 0 -12 10c0 7 35 64 103 131l90 84c19 16 103 88 139 131c-26 0 -37 0 -77 15c-23 8 -42 15 -63 15c-8 0 -66 -1 -85 -47c-2 -6 -4 -11 -13 -11s-12 6 -12 11c0 21 46 114 121 114c33 0 50 -20 69 -43 c15 -17 27 -32 51 -32s45 16 75 64c5 9 8 11 15 11c0 0 11 0 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D467" x="0" y="0"></use>
</g>
</svg> axes was split at
this node
<li> Split position: the position of the splitting plane along the axis
<li> Children: information about how to reach the two child nodes beneath
it
</ul><p>

Each leaf node needs to record only which primitives overlap it.

</p>
<p>It is worth going through a bit of trouble to ensure that all interior
nodes and many leaf nodes use just 8 bytes of memory (assuming 4-byte
<tt>Float</tt>s) because doing so ensures that eight nodes will
fit into a 64-byte cache line.  Because there are often many nodes in the tree
and because many nodes are generally accessed for each ray, minimizing the size of
the node representation substantially improves cache performance.  Our
initial implementation used a 16-byte node representation; when we reduced
the size to 8 bytes we obtained nearly a 20% speed increase.

</p>
<p>Both leaves and interior nodes are represented by the following
<a href="#KdAccelNode"><tt>KdAccelNode</tt></a> structure.  The comments after each <tt>union</tt> member
indicate whether a particular field is used for interior nodes, leaf nodes,
or both.

</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelLocalDeclarations-0"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Local Declarations&gt;&gt;=&nbsp;<a href="#fragment-KdTreeAccelLocalDeclarations-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">struct <span class="anchor" id="KdAccelNode"></span>KdAccelNode {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-KdAccelNodeMethods-0">KdAccelNode Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-604" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-604"><i></i></a><div id="fragbit-604" class="collapse"><div class="fragmentcode">       void InitLeaf(int *primNums, int np, std::vector&lt;int&gt; *primitiveIndices);
       void InitInterior(int axis, int ac, Float s) {
           <a href="#KdAccelNode::split" class="code">split</a> = s;
           <a href="#KdAccelNode::flags" class="code">flags</a> = axis;
           <a href="#KdAccelNode::aboveChild" class="code">aboveChild</a> |= (ac &lt;&lt; 2);
       }
       Float SplitPos() const { return <a href="#KdAccelNode::split" class="code">split</a>; }
       int nPrimitives() const { return <a href="#KdAccelNode::nPrims" class="code">nPrims</a> &gt;&gt; 2; }
       int SplitAxis() const { return <a href="#KdAccelNode::flags" class="code">flags</a> &amp; 3; }
       bool IsLeaf() const { return (<a href="#KdAccelNode::flags" class="code">flags</a> &amp; 3) == 3; }
       int AboveChild() const { return <a href="#KdAccelNode::aboveChild" class="code">aboveChild</a> &gt;&gt; 2; }</div></div>
    union {
        Float <span class="anchor" id="KdAccelNode::split"></span>split;                  // Interior
        int <span class="anchor" id="KdAccelNode::onePrimitive"></span>onePrimitive;             // Leaf
        int <span class="anchor" id="KdAccelNode::primitiveIndicesOffset"></span>primitiveIndicesOffset;   // Leaf
    };
    union {
        int <span class="anchor" id="KdAccelNode::flags"></span>flags;         // Both
        int <span class="anchor" id="KdAccelNode::nPrims"></span>nPrims;        // Leaf
        int <span class="anchor" id="KdAccelNode::aboveChild"></span>aboveChild;    // Interior
    };
};</div><p>


</p>
<p>The two low-order bits of the <a href="#KdAccelNode::flags"><tt>KdAccelNode::flags</tt></a> variable are used to
differentiate between interior nodes with <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg>, and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.086ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 467.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">z</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D467" d="M467 432c0 -4 -22 -52 -117 -145c-36 -36 -98 -90 -98 -90c-36 -31 -65 -56 -119 -114c9 3 27 3 27 3c21 0 36 -4 70 -17c21 -7 39 -13 59 -13c33 0 97 19 120 84c3 7 5 13 14 13c8 0 12 -5 12 -10c0 -27 -58 -154 -157 -154c-29 0 -47 16 -64 37c-25 29 -35 38 -58 38 c-32 0 -62 -27 -85 -62c-6 -11 -8 -13 -16 -13c0 0 -12 0 -12 10c0 7 35 64 103 131l90 84c19 16 103 88 139 131c-26 0 -37 0 -77 15c-23 8 -42 15 -63 15c-8 0 -66 -1 -85 -47c-2 -6 -4 -11 -13 -11s-12 6 -12 11c0 21 46 114 121 114c33 0 50 -20 69 -43 c15 -17 27 -32 51 -32s45 16 75 64c5 9 8 11 15 11c0 0 11 0 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D467" x="0" y="0"></use>
</g>
</svg> splits (where
these bits hold the values 0, 1, and 2, respectively) and leaf nodes (where
these bits hold the value 3).  It is relatively easy to store leaf nodes in
8 bytes: since the low 2 bits of <a href="#KdAccelNode::flags"><tt>KdAccelNode::flags</tt></a> are used to
indicate that this is a leaf, the upper 30 bits of
<a href="#KdAccelNode::nPrims"><tt>KdAccelNode::nPrims</tt></a> are available to record how many primitives
overlap it.  Then, if just a single primitive overlaps a <a href="#KdAccelNode"><tt>KdAccelNode</tt></a>
leaf, an integer index into the <a href="#KdTreeAccel::primitives"><tt>KdTreeAccel::primitives</tt></a> array
identifies the <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a>.  If more than one primitive overlaps, then
their indices are stored in a segment of
<a href="#KdTreeAccel::primitiveIndices"><tt>KdTreeAccel::primitiveIndices</tt></a>.  The offset to the first index for the
leaf is stored in <a href="#KdAccelNode::primitiveIndicesOffset"><tt>KdAccelNode::primitiveIndicesOffset</tt></a> and the indices
for the rest directly follow.

</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelPrivateData-1"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Private Data&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelPrivateData-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-KdTreeAccelPrivateData-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">std::vector&lt;int&gt; <span class="anchor" id="KdTreeAccel::primitiveIndices"></span>primitiveIndices;</div><p>


</p>
<p>Leaf nodes are easy to initialize, though we have to be careful with the
details since both <tt>flags</tt> and <tt>nPrims</tt> share the same storage;
we need to be careful to not clobber data for one of them while
initializing the other.  Furthermore, the number of primitives must be
shifted two bits to the left before being stored so that the low two bits
of <a href="#KdAccelNode::flags"><tt>KdAccelNode::flags</tt></a> can both be set to <tt>1</tt> to indicate that
this is a leaf node.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelMethodDefinitions-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-KdTreeAccelMethodDefinitions-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="KdAccelNode::InitLeaf"></span>KdAccelNode::InitLeaf(int *primNums, int np,
        std::vector&lt;int&gt; *primitiveIndices) {
    <a href="#KdAccelNode::flags" class="code">flags</a> = 3;
    <a href="#KdAccelNode::nPrims" class="code">nPrims</a> |= (np &lt;&lt; 2);
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Storeprimitiveidsforleafnode-0">Store primitive ids for leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-605" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-605"><i></i></a><div id="fragbit-605" class="collapse"><div class="fragmentcode">       if (np == 0)
           <a href="#KdAccelNode::onePrimitive" class="code">onePrimitive</a> = 0;
       else if (np == 1)
           <a href="#KdAccelNode::onePrimitive" class="code">onePrimitive</a> = primNums[0];
       else {
           <a href="#KdAccelNode::primitiveIndicesOffset" class="code">primitiveIndicesOffset</a> = primitiveIndices-&gt;size();
           for (int i = 0; i &lt; np; ++i)
               primitiveIndices-&gt;push_back(primNums[i]);
       }</div></div>
}</div><p>


</p>
<p>For leaf nodes with zero or one overlapping primitives, no additional
memory allocation is necessary thanks to the
<a href="#KdAccelNode::onePrimitive"><tt>KdAccelNode::onePrimitive</tt></a> field.  For the case where multiple
primitives overlap, storage is allocated in the <tt>primitiveIndices</tt>
array.

</p>
<p></p>
<span class="anchor" id="fragment-Storeprimitiveidsforleafnode-0"></span><div class="fragmentname">&lt;&lt;Store primitive ids for leaf node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (np == 0)
    <a href="#KdAccelNode::onePrimitive" class="code">onePrimitive</a> = 0;
else if (np == 1)
    <a href="#KdAccelNode::onePrimitive" class="code">onePrimitive</a> = primNums[0];
else {
    <a href="#KdAccelNode::primitiveIndicesOffset" class="code">primitiveIndicesOffset</a> = primitiveIndices-&gt;size();
    for (int i = 0; i &lt; np; ++i)
        primitiveIndices-&gt;push_back(primNums[i]);
}</div><p>


</p>
<p>Getting interior nodes down to 8 bytes is also reasonably straightforward.
A <tt>Float</tt> (which is 32 bits in size when <tt>Float</tt>s are defined to be
<tt>float</tt>s) stores the position along the chosen split axis where the
node splits space, and, as explained earlier, the lowest 2 bits of
<a href="#KdAccelNode::flags"><tt>KdAccelNode::flags</tt></a> are used to record which axis the node was split
along.  All that is left is to store enough information to find the two
children of the node as we&rsquo;re traversing the tree.

</p>
<p>Rather than storing two pointers or offsets, we lay the nodes out in a way
that lets us only store one child pointer: all of the nodes are allocated in
a single contiguous block of memory, and the child of an interior node that
is responsible for space below the splitting plane is always stored in the
array position immediately after its parent (this layout also improves cache
performance, by keeping at least one child close to its parent in memory).
The other child, representing space above the splitting plane, will end up
somewhere else in the array; a single integer offset,
<a href="#KdAccelNode::aboveChild"><tt>KdAccelNode::aboveChild</tt></a>, stores its position in the nodes array.
This representation is similar to the one used for BVH nodes in Section&nbsp;<a href="../Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#sec:compact-bvh">4.3.4</a>.

</p>
<p>Given all those conventions, the code to initialize an interior node is
straightforward.  As in the <tt>InitLeaf()</tt> method, it&rsquo;s important to
assign the value to <tt>flags</tt> before setting <tt>aboveChild</tt> and to
compute the logical OR of the shifted <tt>aboveChild</tt> value so as not to clobber the bits
stored in <tt>flags</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-KdAccelNodeMethods-0"></span><div class="fragmentname">&lt;&lt;KdAccelNode Methods&gt;&gt;=&nbsp;<a href="#fragment-KdAccelNodeMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="KdAccelNode::InitInterior"></span>InitInterior(int axis, int ac, Float s) {
    <a href="#KdAccelNode::split" class="code">split</a> = s;
    <a href="#KdAccelNode::flags" class="code">flags</a> = axis;
    <a href="#KdAccelNode::aboveChild" class="code">aboveChild</a> |= (ac &lt;&lt; 2);
}</div><p>


</p>
<p>Finally, we&rsquo;ll provide a few methods to extract various values from the
node, so that callers don&rsquo;t have to be aware of the details of its
representation in memory.

</p>
<p></p>
<span class="anchor" id="fragment-KdAccelNodeMethods-1"></span><div class="fragmentname">&lt;&lt;KdAccelNode Methods&gt;&gt;+=&nbsp;<a href="#fragment-KdAccelNodeMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">Float <span class="anchor" id="KdAccelNode::SplitPos"></span>SplitPos() const { return <a href="#KdAccelNode::split" class="code">split</a>; }
int <span class="anchor" id="KdAccelNode::nPrimitives"></span>nPrimitives() const { return <a href="#KdAccelNode::nPrims" class="code">nPrims</a> &gt;&gt; 2; }
int <span class="anchor" id="KdAccelNode::SplitAxis"></span>SplitAxis() const { return <a href="#KdAccelNode::flags" class="code">flags</a> &amp; 3; }
bool <span class="anchor" id="KdAccelNode::IsLeaf"></span>IsLeaf() const { return (<a href="#KdAccelNode::flags" class="code">flags</a> &amp; 3) == 3; }
int <span class="anchor" id="KdAccelNode::AboveChild"></span>AboveChild() const { return <a href="#KdAccelNode::aboveChild" class="code">aboveChild</a> &gt;&gt; 2; }</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#TreeConstruction"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:kdtree-accel-construction"></span><span id="TreeConstruction"></span><h3>4.4.2  Tree Construction</h3><p>



</p>
<p>The kd-tree is built with a recursive top-down algorithm.  At each step, we
have an axis-aligned region of space and a set of primitives that overlap that
region.  Either the region is split into two subregions and turned into an
interior node or a leaf node is created with the overlapping primitives, 
terminating the recursion.  

</p>
<p>As mentioned in the discussion of <a href="#KdAccelNode"><tt>KdAccelNode</tt></a>s, all tree nodes are
stored in a contiguous array. <a href="#KdTreeAccel::nextFreeNode"><tt>KdTreeAccel::nextFreeNode</tt></a> records the
next node in this array that is available, and
<a href="#KdTreeAccel::nAllocedNodes"><tt>KdTreeAccel::nAllocedNodes</tt></a> records the total number that have been
allocated.  By setting both of them to&nbsp;0 and not allocating any nodes at
start-up, the implementation here ensures that an allocation will be done
immediately when the first node of the tree is initialized.

</p>
<p>
It is also necessary to determine a maximum tree depth if one wasn&rsquo;t given
to the constructor.  Although the tree construction process will normally
terminate naturally at a reasonable depth, it is important to cap the
maximum depth so that the amount of memory used for the tree cannot grow
without bound in pathological cases.  We have found that the value
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.19ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 6109.6 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">8 plus 1.3 log left-parenthesis upper N right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-38" d="M457 168c0 -107 -95 -190 -208 -190c-105 0 -207 67 -207 173c0 99 86 155 144 184c-25 17 -62 42 -73 54c-42 47 -44 92 -44 110c0 93 81 167 181 167c91 0 180 -57 180 -149c0 -66 -49 -118 -121 -155c64 -40 80 -50 99 -71c38 -42 49 -87 49 -123zM386 517 c0 72 -64 124 -137 124c-71 0 -136 -42 -136 -103c0 -17 4 -51 50 -81l124 -80c60 35 99 83 99 140zM407 132c0 61 -47 91 -75 110l-123 78c-85 -47 -117 -111 -117 -169c0 -83 72 -145 158 -145c82 0 157 52 157 126Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2E" d="M192 53c0 -29 -24 -53 -53 -53s-53 24 -53 53s24 53 53 53s53 -24 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-33" d="M457 171c0 -102 -91 -193 -213 -193c-109 0 -202 66 -202 157c0 44 32 58 56 58c29 0 56 -20 56 -56c0 -38 -31 -60 -66 -55c35 -59 110 -76 153 -76c44 0 113 29 113 165c0 98 -37 166 -119 166h-44c-17 0 -24 0 -24 11c0 10 7 11 15 12c7 0 31 2 39 3c25 1 59 4 89 52 c26 44 28 102 28 114c0 90 -55 112 -96 112c-36 0 -102 -13 -133 -62c15 0 62 0 62 -50c0 -29 -20 -51 -51 -51c-29 0 -51 19 -51 52c0 76 76 136 177 136c96 0 184 -56 184 -138c0 -79 -58 -149 -140 -176c104 -21 167 -99 167 -181Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6C" d="M255 0l-111 3l-111 -3v31c67 0 78 0 78 45v520c0 49 -8 56 -78 56v31l144 11v-618c0 -45 11 -45 78 -45v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-67" d="M485 404c0 -23 -19 -30 -29 -30c-16 0 -29 12 -29 29c0 12 5 23 16 27c-3 1 -10 1 -10 1c-18 0 -54 -5 -90 -39c25 -23 41 -60 41 -97c0 -77 -69 -146 -162 -146c-19 0 -60 3 -99 31c-17 -20 -17 -43 -17 -47c0 -32 21 -63 53 -67c7 -1 50 -1 75 -1c61 0 119 0 172 -28 c51 -28 65 -79 65 -114c0 -78 -104 -129 -222 -129c-122 0 -221 55 -221 127c0 40 32 83 92 100c-31 20 -44 58 -44 89c0 35 18 68 31 83c-25 21 -47 59 -47 103c0 77 69 146 162 146c22 0 64 -3 106 -36c42 41 86 47 106 47c39 0 51 -32 51 -49zM309 296 c0 23 0 123 -87 123c-40 0 -63 -28 -71 -40c-15 -25 -16 -57 -16 -84c0 -23 0 -123 87 -123c40 0 63 28 71 40c15 25 16 57 16 84zM419 -79c0 86 -112 86 -198 86h-59c-44 -3 -82 -40 -82 -86c0 -53 69 -104 170 -104c98 0 169 50 169 104Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D441" d="M881 672c0 -19 -12 -20 -17 -20c-80 -3 -98 -34 -108 -74l-140 -557c-5 -18 -5 -21 -16 -21c-9 0 -12 2 -19 19l-249 589c-5 10 -5 12 -9 18l-132 -528c-3 -11 -4 -16 -4 -23c0 -20 8 -42 66 -44c11 0 20 -1 20 -11c0 -20 -13 -20 -18 -20c-33 0 -69 3 -103 3 c-33 0 -68 -3 -100 -3c-8 0 -13 4 -13 11c0 19 11 20 17 20c81 3 98 35 108 75l134 537c0 9 -63 9 -68 9c-19 0 -28 0 -28 11c0 20 9 20 29 20h134c23 0 24 -1 32 -19l221 -522l112 445c1 3 3 18 3 21c0 22 -11 43 -68 44c-8 0 -18 0 -18 11c0 20 12 20 18 20 c33 0 68 -3 102 -3c33 0 68 3 101 3c13 0 13 -11 13 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-38" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="722" y="0"></use>
<g transform="translate(1723,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2E" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-33" x="779" y="0"></use>
</g>
<g transform="translate(3169,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-6C"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6F" x="278" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-67" x="779" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="4449" y="0"></use>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D441" x="4838" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="5720" y="0"></use>
</g>
</svg> gives a reasonable maximum depth for a variety of scenes.

</p>
<p></p>
<span class="anchor" id="fragment-Buildkd-treeforaccelerator-0"></span><div class="fragmentname">&lt;&lt;Build kd-tree for accelerator&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">nextFreeNode = nAllocedNodes = 0;
if (maxDepth &lt;= 0)
    maxDepth = std::round(8 + 1.3f * <a href="../Utilities/Main_Include_File.html#Log2Int" class="code">Log2Int</a>(primitives.size()));
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computeboundsforkd-treeconstruction-0">Compute bounds for kd-tree construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-606" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-606"><i></i></a><div id="fragbit-606" class="collapse"><div class="fragmentcode">   std::vector&lt;<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>&gt; primBounds;
   for (const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;prim : <a href="#KdTreeAccel::primitives" class="code">primitives</a>) {
       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> b = prim-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::WorldBound" class="code">WorldBound</a>();
       bounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(bounds, b);
       primBounds.push_back(b);
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Allocateworkingmemoryforkd-treeconstruction-0">Allocate working memory for kd-tree construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-607" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-607"><i></i></a><div id="fragbit-607" class="collapse"><div class="fragmentcode">   std::unique_ptr&lt;BoundEdge[]&gt; edges[3];
   for (int i = 0; i &lt; 3; ++i)
       edges[i].reset(new BoundEdge[2 * <a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);
   std::unique_ptr&lt;int[]&gt; prims0(new int[<a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);
   std::unique_ptr&lt;int[]&gt; prims1(new int[(maxDepth+1) * <a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoprimNumsforkd-treeconstruction-0">Initialize <tt>primNums</tt> for kd-tree construction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-608" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-608"><i></i></a><div id="fragbit-608" class="collapse"><div class="fragmentcode">   std::unique_ptr&lt;int[]&gt; primNums(new int[primitives.size()]);
   for (size_t i = 0; i &lt; primitives.size(); ++i)
       primNums[i] = i;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Startrecursiveconstructionofkd-tree-0">Start recursive construction of kd-tree</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-609" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-609"><i></i></a><div id="fragbit-609" class="collapse"><div class="fragmentcode">   <a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(0, bounds, primBounds, primNums.get(), primitives.size(), 
             maxDepth, edges, prims0.get(), prims1.get());</div></div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelPrivateData-2"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Private Data&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelPrivateData-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-KdTreeAccelPrivateData-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">KdAccelNode *<span class="anchor" id="KdTreeAccel::nodes"></span>nodes;
int <span class="anchor" id="KdTreeAccel::nAllocedNodes"></span>nAllocedNodes, <span class="anchor" id="KdTreeAccel::nextFreeNode"></span>nextFreeNode;</div><p>


</p>
<p>Because the construction routine will be repeatedly using the bounding
boxes of the primitives along the way, they are stored in a <tt>vector</tt> before
tree construction starts so that the potentially slow
<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::WorldBound"><tt>Primitive::WorldBound()</tt></a> methods don&rsquo;t need to be called repeatedly.

</p>
<p></p>
<span class="anchor" id="fragment-Computeboundsforkd-treeconstruction-0"></span><div class="fragmentname">&lt;&lt;Compute bounds for kd-tree construction&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>&gt; primBounds;
for (const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;prim : <a href="#KdTreeAccel::primitives" class="code">primitives</a>) {
    <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> b = prim-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::WorldBound" class="code">WorldBound</a>();
    bounds = <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::Union" class="code">Union</a>(bounds, b);
    primBounds.push_back(b);
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelPrivateData-3"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Private Data&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelPrivateData-2"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="KdTreeAccel::bounds"></span>bounds;</div><p>


</p>
<p>One of the parameters to the tree construction routine is an array of
primitive indices
indicating which primitives overlap the current node. 
Because all primitives overlap the root node (when the recursion begins) we
start with an array initialized with values from zero through
<tt>primitives.size()-1</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonoprimNumsforkd-treeconstruction-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>primNums</tt> for kd-tree construction&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::unique_ptr&lt;int[]&gt; primNums(new int[primitives.size()]);
for (size_t i = 0; i &lt; primitives.size(); ++i)
    primNums[i] = i;</div><p>


</p>
<p><a href="#KdTreeAccel::buildTree"><tt>KdTreeAccel::buildTree()</tt></a> is called for each tree node. It is responsible
for deciding if the node should be an interior node or leaf and updating the
data structures appropriately.  The last three parameters, <tt>edges</tt>,
<tt>prims0</tt>, and <tt>prims1</tt>, are pointers to data that is allocated in the
&lt;&lt;<span class="fragmentname"><a href="#fragment-Allocateworkingmemoryforkd-treeconstruction-0">Allocate working memory for kd-tree construction</a></span>&gt;&gt; fragment, which
will be defined and documented in a few pages.

</p>
<p></p>
<span class="anchor" id="fragment-Startrecursiveconstructionofkd-tree-0"></span><div class="fragmentname">&lt;&lt;Start recursive construction of kd-tree&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(0, bounds, primBounds, primNums.get(), primitives.size(), 
          maxDepth, edges, prims0.get(), prims1.get());</div><p>


</p>
<p>

</p>
<p>

</p>
<p>The main parameters to <a href="#KdTreeAccel::buildTree"><tt>KdTreeAccel::buildTree()</tt></a> are the offset into
the array of <a href="#KdAccelNode"><tt>KdAccelNode</tt></a>s to use for the node that it creates,
<tt>nodeNum</tt>; the bounding box that gives the region of space that the
node covers, <tt>nodeBounds</tt>; and the indices of primitives that overlap
it, <tt>primNums</tt>.  The remainder of the parameters will be described
later, closer to where they are used.

</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelMethodDefinitions-2"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelMethodDefinitions-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-KdTreeAccelMethodDefinitions-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void KdTreeAccel::<span class="anchor" id="KdTreeAccel::buildTree"></span>buildTree(int nodeNum, const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;nodeBounds,
        const std::vector&lt;<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a>&gt; &amp;allPrimBounds, int *primNums,
        int nPrimitives, int depth,
        const std::unique_ptr&lt;BoundEdge[]&gt; edges[3], 
        int *prims0, int *prims1, int badRefines) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Getnextfreenodefrommononodesarray-0">Get next free node from <tt>nodes</tt> array</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-610" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-610"><i></i></a><div id="fragbit-610" class="collapse"><div class="fragmentcode">       if (<a href="#KdTreeAccel::nextFreeNode" class="code">nextFreeNode</a> == <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a>) {
           int nNewAllocNodes = std::max(2 * <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a>, 512);
           KdAccelNode *n = <a href="../Utilities/Memory_Management.html#AllocAligned" class="code">AllocAligned</a>&lt;KdAccelNode&gt;(nNewAllocNodes);
           if (<a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a> &gt; 0) {
               memcpy(n, <a href="#KdTreeAccel::nodes" class="code">nodes</a>, <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a> * sizeof(KdAccelNode));
               FreeAligned(<a href="#KdTreeAccel::nodes" class="code">nodes</a>);
           }
           <a href="#KdTreeAccel::nodes" class="code">nodes</a> = n;
           <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a> = nNewAllocNodes;
       }
       ++<a href="#KdTreeAccel::nextFreeNode" class="code">nextFreeNode</a>;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializeleafnodeifterminationcriteriamet-0">Initialize leaf node if termination criteria met</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-611" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-611"><i></i></a><div id="fragbit-611" class="collapse"><div class="fragmentcode">       if (nPrimitives &lt;= <a href="#KdTreeAccel::maxPrims" class="code">maxPrims</a> || depth == 0) {
           <a href="#KdTreeAccel::nodes" class="code">nodes</a>[nodeNum].<a href="#KdAccelNode::InitLeaf" class="code">InitLeaf</a>(primNums, nPrimitives, &amp;<a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>);
           return;
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializeinteriornodeandcontinuerecursion-0">Initialize interior node and continue recursion</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-612" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-612"><i></i></a><div id="fragbit-612" class="collapse"><div class="fragmentcode">       &lt;&lt;<span class="fragmentname"><a href="#fragment-Choosesplitaxispositionforinteriornode-0">Choose split axis position for interior node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-613" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-613"><i></i></a><div id="fragbit-613" class="collapse"><div class="fragmentcode">          int bestAxis = -1, bestOffset = -1;
          Float bestCost = <a href="../Shapes/Managing_Rounding_Error.html#Infinity" class="code">Infinity</a>;
          Float oldCost = <a href="#KdTreeAccel::isectCost" class="code">isectCost</a> * Float(nPrimitives);
          Float totalSA = nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
          Float invTotalSA = 1 / totalSA;
          <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> d = nodeBounds.pMax - nodeBounds.pMin;
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Choosewhichaxistosplitalong-0">Choose which axis to split along</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-614" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-614"><i></i></a><div id="fragbit-614" class="collapse"><div class="fragmentcode">             int axis = nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::MaximumExtent" class="code">MaximumExtent</a>();</div></div>
          int retries = 0;
          retrySplit:
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializeedgesformonoaxis-0">Initialize edges for <tt>axis</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-615" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-615"><i></i></a><div id="fragbit-615" class="collapse"><div class="fragmentcode">             for (int i = 0; i &lt; nPrimitives; ++i) {
                 int pn = primNums[i];
                 const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;bounds = allPrimBounds[pn];
                 edges[axis][2 * i] =     BoundEdge(bounds.pMin[axis], pn, true);
                 edges[axis][2 * i + 1] = BoundEdge(bounds.pMax[axis], pn, false);
             }
             &lt;&lt;<span class="fragmentname"><a href="#fragment-Sortmonoedgesformonoaxis-0">Sort <tt>edges</tt> for <tt>axis</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-616" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-616"><i></i></a><div id="fragbit-616" class="collapse"><div class="fragmentcode">                std::sort(&amp;edges[axis][0], &amp;edges[axis][2*nPrimitives],
                    [](const BoundEdge &amp;e0, const BoundEdge &amp;e1) -&gt; bool {
                        if (e0.<a href="#BoundEdge::t" class="code">t</a> == e1.<a href="#BoundEdge::t" class="code">t</a>)
                            return (int)e0.<a href="#BoundEdge::type" class="code">type</a> &lt; (int)e1.<a href="#BoundEdge::type" class="code">type</a>;
                        else return e0.<a href="#BoundEdge::t" class="code">t</a> &lt; e1.<a href="#BoundEdge::t" class="code">t</a>; 
                    });</div></div></div></div>
          &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostofallsplitsformonoaxistofindbest-0">Compute cost of all splits for <tt>axis</tt> to find best</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-617" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-617"><i></i></a><div id="fragbit-617" class="collapse"><div class="fragmentcode">             int nBelow = 0, nAbove = nPrimitives;
             for (int i = 0; i &lt; 2 * nPrimitives; ++i) {
                 if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::End) --nAbove;
                 Float edgeT = edges[axis][i].<a href="#BoundEdge::t" class="code">t</a>;
                 if (edgeT &gt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis] &amp;&amp;
                     edgeT &lt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis]) {
                     &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforsplitatmonoithedge-0">Compute cost for split at <tt>i</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-618" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-618"><i></i></a><div id="fragbit-618" class="collapse"><div class="fragmentcode">                        &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputechildsurfaceareasforsplitatmonoedgeT-0">Compute child surface areas for split at <tt>edgeT</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-619" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-619"><i></i></a><div id="fragbit-619" class="collapse"><div class="fragmentcode">                           int otherAxis0 = (axis + 1) % 3, otherAxis1 = (axis + 2) % 3;
                           Float belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                                (edgeT - nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis]) * 
                                                (d[otherAxis0] + d[otherAxis1]));
                           Float aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                                (nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis] - edgeT) * 
                                                (d[otherAxis0] + d[otherAxis1]));</div></div>
                        Float pBelow = belowSA * invTotalSA; 
                        Float pAbove = aboveSA * invTotalSA;
                        Float eb = (nAbove == 0 || nBelow == 0) ? emptyBonus : 0;
                        Float cost = traversalCost + 
                                     isectCost * (1 - eb) * (pBelow * nBelow + pAbove * nAbove);
                        &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatebestsplitifthisislowestcostsofar-0">Update best split if this is lowest cost so far</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-620" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-620"><i></i></a><div id="fragbit-620" class="collapse"><div class="fragmentcode">                           if (cost &lt; bestCost)  {
                               bestCost = cost;
                               bestAxis = axis;
                               bestOffset = i;
                           }</div></div></div></div>
                 }
                 if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::Start) ++nBelow;
             }
             </div></div></div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Createleafifnogoodsplitswerefound-0">Create leaf if no good splits were found</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-621" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-621"><i></i></a><div id="fragbit-621" class="collapse"><div class="fragmentcode">          if (bestAxis == -1 &amp;&amp; retries &lt; 2) {
              ++retries;
              axis = (axis + 1) % 3;
              goto retrySplit;
          }
          if (bestCost &gt; oldCost) ++badRefines;
          if ((bestCost &gt; 4 * oldCost &amp;&amp; nPrimitives &lt; 16) || 
              bestAxis == -1 || badRefines == 3) {
              nodes[nodeNum].<a href="#KdAccelNode::InitLeaf" class="code">InitLeaf</a>(primNums, nPrimitives, &amp;<a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>);
              return; 
          }</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Classifyprimitiveswithrespecttosplit-0">Classify primitives with respect to split</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-622" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-622"><i></i></a><div id="fragbit-622" class="collapse"><div class="fragmentcode">          int n0 = 0, n1 = 0;
          for (int i = 0; i &lt; bestOffset; ++i)
              if (edges[bestAxis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::End" class="code">EdgeType</a>::Start)
                  prims0[n0++] = edges[bestAxis][i].<a href="#BoundEdge::primNum" class="code">primNum</a>;
          for (int i = bestOffset + 1; i &lt; 2 * nPrimitives; ++i)
              if (edges[bestAxis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::End" class="code">EdgeType</a>::End)
                  prims1[n1++] = edges[bestAxis][i].<a href="#BoundEdge::primNum" class="code">primNum</a>;</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Recursivelyinitializechildrennodes-0">Recursively initialize children nodes</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-623" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-623"><i></i></a><div id="fragbit-623" class="collapse"><div class="fragmentcode">          Float tSplit = edges[bestAxis][bestOffset].<a href="#BoundEdge::t" class="code">t</a>;
          <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> bounds0 = nodeBounds, bounds1 = nodeBounds;
          bounds0.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[bestAxis] = bounds1.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[bestAxis] = tSplit;
          <a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(nodeNum + 1, bounds0, allPrimBounds, prims0, n0,
                    depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);
          int aboveChild = <a href="#KdTreeAccel::nextFreeNode" class="code">nextFreeNode</a>;
          nodes[nodeNum].<a href="#KdAccelNode::InitInterior" class="code">InitInterior</a>(bestAxis, aboveChild, tSplit);
          <a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(aboveChild, bounds1, allPrimBounds, prims1, n1, 
                    depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);</div></div></div></div>
}</div><p>


</p>
<p>If all of the allocated nodes have been used up, node memory is reallocated
with twice as many entries and the old values are copied.  The first
time <a href="#KdTreeAccel::buildTree"><tt>KdTreeAccel::buildTree()</tt></a> is called,
<a href="#KdTreeAccel::nAllocedNodes"><tt>KdTreeAccel::nAllocedNodes</tt></a> is&nbsp;0 and an initial block of tree
nodes is allocated.

</p>
<p></p>
<span class="anchor" id="fragment-Getnextfreenodefrommononodesarray-0"></span><div class="fragmentname">&lt;&lt;Get next free node from <tt>nodes</tt> array&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (<a href="#KdTreeAccel::nextFreeNode" class="code">nextFreeNode</a> == <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a>) {
    int nNewAllocNodes = std::max(2 * <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a>, 512);
    KdAccelNode *n = <a href="../Utilities/Memory_Management.html#AllocAligned" class="code">AllocAligned</a>&lt;KdAccelNode&gt;(nNewAllocNodes);
    if (<a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a> &gt; 0) {
        memcpy(n, <a href="#KdTreeAccel::nodes" class="code">nodes</a>, <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a> * sizeof(KdAccelNode));
        FreeAligned(<a href="#KdTreeAccel::nodes" class="code">nodes</a>);
    }
    <a href="#KdTreeAccel::nodes" class="code">nodes</a> = n;
    <a href="#KdTreeAccel::nAllocedNodes" class="code">nAllocedNodes</a> = nNewAllocNodes;
}
++<a href="#KdTreeAccel::nextFreeNode" class="code">nextFreeNode</a>;</div><p>


</p>
<p>A leaf node is created (stopping the recursion) either if there are a
sufficiently small number of primitives in the region or if the maximum depth
has been reached.  The <tt>depth</tt> parameter starts out as the tree&rsquo;s maximum
depth and is decremented at each level.

</p>
<p></p>
<span class="anchor" id="fragment-Initializeleafnodeifterminationcriteriamet-0"></span><div class="fragmentname">&lt;&lt;Initialize leaf node if termination criteria met&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (nPrimitives &lt;= <a href="#KdTreeAccel::maxPrims" class="code">maxPrims</a> || depth == 0) {
    <a href="#KdTreeAccel::nodes" class="code">nodes</a>[nodeNum].<a href="#KdAccelNode::InitLeaf" class="code">InitLeaf</a>(primNums, nPrimitives, &amp;<a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>);
    return;
}</div><p>


</p>
<p>If this is an internal node, it is necessary to choose a splitting plane,
classify the primitives with respect to that plane, and recurse.

</p>
<p></p>
<span class="anchor" id="fragment-Initializeinteriornodeandcontinuerecursion-0"></span><div class="fragmentname">&lt;&lt;Initialize interior node and continue recursion&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-Choosesplitaxispositionforinteriornode-0">Choose split axis position for interior node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-624" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-624"><i></i></a><div id="fragbit-624" class="collapse"><div class="fragmentcode">   int bestAxis = -1, bestOffset = -1;
   Float bestCost = <a href="../Shapes/Managing_Rounding_Error.html#Infinity" class="code">Infinity</a>;
   Float oldCost = <a href="#KdTreeAccel::isectCost" class="code">isectCost</a> * Float(nPrimitives);
   Float totalSA = nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
   Float invTotalSA = 1 / totalSA;
   <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> d = nodeBounds.pMax - nodeBounds.pMin;
   &lt;&lt;<span class="fragmentname"><a href="#fragment-Choosewhichaxistosplitalong-0">Choose which axis to split along</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-625" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-625"><i></i></a><div id="fragbit-625" class="collapse"><div class="fragmentcode">      int axis = nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::MaximumExtent" class="code">MaximumExtent</a>();</div></div>
   int retries = 0;
   retrySplit:
   &lt;&lt;<span class="fragmentname"><a href="#fragment-Initializeedgesformonoaxis-0">Initialize edges for <tt>axis</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-626" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-626"><i></i></a><div id="fragbit-626" class="collapse"><div class="fragmentcode">      for (int i = 0; i &lt; nPrimitives; ++i) {
          int pn = primNums[i];
          const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;bounds = allPrimBounds[pn];
          edges[axis][2 * i] =     BoundEdge(bounds.pMin[axis], pn, true);
          edges[axis][2 * i + 1] = BoundEdge(bounds.pMax[axis], pn, false);
      }
      &lt;&lt;<span class="fragmentname"><a href="#fragment-Sortmonoedgesformonoaxis-0">Sort <tt>edges</tt> for <tt>axis</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-627" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-627"><i></i></a><div id="fragbit-627" class="collapse"><div class="fragmentcode">         std::sort(&amp;edges[axis][0], &amp;edges[axis][2*nPrimitives],
             [](const BoundEdge &amp;e0, const BoundEdge &amp;e1) -&gt; bool {
                 if (e0.<a href="#BoundEdge::t" class="code">t</a> == e1.<a href="#BoundEdge::t" class="code">t</a>)
                     return (int)e0.<a href="#BoundEdge::type" class="code">type</a> &lt; (int)e1.<a href="#BoundEdge::type" class="code">type</a>;
                 else return e0.<a href="#BoundEdge::t" class="code">t</a> &lt; e1.<a href="#BoundEdge::t" class="code">t</a>; 
             });</div></div></div></div>
   &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostofallsplitsformonoaxistofindbest-0">Compute cost of all splits for <tt>axis</tt> to find best</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-628" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-628"><i></i></a><div id="fragbit-628" class="collapse"><div class="fragmentcode">      int nBelow = 0, nAbove = nPrimitives;
      for (int i = 0; i &lt; 2 * nPrimitives; ++i) {
          if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::End) --nAbove;
          Float edgeT = edges[axis][i].<a href="#BoundEdge::t" class="code">t</a>;
          if (edgeT &gt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis] &amp;&amp;
              edgeT &lt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis]) {
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforsplitatmonoithedge-0">Compute cost for split at <tt>i</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-629" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-629"><i></i></a><div id="fragbit-629" class="collapse"><div class="fragmentcode">                 &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputechildsurfaceareasforsplitatmonoedgeT-0">Compute child surface areas for split at <tt>edgeT</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-630" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-630"><i></i></a><div id="fragbit-630" class="collapse"><div class="fragmentcode">                    int otherAxis0 = (axis + 1) % 3, otherAxis1 = (axis + 2) % 3;
                    Float belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                         (edgeT - nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis]) * 
                                         (d[otherAxis0] + d[otherAxis1]));
                    Float aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                         (nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis] - edgeT) * 
                                         (d[otherAxis0] + d[otherAxis1]));</div></div>
                 Float pBelow = belowSA * invTotalSA; 
                 Float pAbove = aboveSA * invTotalSA;
                 Float eb = (nAbove == 0 || nBelow == 0) ? emptyBonus : 0;
                 Float cost = traversalCost + 
                              isectCost * (1 - eb) * (pBelow * nBelow + pAbove * nAbove);
                 &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatebestsplitifthisislowestcostsofar-0">Update best split if this is lowest cost so far</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-631" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-631"><i></i></a><div id="fragbit-631" class="collapse"><div class="fragmentcode">                    if (cost &lt; bestCost)  {
                        bestCost = cost;
                        bestAxis = axis;
                        bestOffset = i;
                    }</div></div></div></div>
          }
          if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::Start) ++nBelow;
      }
      </div></div></div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Createleafifnogoodsplitswerefound-0">Create leaf if no good splits were found</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-632" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-632"><i></i></a><div id="fragbit-632" class="collapse"><div class="fragmentcode">   if (bestAxis == -1 &amp;&amp; retries &lt; 2) {
       ++retries;
       axis = (axis + 1) % 3;
       goto retrySplit;
   }
   if (bestCost &gt; oldCost) ++badRefines;
   if ((bestCost &gt; 4 * oldCost &amp;&amp; nPrimitives &lt; 16) || 
       bestAxis == -1 || badRefines == 3) {
       nodes[nodeNum].<a href="#KdAccelNode::InitLeaf" class="code">InitLeaf</a>(primNums, nPrimitives, &amp;<a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>);
       return; 
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Classifyprimitiveswithrespecttosplit-0">Classify primitives with respect to split</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-633" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-633"><i></i></a><div id="fragbit-633" class="collapse"><div class="fragmentcode">   int n0 = 0, n1 = 0;
   for (int i = 0; i &lt; bestOffset; ++i)
       if (edges[bestAxis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::End" class="code">EdgeType</a>::Start)
           prims0[n0++] = edges[bestAxis][i].<a href="#BoundEdge::primNum" class="code">primNum</a>;
   for (int i = bestOffset + 1; i &lt; 2 * nPrimitives; ++i)
       if (edges[bestAxis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::End" class="code">EdgeType</a>::End)
           prims1[n1++] = edges[bestAxis][i].<a href="#BoundEdge::primNum" class="code">primNum</a>;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Recursivelyinitializechildrennodes-0">Recursively initialize children nodes</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-634" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-634"><i></i></a><div id="fragbit-634" class="collapse"><div class="fragmentcode">   Float tSplit = edges[bestAxis][bestOffset].<a href="#BoundEdge::t" class="code">t</a>;
   <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> bounds0 = nodeBounds, bounds1 = nodeBounds;
   bounds0.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[bestAxis] = bounds1.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[bestAxis] = tSplit;
   <a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(nodeNum + 1, bounds0, allPrimBounds, prims0, n0,
             depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);
   int aboveChild = <a href="#KdTreeAccel::nextFreeNode" class="code">nextFreeNode</a>;
   nodes[nodeNum].<a href="#KdAccelNode::InitInterior" class="code">InitInterior</a>(bestAxis, aboveChild, tSplit);
   <a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(aboveChild, bounds1, allPrimBounds, prims1, n1, 
             depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);</div></div></div><p>


</p>
<p>Our implementation chooses a split using the SAH
introduced in Section&nbsp;<a href="../Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#sec:sah">4.3.2</a>.  The SAH is applicable to kd-trees as
well as BVHs; here, the estimated cost is computed for a series of
candidate splitting planes in the node, and the split that gives the lowest
cost is chosen.

</p>
<p>In the implementation here, the intersection cost <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.277ex" height="2.343ex" style="vertical-align: -0.671ex;" viewBox="0 -719.6 1841.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal i normal s normal e normal c normal t</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
</g>
</svg> and the
traversal cost <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.046ex" height="2.343ex" style="vertical-align: -0.671ex;" viewBox="0 -719.6 1742.1 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal t normal r normal a normal v</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-72" d="M364 381c0 -32 -25 -44 -43 -44c-22 0 -43 15 -43 43c0 26 20 38 23 39c-2 1 -4 1 -11 1c-76 0 -118 -89 -118 -188v-154c0 -36 2 -47 76 -47h21v-31c-40 3 -87 3 -127 3l-114 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l139 11v-110c14 43 50 110 123 110 c43 0 74 -29 74 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-72" x="389" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="782" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-76" x="1282" y="0"></use>
</g>
</g>
</svg> can be set by the user; their default values
are 80 and 1, respectively.  Ultimately, it is the ratio of these two
values that determines the behavior of the tree-building
algorithm.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="Many other implementations of this approach seem to use
  values for these costs that are much closer together, sometimes even
  approaching equal values (for example, see Hurley et al. 2002).  The
  values used here gave the best performance for a number of test scenes in
  <tt>pbrt</tt>.  We suspect that this discrepancy is due to the fact that
  ray&ndash;primitive intersection tests in <tt>pbrt</tt> require two virtual function
  calls and a ray world-to-object-space transformation, in addition to the
  cost of performing the actual intersection test.  Highly optimized ray
  tracers that only support triangle primitives don&rsquo;t pay any of that
  additional cost.  See Section&nbsp;17.1.1 for further discussion
  of this design trade-off.">
      <sup>&dagger;</sup>
    </button>
		
The greater ratio between these values compared to the values
used for BVH construction reflects the fact that visiting a kd-tree node is
less expensive than visiting a BVH node.

</p>
<p>One modification to the SAH used for BVH trees is that for kd-trees it is
worth giving a slight preference to choosing splits where one of the
children has no primitives overlapping it, since rays passing through these
regions can immediately advance to the next kd-tree node without any
ray&ndash;primitive intersection tests.  Thus, the revised costs for unsplit and
split regions are, respectively,
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">
<div class="displaymath"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="55.186ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 23760.4 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal i normal s normal e normal c normal t Baseline upper N and t Subscript normal t normal r normal a normal v Baseline plus left-parenthesis 1 minus b Subscript normal e Baseline right-parenthesis left-parenthesis p Subscript upper B Baseline upper N Subscript upper B Baseline t Subscript normal i normal s normal e normal c normal t Baseline plus p Subscript upper A Baseline upper N Subscript upper A Baseline t Subscript normal i normal s normal e normal c normal t Baseline right-parenthesis comma</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-63" d="M415 119c0 -10 -32 -130 -166 -130c-116 0 -215 99 -215 227c0 124 92 232 217 232c77 0 153 -39 153 -107c0 -30 -20 -47 -46 -47c-28 0 -46 20 -46 46c0 13 6 43 47 46c-35 36 -98 37 -107 37c-53 0 -135 -42 -135 -205c0 -161 88 -204 141 -204c37 0 102 12 131 105 c2 6 4 10 13 10c3 0 13 0 13 -10Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D441" d="M881 672c0 -19 -12 -20 -17 -20c-80 -3 -98 -34 -108 -74l-140 -557c-5 -18 -5 -21 -16 -21c-9 0 -12 2 -19 19l-249 589c-5 10 -5 12 -9 18l-132 -528c-3 -11 -4 -16 -4 -23c0 -20 8 -42 66 -44c11 0 20 -1 20 -11c0 -20 -13 -20 -18 -20c-33 0 -69 3 -103 3 c-33 0 -68 -3 -100 -3c-8 0 -13 4 -13 11c0 19 11 20 17 20c81 3 98 35 108 75l134 537c0 9 -63 9 -68 9c-19 0 -28 0 -28 11c0 20 9 20 29 20h134c23 0 24 -1 32 -19l221 -522l112 445c1 3 3 18 3 21c0 22 -11 43 -68 44c-8 0 -18 0 -18 11c0 20 12 20 18 20 c33 0 68 -3 102 -3c33 0 68 3 101 3c13 0 13 -11 13 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-64" d="M527 0l-147 -11v66c-25 -32 -70 -66 -134 -66c-114 0 -212 99 -212 226c0 129 105 227 223 227c54 0 97 -26 126 -62v216c0 49 -8 56 -78 56v31l144 11v-607c0 -49 8 -56 78 -56v-31zM380 118v205c0 18 0 20 -11 37c-31 45 -73 60 -108 60c-54 0 -92 -33 -113 -64 c-29 -45 -31 -105 -31 -142c0 -41 3 -98 29 -139c24 -38 60 -64 105 -64c43 0 88 22 118 70c11 17 11 19 11 37Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-72" d="M364 381c0 -32 -25 -44 -43 -44c-22 0 -43 15 -43 43c0 26 20 38 23 39c-2 1 -4 1 -11 1c-76 0 -118 -89 -118 -188v-154c0 -36 2 -47 76 -47h21v-31c-40 3 -87 3 -127 3l-114 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l139 11v-110c14 43 50 110 123 110 c43 0 74 -29 74 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-76" d="M508 400c-66 -1 -83 -44 -92 -67l-131 -325c-4 -10 -8 -19 -21 -19s-15 5 -21 19l-144 355c-13 31 -17 37 -80 37v31c30 -2 70 -3 97 -3l109 3v-31c-18 0 -57 0 -57 -26c0 0 0 -4 6 -17l112 -279l102 255c4 11 6 15 6 24c0 19 -11 42 -48 43v31l87 -3c23 0 52 1 75 3v-31 Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2B" d="M722 250c0 -11 -9 -20 -20 -20h-293v-293c0 -11 -9 -20 -20 -20s-20 9 -20 20v293h-293c-11 0 -20 9 -20 20s9 20 20 20h293v293c0 11 9 20 20 20s20 -9 20 -20v-293h293c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44F" d="M415 282c0 -144 -123 -293 -241 -293c-74 0 -127 62 -127 157c0 35 4 51 16 101l82 326c5 21 14 55 14 62c0 10 -2 17 -50 17c-15 0 -24 0 -24 12c0 18 11 19 19 20c26 2 99 10 122 10c13 0 13 -11 13 -11l-74 -301c30 31 71 60 117 60c80 0 133 -69 133 -160zM343 326 c0 64 -27 94 -63 94c-26 0 -71 -15 -120 -80c-9 -11 -9 -13 -15 -35l-22 -92c-16 -63 -16 -82 -16 -101c0 -74 33 -101 67 -101c39 0 85 36 118 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45D" d="M490 282c0 -147 -125 -293 -241 -293c-51 0 -79 35 -92 64c-7 -25 -49 -188 -49 -200c0 -9 0 -16 50 -16c14 0 24 0 24 -11c0 -20 -13 -20 -18 -20c-32 0 -66 3 -99 3c-28 0 -57 -3 -84 -3c-8 0 -13 4 -13 12c0 19 11 19 23 19c44 0 46 7 54 41l112 445c4 17 7 28 7 51 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c37 0 80 -21 90 -75c33 39 81 75 131 75c76 0 133 -66 133 -160zM418 326c0 59 -24 94 -64 94c-17 0 -46 -7 -81 -38c-18 -15 -45 -43 -52 -70 l-49 -196c-3 -12 -3 -16 -3 -16c0 -6 13 -89 79 -89c37 0 85 33 119 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNNORMAL-1D441" x="1841" y="0"></use>
<g transform="translate(3722,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-61"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-6E" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-64" x="1057" y="0"></use>
</g>
<g transform="translate(6336,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-72" x="389" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="782" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-76" x="1282" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="8300" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="9301" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-31" x="9690" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="10413" y="0"></use>
<g transform="translate(11414,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="607" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="12258" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="12647" y="0"></use>
<g transform="translate(13037,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="712" y="-213"></use>
</g>
<g transform="translate(14177,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D441" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D435" x="1136" y="-213"></use>
</g>
<g transform="translate(15618,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2B" x="17681" y="0"></use>
<g transform="translate(18682,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="712" y="-230"></use>
</g>
<g transform="translate(19816,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D441" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNNORMAL-1D434" x="1136" y="-230"></use>
</g>
<g transform="translate(21251,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="278" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="673" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-63" x="1117" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1562" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="23092" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="23481" y="0"></use>
</g>
</svg>
</div>
<p>

where <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.96ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 843.8 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">b Subscript normal e</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44F" d="M415 282c0 -144 -123 -293 -241 -293c-74 0 -127 62 -127 157c0 35 4 51 16 101l82 326c5 21 14 55 14 62c0 10 -2 17 -50 17c-15 0 -24 0 -24 12c0 18 11 19 19 20c26 2 99 10 122 10c13 0 13 -11 13 -11l-74 -301c30 31 71 60 117 60c80 0 133 -69 133 -160zM343 326 c0 64 -27 94 -63 94c-26 0 -71 -15 -120 -80c-9 -11 -9 -13 -15 -35l-22 -92c-16 -63 -16 -82 -16 -101c0 -74 33 -101 67 -101c39 0 85 36 118 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-65" d="M415 119c0 -19 -45 -130 -167 -130c-115 0 -220 97 -220 231c0 125 92 228 208 228c125 0 179 -97 179 -196c0 -21 -3 -21 -25 -21h-279c0 -36 0 -102 30 -150c23 -37 63 -67 113 -67c10 0 100 0 135 103c2 8 4 14 13 14c5 0 13 -2 13 -12zM349 252 c0 39 -10 174 -113 174c-34 0 -118 -25 -124 -174h237Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-65" x="607" y="-213"></use>
</g>
</svg> is a &ldquo;bonus&rdquo; value that is zero unless one of the two regions is
completely empty, in which case it takes on a value between&nbsp;0 and&nbsp;1.

</p>
<p>Given a way to compute the probabilities for the cost model, the only
problem to address is how to generate candidate splitting positions and how
to efficiently compute the cost for each candidate.  It can be shown that
the minimum cost with this model will be attained at a split that is
coincident with one of the faces of one of the primitive&rsquo;s bounding
boxes&mdash;there&rsquo;s no need to consider splits at intermediate positions.  (To
convince yourself of this, consider the behavior of the cost function
between the edges of the faces.)  Here, we will consider all bounding box
faces inside the region for one or more of the three coordinate axes.

</p>
<p>The cost for checking all of these candidates thus can be kept relatively
low with a carefully structured algorithm.  To compute these costs, we will
sweep across the projections of the bounding boxes onto each axis and keep
track of which gives the lowest cost
(Figure&nbsp;<a href="#fig:kd-bbox-projections">4.15</a>). Each bounding box has two edges on
each axis, each of which is represented by an instance of the
<a href="#BoundEdge"><tt>BoundEdge</tt></a> structure.  This structure records the position of the edge
along the axis, whether it represents the start or end of a bounding box
(going from low to high along the axis), and which primitive it is
associated with.

</p>
<p></p>
<span class="anchor" id="fig:kd-bbox-projections"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="kd%20tree%20projected%20bboxes.svg" title=""><img src="kd%20tree%20projected%20bboxes.svg" width=562 height=256 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 4.15: <span class="legend"> Given an axis along which we&rsquo;d like
to consider possible splits, the primitives&rsquo; bounding boxes are projected
onto the axis, which leads to an efficient algorithm to track how many
primitives would be on each side of a particular splitting plane.  Here,
for example, a split at <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.284ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 983.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">a 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44E" d="M498 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-48 0 -83 33 -91 75c-60 -71 -110 -75 -130 -75c-78 0 -133 66 -133 160c0 146 124 293 241 293c45 0 74 -27 92 -64c3 22 18 44 42 44c17 0 29 -10 29 -27c0 -4 0 -6 -7 -34l-36 -140l-22 -90 c-11 -44 -13 -52 -13 -74c0 -20 3 -46 30 -46c41 0 59 59 76 124c3 14 4 18 14 18c3 0 12 0 12 -10zM361 332c0 6 -14 88 -79 88c-40 0 -85 -37 -116 -96c-23 -46 -55 -169 -55 -219c0 -39 14 -94 64 -94c28 0 69 16 113 71c15 17 15 19 20 37l50 196c1 5 3 11 3 17Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44E" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="748" y="-213"></use>
</g>
</svg> would leave <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 750.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper A</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D434" d="M721 20c0 -20 -12 -20 -18 -20c-25 0 -88 3 -113 3c-41 0 -84 -3 -125 -3c0 0 -14 0 -14 11c0 20 10 20 24 20c20 0 72 3 72 33c0 10 -14 146 -16 167h-251c-68 -116 -69 -116 -76 -128c-8 -14 -14 -25 -14 -37c0 -25 24 -33 47 -35c7 0 16 -1 16 -12 c0 -19 -13 -19 -19 -19c-32 0 -67 3 -100 3c-28 0 -59 -3 -86 -3c-8 0 -13 5 -13 11c0 19 9 19 21 20c44 3 83 17 123 84l348 584c6 10 10 17 26 17c17 0 17 -4 19 -24l61 -625c3 -29 3 -36 65 -36c13 0 23 0 23 -11zM528 262l-32 330l-197 -330h229Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D434" x="0" y="0"></use>
</g>
</svg> completely below the
splitting plane, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 759.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper B</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D435" d="M756 545c0 -95 -105 -169 -209 -188c97 -11 155 -69 155 -141c0 -98 -118 -216 -276 -216h-357c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 10 20 29 20h336 c120 0 186 -64 186 -138zM665 549c0 44 -21 103 -109 103h-129c-43 0 -45 -3 -54 -38l-62 -248h146c122 0 208 95 208 183zM609 227c0 43 -19 117 -115 117h-189l-69 -279c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h136c118 0 207 97 207 196Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D435" x="0" y="0"></use>
</g>
</svg> straddling it, and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 760.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper C</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D436" d="M760 695l-63 -255c-5 -18 -5 -20 -18 -20c-4 0 -15 0 -15 10s3 11 3 51c0 116 -59 193 -161 193c-89 0 -183 -50 -244 -121c-100 -117 -121 -279 -121 -336c0 -156 106 -208 196 -208c52 0 115 17 184 73c69 58 92 129 101 158c2 8 7 10 13 10c0 0 12 0 12 -10 c0 -3 -17 -94 -110 -176c-53 -46 -129 -86 -216 -86c-153 0 -271 109 -271 274c0 232 225 453 448 453c111 0 157 -75 166 -89l70 77c11 11 12 12 15 12c9 0 11 -7 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D436" x="0" y="0"></use>
</g>
</svg> completely above it.  Each
point on the axis, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.284ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 983.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">a 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44E" d="M498 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-48 0 -83 33 -91 75c-60 -71 -110 -75 -130 -75c-78 0 -133 66 -133 160c0 146 124 293 241 293c45 0 74 -27 92 -64c3 22 18 44 42 44c17 0 29 -10 29 -27c0 -4 0 -6 -7 -34l-36 -140l-22 -90 c-11 -44 -13 -52 -13 -74c0 -20 3 -46 30 -46c41 0 59 59 76 124c3 14 4 18 14 18c3 0 12 0 12 -10zM361 332c0 6 -14 88 -79 88c-40 0 -85 -37 -116 -96c-23 -46 -55 -169 -55 -219c0 -39 14 -94 64 -94c28 0 69 16 113 71c15 17 15 19 20 37l50 196c1 5 3 11 3 17Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44E" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="748" y="-213"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.284ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 983.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">a 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44E" d="M498 143c0 0 -13 -63 -30 -99c-16 -32 -39 -55 -74 -55c-48 0 -83 33 -91 75c-60 -71 -110 -75 -130 -75c-78 0 -133 66 -133 160c0 146 124 293 241 293c45 0 74 -27 92 -64c3 22 18 44 42 44c17 0 29 -10 29 -27c0 -4 0 -6 -7 -34l-36 -140l-22 -90 c-11 -44 -13 -52 -13 -74c0 -20 3 -46 30 -46c41 0 59 59 76 124c3 14 4 18 14 18c3 0 12 0 12 -10zM361 332c0 6 -14 88 -79 88c-40 0 -85 -37 -116 -96c-23 -46 -55 -169 -55 -219c0 -39 14 -94 64 -94c28 0 69 16 113 71c15 17 15 19 20 37l50 196c1 5 3 11 3 17Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44E" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="748" y="-213"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.052ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 883.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">b 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44F" d="M415 282c0 -144 -123 -293 -241 -293c-74 0 -127 62 -127 157c0 35 4 51 16 101l82 326c5 21 14 55 14 62c0 10 -2 17 -50 17c-15 0 -24 0 -24 12c0 18 11 19 19 20c26 2 99 10 122 10c13 0 13 -11 13 -11l-74 -301c30 31 71 60 117 60c80 0 133 -69 133 -160zM343 326 c0 64 -27 94 -63 94c-26 0 -71 -15 -120 -80c-9 -11 -9 -13 -15 -35l-22 -92c-16 -63 -16 -82 -16 -101c0 -74 33 -101 67 -101c39 0 85 36 118 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="607" y="-213"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.052ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 883.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">b 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D44F" d="M415 282c0 -144 -123 -293 -241 -293c-74 0 -127 62 -127 157c0 35 4 51 16 101l82 326c5 21 14 55 14 62c0 10 -2 17 -50 17c-15 0 -24 0 -24 12c0 18 11 19 19 20c26 2 99 10 122 10c13 0 13 -11 13 -11l-74 -301c30 31 71 60 117 60c80 0 133 -69 133 -160zM343 326 c0 64 -27 94 -63 94c-26 0 -71 -15 -120 -80c-9 -11 -9 -13 -15 -35l-22 -92c-16 -63 -16 -82 -16 -101c0 -74 33 -101 67 -101c39 0 85 36 118 103c18 38 51 153 51 212Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D44F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="607" y="-213"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.061ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 887.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">c 0</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D450" d="M430 107c0 -12 -84 -118 -227 -118c-104 0 -162 79 -162 169c0 141 133 284 268 284c71 0 118 -37 118 -86c0 -40 -27 -64 -56 -64c-19 0 -37 11 -37 35c0 7 2 24 18 39c14 14 28 14 44 14c-14 27 -52 40 -86 40c-55 0 -110 -43 -141 -100c-34 -62 -54 -159 -54 -200 c0 -60 27 -109 90 -109c12 0 121 0 200 99c6 8 8 10 13 10c6 0 12 -7 12 -13Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-30" d="M460 320c0 -79 -5 -157 -37 -226c-44 -95 -120 -116 -174 -116c-49 0 -122 20 -165 101c-41 76 -45 166 -45 241c0 80 5 158 37 227c41 93 114 119 174 119c42 0 124 -16 170 -112c35 -74 40 -154 40 -234zM377 332c0 63 0 139 -10 195c-19 99 -85 117 -118 117 c-25 0 -100 -9 -119 -128c-8 -54 -8 -120 -8 -184c0 -59 0 -151 11 -211c18 -96 77 -121 116 -121c45 0 102 30 117 125c11 64 11 132 11 207Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D450" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-30" x="613" y="-213"></use>
</g>
</svg>, and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.061ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 887.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">c 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D450" d="M430 107c0 -12 -84 -118 -227 -118c-104 0 -162 79 -162 169c0 141 133 284 268 284c71 0 118 -37 118 -86c0 -40 -27 -64 -56 -64c-19 0 -37 11 -37 35c0 7 2 24 18 39c14 14 28 14 44 14c-14 27 -52 40 -86 40c-55 0 -110 -43 -141 -100c-34 -62 -54 -159 -54 -200 c0 -60 27 -109 90 -109c12 0 121 0 200 99c6 8 8 10 13 10c6 0 12 -7 12 -13Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D450" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="613" y="-213"></use>
</g>
</svg>, is
represented by an instance of the <a href="#BoundEdge"><tt>BoundEdge</tt></a> structure.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelLocalDeclarations-1"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Local Declarations&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelLocalDeclarations-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-KdTreeAccelLocalDeclarations-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">enum class <span class="anchor" id="EdgeType"></span>EdgeType { <span class="anchor" id="EdgeType::Start"></span>Start, <span class="anchor" id="EdgeType::End"></span>End };</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelLocalDeclarations-2"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Local Declarations&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelLocalDeclarations-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">struct <span class="anchor" id="BoundEdge"></span>BoundEdge {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-BoundEdgePublicMethods-0">BoundEdge Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-635" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-635"><i></i></a><div id="fragbit-635" class="collapse"><div class="fragmentcode">       BoundEdge() { }
       BoundEdge(Float <a href="#BoundEdge::t" class="code">t</a>, int <a href="#BoundEdge::primNum" class="code">primNum</a>, bool starting)
           : <a href="#BoundEdge::t" class="code">t</a>(<a href="#BoundEdge::t" class="code">t</a>), <a href="#BoundEdge::primNum" class="code">primNum</a>(<a href="#BoundEdge::primNum" class="code">primNum</a>) {
           <a href="#BoundEdge::type" class="code">type</a> = starting ? <a href="#EdgeType::End" class="code">EdgeType</a>::Start : <a href="#EdgeType::End" class="code">EdgeType</a>::End; 
       }</div></div>
    Float <span class="anchor" id="BoundEdge::t"></span>t;
    int <span class="anchor" id="BoundEdge::primNum"></span>primNum;
    EdgeType <span class="anchor" id="BoundEdge::type"></span>type;
};</div><p>


</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-BoundEdgePublicMethods-0"></span><div class="fragmentname">&lt;&lt;BoundEdge Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">BoundEdge(Float <a href="#BoundEdge::t" class="code">t</a>, int <a href="#BoundEdge::primNum" class="code">primNum</a>, bool starting)
    : <a href="#BoundEdge::t" class="code">t</a>(<a href="#BoundEdge::t" class="code">t</a>), <a href="#BoundEdge::primNum" class="code">primNum</a>(<a href="#BoundEdge::primNum" class="code">primNum</a>) {
    <a href="#BoundEdge::type" class="code">type</a> = starting ? <a href="#EdgeType::End" class="code">EdgeType</a>::Start : <a href="#EdgeType::End" class="code">EdgeType</a>::End; 
}</div><p>


</p>
<p>At most, <tt>2 * primitives.size()</tt> <a href="#BoundEdge"><tt>BoundEdge</tt></a>s are needed for computing
costs for any tree node, so the memory for the edges for all three
axes is allocated once and then reused for each node that is created.

</p>
<p></p>
<span class="anchor" id="fragment-Allocateworkingmemoryforkd-treeconstruction-0"></span><div class="fragmentname">&lt;&lt;Allocate working memory for kd-tree construction&gt;&gt;=&nbsp;<a href="#fragment-Allocateworkingmemoryforkd-treeconstruction-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">std::unique_ptr&lt;BoundEdge[]&gt; edges[3];
for (int i = 0; i &lt; 3; ++i)
    edges[i].reset(new BoundEdge[2 * primitives.size()]);</div><p>


</p>
<p>After determining the estimated cost for creating a leaf,
<a href="#KdTreeAccel::buildTree"><tt>KdTreeAccel::buildTree()</tt></a> chooses an axis to try to split along and computes the cost
function for each candidate split.  <tt>bestAxis</tt> and <tt>bestOffset</tt>
record the axis and bounding box edge index that have given the lowest cost so far,
<tt>bestCost</tt>.  <tt>invTotalSA</tt> is initialized to the reciprocal of the
node&rsquo;s surface area; its value will be used when computing the probabilities of
rays passing through each of the candidate children nodes.
 
</p>
<span class="anchor" id="fragment-Choosesplitaxispositionforinteriornode-0"></span><div class="fragmentname">&lt;&lt;Choose split axis position for interior node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int bestAxis = -1, bestOffset = -1;
Float bestCost = <a href="../Shapes/Managing_Rounding_Error.html#Infinity" class="code">Infinity</a>;
Float oldCost = <a href="#KdTreeAccel::isectCost" class="code">isectCost</a> * Float(nPrimitives);
Float totalSA = nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::SurfaceArea" class="code">SurfaceArea</a>();
Float invTotalSA = 1 / totalSA;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> d = nodeBounds.pMax - nodeBounds.pMin;
&lt;&lt;<span class="fragmentname"><a href="#fragment-Choosewhichaxistosplitalong-0">Choose which axis to split along</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-636" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-636"><i></i></a><div id="fragbit-636" class="collapse"><div class="fragmentcode">   int axis = nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::MaximumExtent" class="code">MaximumExtent</a>();</div></div>
int retries = 0;
retrySplit:
&lt;&lt;<span class="fragmentname"><a href="#fragment-Initializeedgesformonoaxis-0">Initialize edges for <tt>axis</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-637" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-637"><i></i></a><div id="fragbit-637" class="collapse"><div class="fragmentcode">   for (int i = 0; i &lt; nPrimitives; ++i) {
       int pn = primNums[i];
       const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;bounds = allPrimBounds[pn];
       edges[axis][2 * i] =     BoundEdge(bounds.pMin[axis], pn, true);
       edges[axis][2 * i + 1] = BoundEdge(bounds.pMax[axis], pn, false);
   }
   &lt;&lt;<span class="fragmentname"><a href="#fragment-Sortmonoedgesformonoaxis-0">Sort <tt>edges</tt> for <tt>axis</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-638" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-638"><i></i></a><div id="fragbit-638" class="collapse"><div class="fragmentcode">      std::sort(&amp;edges[axis][0], &amp;edges[axis][2*nPrimitives],
          [](const BoundEdge &amp;e0, const BoundEdge &amp;e1) -&gt; bool {
              if (e0.<a href="#BoundEdge::t" class="code">t</a> == e1.<a href="#BoundEdge::t" class="code">t</a>)
                  return (int)e0.<a href="#BoundEdge::type" class="code">type</a> &lt; (int)e1.<a href="#BoundEdge::type" class="code">type</a>;
              else return e0.<a href="#BoundEdge::t" class="code">t</a> &lt; e1.<a href="#BoundEdge::t" class="code">t</a>; 
          });</div></div></div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostofallsplitsformonoaxistofindbest-0">Compute cost of all splits for <tt>axis</tt> to find best</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-639" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-639"><i></i></a><div id="fragbit-639" class="collapse"><div class="fragmentcode">   int nBelow = 0, nAbove = nPrimitives;
   for (int i = 0; i &lt; 2 * nPrimitives; ++i) {
       if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::End) --nAbove;
       Float edgeT = edges[axis][i].<a href="#BoundEdge::t" class="code">t</a>;
       if (edgeT &gt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis] &amp;&amp;
           edgeT &lt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis]) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforsplitatmonoithedge-0">Compute cost for split at <tt>i</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-640" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-640"><i></i></a><div id="fragbit-640" class="collapse"><div class="fragmentcode">              &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputechildsurfaceareasforsplitatmonoedgeT-0">Compute child surface areas for split at <tt>edgeT</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-641" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-641"><i></i></a><div id="fragbit-641" class="collapse"><div class="fragmentcode">                 int otherAxis0 = (axis + 1) % 3, otherAxis1 = (axis + 2) % 3;
                 Float belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                      (edgeT - nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis]) * 
                                      (d[otherAxis0] + d[otherAxis1]));
                 Float aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                      (nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis] - edgeT) * 
                                      (d[otherAxis0] + d[otherAxis1]));</div></div>
              Float pBelow = belowSA * invTotalSA; 
              Float pAbove = aboveSA * invTotalSA;
              Float eb = (nAbove == 0 || nBelow == 0) ? emptyBonus : 0;
              Float cost = traversalCost + 
                           isectCost * (1 - eb) * (pBelow * nBelow + pAbove * nAbove);
              &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatebestsplitifthisislowestcostsofar-0">Update best split if this is lowest cost so far</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-642" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-642"><i></i></a><div id="fragbit-642" class="collapse"><div class="fragmentcode">                 if (cost &lt; bestCost)  {
                     bestCost = cost;
                     bestAxis = axis;
                     bestOffset = i;
                 }</div></div></div></div>
       }
       if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::Start) ++nBelow;
   }
   </div></div></div><p>


</p>
<p>This method first tries to find a split along the axis with the largest spatial
extent; if successful, this choice helps to give regions of space that 
tend toward being square in shape.  This is an intuitively sensible
approach.  Later, if it was unsuccessful in finding a good split along this
axis, it will go back and try the others in turn.

</p>
<p></p>
<span class="anchor" id="fragment-Choosewhichaxistosplitalong-0"></span><div class="fragmentname">&lt;&lt;Choose which axis to split along&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int axis = nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::MaximumExtent" class="code">MaximumExtent</a>();</div><p>


</p>
<p>First the <tt>edges</tt> array for the axis is initialized using the
bounding boxes of the overlapping primitives.  The array is then sorted
from low to high along the axis so that it can sweep over the box edges
from first to last.

</p>
<p></p>
<span class="anchor" id="fragment-Initializeedgesformonoaxis-0"></span><div class="fragmentname">&lt;&lt;Initialize edges for <tt>axis</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (int i = 0; i &lt; nPrimitives; ++i) {
    int pn = primNums[i];
    const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;bounds = allPrimBounds[pn];
    edges[axis][2 * i] =     BoundEdge(bounds.pMin[axis], pn, true);
    edges[axis][2 * i + 1] = BoundEdge(bounds.pMax[axis], pn, false);
}
&lt;&lt;<span class="fragmentname"><a href="#fragment-Sortmonoedgesformonoaxis-0">Sort <tt>edges</tt> for <tt>axis</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-643" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-643"><i></i></a><div id="fragbit-643" class="collapse"><div class="fragmentcode">   std::sort(&amp;edges[axis][0], &amp;edges[axis][2*nPrimitives],
       [](const BoundEdge &amp;e0, const BoundEdge &amp;e1) -&gt; bool {
           if (e0.<a href="#BoundEdge::t" class="code">t</a> == e1.<a href="#BoundEdge::t" class="code">t</a>)
               return (int)e0.<a href="#BoundEdge::type" class="code">type</a> &lt; (int)e1.<a href="#BoundEdge::type" class="code">type</a>;
           else return e0.<a href="#BoundEdge::t" class="code">t</a> &lt; e1.<a href="#BoundEdge::t" class="code">t</a>; 
       });</div></div></div><p>


</p>
<p>The C++ standard library  routine <tt>sort()</tt> requires that the structure
being sorted define an ordering; this is done using the
<a href="#BoundEdge::t"><tt>BoundEdge::t</tt></a> values.  However, one subtlety is that if the
<a href="#BoundEdge::t"><tt>BoundEdge::t</tt></a> values match, it is necessary to try to break the tie by
comparing the node&rsquo;s types; this is necessary since <tt>sort()</tt> depends on
the fact that the only time <tt>a &lt; b</tt> and <tt>b &lt; a</tt> are both
<tt>false</tt> is when <tt>a == b</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-Sortmonoedgesformonoaxis-0"></span><div class="fragmentname">&lt;&lt;Sort <tt>edges</tt> for <tt>axis</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::sort(&amp;edges[axis][0], &amp;edges[axis][2*nPrimitives],
    [](const BoundEdge &amp;e0, const BoundEdge &amp;e1) -&gt; bool {
        if (e0.<a href="#BoundEdge::t" class="code">t</a> == e1.<a href="#BoundEdge::t" class="code">t</a>)
            return (int)e0.<a href="#BoundEdge::type" class="code">type</a> &lt; (int)e1.<a href="#BoundEdge::type" class="code">type</a>;
        else return e0.<a href="#BoundEdge::t" class="code">t</a> &lt; e1.<a href="#BoundEdge::t" class="code">t</a>; 
    });</div><p>


</p>
<p>Given the sorted array of edges, we&rsquo;d like to quickly compute the cost
function for a split at each one of them.  The probabilities for a ray
passing through each child node are easily computed using their surface
areas, and the number of primitives on each side of the split is tracked by
the variables <tt>nBelow</tt> and <tt>nAbove</tt>.  We would like to keep their
values updated such that if we chose to split at <tt>edgeT</tt> for a
particular pass through the loop, <tt>nBelow</tt> will give the number of
primitives that would end up below the splitting plane and <tt>nAbove</tt>
would give the number above it.<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="When multiple bounding box faces
project to the same point on the axis, this invariant may not be true at
those points.  However, as implemented here it will only overestimate the
counts and, more importantly, will have the correct value for one of the
multiple times through the loop at each of those points, so the algorithm
functions correctly in the end anyway.">
      <sup>&dagger;</sup>
    </button>
		

</p>
<p>At the first edge, all primitives must be above that edge by definition, so
<tt>nAbove</tt> is initialized to <tt>nPrimitives</tt> and <tt>nBelow</tt> is set
to&nbsp;0. When the loop is considering a split at the end of a bounding box&rsquo;s
extent, <tt>nAbove</tt> needs to be decremented, since that box, which
must have previously been above the splitting plane, will no longer
be above it if
splitting is done at the point.  Similarly, after calculating the split
cost, if the split candidate was at the start of a bounding box&rsquo;s extent,
then the box will be on the below side for all subsequent splits.  The
tests at the start and end of the loop body update the primitive counts for
these two cases.

</p>
<p></p>
<span class="anchor" id="fragment-Computecostofallsplitsformonoaxistofindbest-0"></span><div class="fragmentname">&lt;&lt;Compute cost of all splits for <tt>axis</tt> to find best&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int nBelow = 0, nAbove = nPrimitives;
for (int i = 0; i &lt; 2 * nPrimitives; ++i) {
    if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::End) --nAbove;
    Float edgeT = edges[axis][i].<a href="#BoundEdge::t" class="code">t</a>;
    if (edgeT &gt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis] &amp;&amp;
        edgeT &lt; nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis]) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Computecostforsplitatmonoithedge-0">Compute cost for split at <tt>i</tt>th edge</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-644" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-644"><i></i></a><div id="fragbit-644" class="collapse"><div class="fragmentcode">           &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputechildsurfaceareasforsplitatmonoedgeT-0">Compute child surface areas for split at <tt>edgeT</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-645" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-645"><i></i></a><div id="fragbit-645" class="collapse"><div class="fragmentcode">              int otherAxis0 = (axis + 1) % 3, otherAxis1 = (axis + 2) % 3;
              Float belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                   (edgeT - nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis]) * 
                                   (d[otherAxis0] + d[otherAxis1]));
              Float aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                                   (nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis] - edgeT) * 
                                   (d[otherAxis0] + d[otherAxis1]));</div></div>
           Float pBelow = belowSA * invTotalSA; 
           Float pAbove = aboveSA * invTotalSA;
           Float eb = (nAbove == 0 || nBelow == 0) ? emptyBonus : 0;
           Float cost = traversalCost + 
                        isectCost * (1 - eb) * (pBelow * nBelow + pAbove * nAbove);
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Updatebestsplitifthisislowestcostsofar-0">Update best split if this is lowest cost so far</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-646" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-646"><i></i></a><div id="fragbit-646" class="collapse"><div class="fragmentcode">              if (cost &lt; bestCost)  {
                  bestCost = cost;
                  bestAxis = axis;
                  bestOffset = i;
              }</div></div></div></div>
    }
    if (edges[axis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::Start" class="code">EdgeType</a>::Start) ++nBelow;
}
</div><p>


</p>
<p>

</p>
<p><tt>belowSA</tt> and <tt>aboveSA</tt> hold the surface areas of the two
candidate child bounds; they are easily computed by adding up the areas of
the six faces.

</p>
<p></p>
<span class="anchor" id="fragment-ComputechildsurfaceareasforsplitatmonoedgeT-0"></span><div class="fragmentname">&lt;&lt;Compute child surface areas for split at <tt>edgeT</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int otherAxis0 = (axis + 1) % 3, otherAxis1 = (axis + 2) % 3;
Float belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                     (edgeT - nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis]) * 
                     (d[otherAxis0] + d[otherAxis1]));
Float aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                     (nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis] - edgeT) * 
                     (d[otherAxis0] + d[otherAxis1]));</div><p>


</p>
<p>Given all of this information, the cost for a particular split can be
computed.  

</p>
<p></p>
<span class="anchor" id="fragment-Computecostforsplitatmonoithedge-0"></span><div class="fragmentname">&lt;&lt;Compute cost for split at <tt>i</tt>th edge&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-ComputechildsurfaceareasforsplitatmonoedgeT-0">Compute child surface areas for split at <tt>edgeT</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-647" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-647"><i></i></a><div id="fragbit-647" class="collapse"><div class="fragmentcode">   int otherAxis0 = (axis + 1) % 3, otherAxis1 = (axis + 2) % 3;
   Float belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                        (edgeT - nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[axis]) * 
                        (d[otherAxis0] + d[otherAxis1]));
   Float aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
                        (nodeBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[axis] - edgeT) * 
                        (d[otherAxis0] + d[otherAxis1]));</div></div>
Float pBelow = belowSA * invTotalSA; 
Float pAbove = aboveSA * invTotalSA;
Float eb = (nAbove == 0 || nBelow == 0) ? emptyBonus : 0;
Float cost = traversalCost + 
             isectCost * (1 - eb) * (pBelow * nBelow + pAbove * nAbove);
&lt;&lt;<span class="fragmentname"><a href="#fragment-Updatebestsplitifthisislowestcostsofar-0">Update best split if this is lowest cost so far</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-648" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-648"><i></i></a><div id="fragbit-648" class="collapse"><div class="fragmentcode">   if (cost &lt; bestCost)  {
       bestCost = cost;
       bestAxis = axis;
       bestOffset = i;
   }</div></div></div><p>


</p>
<p>If the cost computed for this candidate split is the best one so far, the
details of the split are recorded.

</p>
<p></p>
<span class="anchor" id="fragment-Updatebestsplitifthisislowestcostsofar-0"></span><div class="fragmentname">&lt;&lt;Update best split if this is lowest cost so far&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (cost &lt; bestCost)  {
    bestCost = cost;
    bestAxis = axis;
    bestOffset = i;
}</div><p>


</p>
<p>
It may happen that there are no possible splits found in the previous tests 
(Figure&nbsp;<a href="#fig:kd-no-useful-split">4.16</a> illustrates a case where this may
happen).  In this case, there isn&rsquo;t a single candidate position at which to
split the node along the current axis.  At this point, splitting is tried
for the other two axes in turn.  If neither of them can find a split (when
<tt>retries</tt> is equal to&nbsp;2), then there is no useful way to refine the
node, since both children will still have the same number of overlapping
primitives.  When this condition occurs, all that can be done is to give up
and make a leaf node.

</p>
<p> </p>
<span class="anchor" id="fig:kd-no-useful-split"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Overlapping%20bboxes.svg" title=""><img src="Overlapping%20bboxes.svg" width=239 height=189 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 4.16: <span class="legend"> If multiple bounding boxes (dotted
lines) overlap a kd-tree node (solid lines) as shown here, there is no possible split
position that can result in fewer than all of the primitives being on both
sides of it.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>It is also possible that the best split will have a cost that is still higher
than the cost for not splitting the node at all.  If it is substantially worse
and there aren&rsquo;t too many primitives, a leaf node is made immediately.

Otherwise, <tt>badRefines</tt> keeps track of how many bad splits have been made
so far above the current node of the tree.  It&rsquo;s worth allowing a few slightly
poor refinements since later splits may be able to find better ones given
a smaller subset of primitives to consider.

</p>
<p></p>
<span class="anchor" id="fragment-Createleafifnogoodsplitswerefound-0"></span><div class="fragmentname">&lt;&lt;Create leaf if no good splits were found&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (bestAxis == -1 &amp;&amp; retries &lt; 2) {
    ++retries;
    axis = (axis + 1) % 3;
    goto retrySplit;
}
if (bestCost &gt; oldCost) ++badRefines;
if ((bestCost &gt; 4 * oldCost &amp;&amp; nPrimitives &lt; 16) || 
    bestAxis == -1 || badRefines == 3) {
    nodes[nodeNum].<a href="#KdAccelNode::InitLeaf" class="code">InitLeaf</a>(primNums, nPrimitives, &amp;<a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>);
    return; 
}</div><p>


</p>
<p>

</p>
<p>Having chosen a split position, the bounding box edges can be used to
 classify the primitives as being above, below, or on both sides of
the split in the same way as was done to keep track of <tt>nBelow</tt> and
<tt>nAbove</tt> in the earlier code.  Note that the <tt>bestOffset</tt> entry in
the arrays is skipped in the loops below; this is necessary so that the
primitive whose bounding box edge was used for the split isn&rsquo;t incorrectly
categorized as being on both sides of the split.

</p>
<p></p>
<span class="anchor" id="fragment-Classifyprimitiveswithrespecttosplit-0"></span><div class="fragmentname">&lt;&lt;Classify primitives with respect to split&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int n0 = 0, n1 = 0;
for (int i = 0; i &lt; bestOffset; ++i)
    if (edges[bestAxis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::End" class="code">EdgeType</a>::Start)
        prims0[n0++] = edges[bestAxis][i].<a href="#BoundEdge::primNum" class="code">primNum</a>;
for (int i = bestOffset + 1; i &lt; 2 * nPrimitives; ++i)
    if (edges[bestAxis][i].<a href="#BoundEdge::type" class="code">type</a> == <a href="#EdgeType::End" class="code">EdgeType</a>::End)
        prims1[n1++] = edges[bestAxis][i].<a href="#BoundEdge::primNum" class="code">primNum</a>;</div><p>


</p>
<p>Recall that the node number of the &ldquo;below&rdquo; child of this node in the
kd-tree nodes array is the current node number plus one.  After the
recursion has returned from that side of the tree, the <tt>nextFreeNode</tt>
offset is used for the &ldquo;above&rdquo; child.  The only other important detail
here is that the <tt>prims0</tt> memory is passed directly for reuse by both
children, while the <tt>prims1</tt> pointer is advanced forward first.  This
is necessary since the current invocation of <a href="#KdTreeAccel::buildTree"><tt>KdTreeAccel::buildTree()</tt></a>
depends on its <tt>prims1</tt> values being preserved over the first recursive
call to <a href="#KdTreeAccel::buildTree"><tt>KdTreeAccel::buildTree()</tt></a> in the following, since it must be
passed as a parameter to the second call.  However, there is no
corresponding need to preserve the <tt>edges</tt> values or to preserve
<tt>prims0</tt> beyond its immediate use in the first recursive call.

</p>
<p></p>
<span class="anchor" id="fragment-Recursivelyinitializechildrennodes-0"></span><div class="fragmentname">&lt;&lt;Recursively initialize children nodes&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float tSplit = edges[bestAxis][bestOffset].<a href="#BoundEdge::t" class="code">t</a>;
<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> bounds0 = nodeBounds, bounds1 = nodeBounds;
bounds0.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMax" class="code">pMax</a>[bestAxis] = bounds1.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3::pMin" class="code">pMin</a>[bestAxis] = tSplit;
<a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(nodeNum + 1, bounds0, allPrimBounds, prims0, n0,
          depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);
int aboveChild = <a href="#KdTreeAccel::nextFreeNode" class="code">nextFreeNode</a>;
nodes[nodeNum].<a href="#KdAccelNode::InitInterior" class="code">InitInterior</a>(bestAxis, aboveChild, tSplit);
<a href="#KdTreeAccel::buildTree" class="code">buildTree</a>(aboveChild, bounds1, allPrimBounds, prims1, n1, 
          depth - 1, edges, prims0, prims1 + nPrimitives, badRefines);</div><p>


</p>
<p>Thus, much more space is needed for the <tt>prims1</tt> array of integers for
storing the worst-case possible number of overlapping primitive numbers
than for the <tt>prims0</tt> array, which only needs to handle the primitives
at a single level at a time.

</p>
<p></p>
<span class="anchor" id="fragment-Allocateworkingmemoryforkd-treeconstruction-1"></span><div class="fragmentname">&lt;&lt;Allocate working memory for kd-tree construction&gt;&gt;+=&nbsp;<a href="#fragment-Allocateworkingmemoryforkd-treeconstruction-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">std::unique_ptr&lt;int[]&gt; prims0(new int[<a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);
std::unique_ptr&lt;int[]&gt; prims1(new int[(maxDepth+1) * <a href="#KdTreeAccel::primitives" class="code">primitives</a>.size()]);</div><p>


</p>
<p>

</p>
<p>
</p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#Traversal"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="Traversal"></span><h3>4.4.3  Traversal</h3><p>


</p>
<p>

</p>
<p>Figure&nbsp;<a href="#fig:kd-ray-traverse">4.17</a> shows the basic process of ray traversal
through the tree. Intersecting the ray with the tree&rsquo;s overall bounds gives
initial <tt>tMin</tt> and <tt>tMax</tt> values, marked with points in the
figure.  As with the <a href="../Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#BVHAccel"><tt>BVHAccel</tt></a> in this chapter, if the ray misses
the overall primitive bounds, this method can immediately return <tt>false</tt>.
Otherwise, it starts to descend into the tree, starting at the root.  At
each interior node, it determines which of the two children the ray enters
first and processes both children in order.  Traversal ends either when the
ray exits the tree or when the closest intersection is found.

</p>
<p></p>
<span class="anchor" id="fig:kd-ray-traverse"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="kd%20ray%20traversal.svg" title=""><img src="kd%20ray%20traversal.svg" width=461 height=400 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 4.17: Traversal of a Ray through the kd-Tree. <span class="legend"> 
(a)&nbsp;The ray is intersected with the bounds of the tree, giving an initial
parametric <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.27ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 4422 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket t Subscript normal m normal i normal n Baseline comma t Subscript normal m normal a normal x Baseline right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6D" d="M813 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31 c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c45 0 119 -11 133 -98c17 38 61 98 145 98c58 0 91 -20 105 -37c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-78" d="M516 0c-30 2 -69 3 -96 3l-108 -3v31c27 1 36 16 36 25c0 6 -13 22 -21 33l-76 100c-61 -72 -90 -105 -90 -127c0 -15 7 -28 29 -31v-31l-95 3c-26 0 -57 -1 -83 -3v31c21 0 80 2 128 60c47 57 47 59 94 119l-99 129c-47 60 -48 61 -118 61v31c27 -2 74 -3 95 -3l108 3 v-31c-20 -1 -35 -10 -35 -25c0 -6 0 -8 9 -18l78 -101l62 78c5 6 15 19 15 35s-8 29 -29 31v31c13 -1 66 -3 96 -3c26 0 56 1 82 3v-31c-47 -1 -88 -16 -119 -52c-24 -26 -62 -75 -92 -113l134 -173c23 -29 41 -31 95 -31v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
<g transform="translate(278,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6E" x="1112" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1919" y="0"></use>
<g transform="translate(2364,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-78" x="1334" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="4143" y="0"></use>
</g>
</svg> range to consider.  (b)&nbsp;Because this range is
nonempty, it is necessary to consider the two children of the root node here.
The ray first enters the child on the right, labeled &ldquo;near,&rdquo; where it has
a parametric range <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.328ex" height="3.009ex" style="vertical-align: -1.005ex;" viewBox="0 -863.1 4446.7 1295.7" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket t Subscript normal m normal i normal n Baseline comma t Subscript normal s normal p normal l normal i normal t Baseline right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6D" d="M813 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31 c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c45 0 119 -11 133 -98c17 38 61 98 145 98c58 0 91 -20 105 -37c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6C" d="M255 0l-111 3l-111 -3v31c67 0 78 0 78 45v520c0 49 -8 56 -78 56v31l144 11v-618c0 -45 11 -45 78 -45v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
<g transform="translate(278,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6E" x="1112" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1919" y="0"></use>
<g transform="translate(2364,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-70" x="394" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6C" x="951" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="1229" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1508" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="4168" y="0"></use>
</g>
</svg>.  If the near node is a leaf with
primitives in it, ray&ndash;primitive intersection tests are performed; otherwise,
its children nodes are processed.  (c)&nbsp;If no hit is found in the node, or if a hit is found
beyond <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.328ex" height="3.009ex" style="vertical-align: -1.005ex;" viewBox="0 -863.1 4446.7 1295.7" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket t Subscript normal m normal i normal n Baseline comma t Subscript normal s normal p normal l normal i normal t Baseline right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6D" d="M813 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31 c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c45 0 119 -11 133 -98c17 38 61 98 145 98c58 0 91 -20 105 -37c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6C" d="M255 0l-111 3l-111 -3v31c67 0 78 0 78 45v520c0 49 -8 56 -78 56v31l144 11v-618c0 -45 11 -45 78 -45v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
<g transform="translate(278,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6E" x="1112" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1919" y="0"></use>
<g transform="translate(2364,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-70" x="394" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6C" x="951" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="1229" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1508" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="4168" y="0"></use>
</g>
</svg>, then the far node, on the left, is processed.
(d)&nbsp;This sequence continues&mdash;processing tree nodes in a depth-first,
front-to-back traversal&mdash;until the closest intersection is found or the ray
exits the tree.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelMethodDefinitions-3"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelMethodDefinitions-2"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">bool KdTreeAccel::<span class="anchor" id="KdTreeAccel::Intersect"></span>Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray,
        <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeinitialparametricrangeofrayinsidekd-treeextent-0">Compute initial parametric range of ray inside kd-tree extent</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-649" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-649"><i></i></a><div id="fragbit-649" class="collapse"><div class="fragmentcode">       Float tMin, tMax;
       if (!bounds.<a href="../Shapes/Basic_Shape_Interface.html#Bounds3::IntersectP" class="code">IntersectP</a>(ray, &amp;tMin, &amp;tMax)) 
           return false;
       </div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Preparetotraversekd-treeforray-0">Prepare to traverse kd-tree for ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-650" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-650"><i></i></a><div id="fragbit-650" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> invDir(1 / ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>.x, 1 / ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>.y, 1 / ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>.z);
       constexpr int maxTodo = 64;
       KdToDo todo[maxTodo];
       int todoPos = 0;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Traversekd-treenodesinorderforray-0">Traverse kd-tree nodes in order for ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-651" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-651"><i></i></a><div id="fragbit-651" class="collapse"><div class="fragmentcode">       bool hit = false;
       const KdAccelNode *node = &amp;<a href="#KdTreeAccel::nodes" class="code">nodes</a>[0];
       while (node != nullptr) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Bailoutifwefoundahitcloserthanthecurrentnode-0">Bail out if we found a hit closer than the current node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-652" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-652"><i></i></a><div id="fragbit-652" class="collapse"><div class="fragmentcode">              if (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::tMax" class="code">tMax</a> &lt; tMin) break;</div></div>
           if (!node-&gt;<a href="#KdAccelNode::IsLeaf" class="code">IsLeaf</a>()) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Processkd-treeinteriornode-0">Process kd-tree interior node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-653" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-653"><i></i></a><div id="fragbit-653" class="collapse"><div class="fragmentcode">                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeparametricdistancealongraytosplitplane-0">Compute parametric distance along ray to split plane</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-654" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-654"><i></i></a><div id="fragbit-654" class="collapse"><div class="fragmentcode">                     int axis = node-&gt;<a href="#KdAccelNode::SplitAxis" class="code">SplitAxis</a>();
                     Float tPlane = (node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() - ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis]) * invDir[axis];</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Getnodechildrenpointersforray-0">Get node children pointers for ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-655" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-655"><i></i></a><div id="fragbit-655" class="collapse"><div class="fragmentcode">                     const KdAccelNode *firstChild, *secondChild;
                     int belowFirst = (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] &lt;  node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>()) ||
                                      (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] == node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() &amp;&amp; ray.d[axis] &lt;= 0);
                     if (belowFirst) {
                         firstChild = node + 1;
                         secondChild = &amp;nodes[node-&gt;AboveChild()];
                     } else {
                         firstChild = &amp;nodes[node-&gt;AboveChild()];
                         secondChild = node + 1;
                     }</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Advancetonextchildnodepossiblyenqueueotherchild-0">Advance to next child node, possibly enqueue other child</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-656" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-656"><i></i></a><div id="fragbit-656" class="collapse"><div class="fragmentcode">                     if (tPlane &gt; tMax || tPlane &lt;= 0)
                         node = firstChild;
                     else if (tPlane &lt; tMin)
                         node = secondChild;
                     else {
                         &lt;&lt;<span class="fragmentname"><a href="#fragment-EnqueuemonosecondChildintodolist-0">Enqueue <tt>secondChild</tt> in todo list</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-657" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-657"><i></i></a><div id="fragbit-657" class="collapse"><div class="fragmentcode">                            todo[todoPos].<a href="#KdToDo::node" class="code">node</a> = secondChild;
                            todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a> = tPlane;
                            todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a> = <a href="#KdToDo::tMax" class="code">tMax</a>;
                            ++todoPos;</div></div>
                         node = firstChild;
                         tMax = tPlane;
                     }</div></div></div></div>
           } else {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkforintersectionsinsideleafnode-0">Check for intersections inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-658" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-658"><i></i></a><div id="fragbit-658" class="collapse"><div class="fragmentcode">                  int <a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a> = node-&gt;<a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a>();
                  if (<a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a> == 1) {
                      const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;p = <a href="#KdTreeAccel::primitives" class="code">primitives</a>[node-&gt;<a href="#KdAccelNode::onePrimitive" class="code">onePrimitive</a>];
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkoneprimitiveinsideleafnode-0">Check one primitive inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-659" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-659"><i></i></a><div id="fragbit-659" class="collapse"><div class="fragmentcode">                         if (p-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect)) 
                             hit = true;</div></div>
                  } else {
                      for (int i = 0; i &lt; <a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a>; ++i) {
                          int index = <a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>[node-&gt;primitiveIndicesOffset + i];
                          const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;p = <a href="#KdTreeAccel::primitives" class="code">primitives</a>[index];
                          &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkoneprimitiveinsideleafnode-0">Check one primitive inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-660" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-660"><i></i></a><div id="fragbit-660" class="collapse"><div class="fragmentcode">                             if (p-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect)) 
                                 hit = true;</div></div>
                      }
                  }</div></div>
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Grabnextnodetoprocessfromtodolist-0">Grab next node to process from todo list</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-661" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-661"><i></i></a><div id="fragbit-661" class="collapse"><div class="fragmentcode">                  if (todoPos &gt; 0) {
                      --todoPos;
                      <a href="#KdToDo::node" class="code">node</a> = todo[todoPos].<a href="#KdToDo::node" class="code">node</a>;
                      <a href="#KdToDo::tMin" class="code">tMin</a> = todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a>;
                      <a href="#KdToDo::tMax" class="code">tMax</a> = todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a>;
                  }
                  else
                      break;</div></div>
           }
       }
       return hit;</div></div>
}</div><p>


</p>
<p>The algorithm starts by finding the overall parametric range <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.27ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 4422 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-bracket t Subscript normal m normal i normal n Baseline comma t Subscript normal m normal a normal x Baseline right-bracket</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-5B" d="M256 -230c0 -11 -9 -20 -20 -20h-122v1000h122c11 0 20 -9 20 -20s-9 -20 -20 -20h-82v-920h82c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6D" d="M813 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31 c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c45 0 119 -11 133 -98c17 38 61 98 145 98c58 0 91 -20 105 -37c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-78" d="M516 0c-30 2 -69 3 -96 3l-108 -3v31c27 1 36 16 36 25c0 6 -13 22 -21 33l-76 100c-61 -72 -90 -105 -90 -127c0 -15 7 -28 29 -31v-31l-95 3c-26 0 -57 -1 -83 -3v31c21 0 80 2 128 60c47 57 47 59 94 119l-99 129c-47 60 -48 61 -118 61v31c27 -2 74 -3 95 -3l108 3 v-31c-20 -1 -35 -10 -35 -25c0 -6 0 -8 9 -18l78 -101l62 78c5 6 15 19 15 35s-8 29 -29 31v31c13 -1 66 -3 96 -3c26 0 56 1 82 3v-31c-47 -1 -88 -16 -119 -52c-24 -26 -62 -75 -92 -113l134 -173c23 -29 41 -31 95 -31v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-5D" d="M164 -250h-122c-11 0 -20 9 -20 20s9 20 20 20h82v920h-82c-11 0 -20 9 -20 20s9 20 20 20h122v-1000Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-5B" x="0" y="0"></use>
<g transform="translate(278,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6E" x="1112" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1919" y="0"></use>
<g transform="translate(2364,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-78" x="1334" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-5D" x="4143" y="0"></use>
</g>
</svg> of the
ray&rsquo;s overlap with the tree, exiting immediately if there is no overlap.  

</p>
<p></p>
<span class="anchor" id="fragment-Computeinitialparametricrangeofrayinsidekd-treeextent-0"></span><div class="fragmentname">&lt;&lt;Compute initial parametric range of ray inside kd-tree extent&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Float tMin, tMax;
if (!bounds.<a href="../Shapes/Basic_Shape_Interface.html#Bounds3::IntersectP" class="code">IntersectP</a>(ray, &amp;tMin, &amp;tMax)) 
    return false;
</div><p>


</p>
<p>The array of <tt>KdToDo</tt> structures is used to record the
nodes yet to be processed for the ray; it is ordered so that the last active
entry in the array is the next node that should be considered.  The maximum
number of entries needed in this array is the maximum depth of the kd-tree; the
array size used in the following should be more than enough in practice.

</p>
<p></p>
<span class="anchor" id="fragment-Preparetotraversekd-treeforray-0"></span><div class="fragmentname">&lt;&lt;Prepare to traverse kd-tree for ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> invDir(1 / ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>.x, 1 / ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>.y, 1 / ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::d" class="code">d</a>.z);
constexpr int maxTodo = 64;
KdToDo todo[maxTodo];
int todoPos = 0;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelDeclarations-1"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Declarations&gt;&gt;+=&nbsp;<a href="#fragment-KdTreeAccelDeclarations-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">struct <span class="anchor" id="KdToDo"></span>KdToDo {
    const KdAccelNode *<span class="anchor" id="KdToDo::node"></span>node;
    Float <span class="anchor" id="KdToDo::tMin"></span>tMin, <span class="anchor" id="KdToDo::tMax"></span>tMax;
};</div><p>


</p>
<p>

</p>
<p>The traversal continues through the nodes, processing a single leaf or
interior node each time through the loop.  The values <tt>tMin</tt> and
<tt>tMax</tt> will always hold the parametric range for the ray&rsquo;s overlap
with the current node.

</p>
<p></p>
<span class="anchor" id="fragment-Traversekd-treenodesinorderforray-0"></span><div class="fragmentname">&lt;&lt;Traverse kd-tree nodes in order for ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bool hit = false;
const KdAccelNode *node = &amp;<a href="#KdTreeAccel::nodes" class="code">nodes</a>[0];
while (node != nullptr) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Bailoutifwefoundahitcloserthanthecurrentnode-0">Bail out if we found a hit closer than the current node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-662" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-662"><i></i></a><div id="fragbit-662" class="collapse"><div class="fragmentcode">       if (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::tMax" class="code">tMax</a> &lt; tMin) break;</div></div>
    if (!node-&gt;<a href="#KdAccelNode::IsLeaf" class="code">IsLeaf</a>()) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Processkd-treeinteriornode-0">Process kd-tree interior node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-663" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-663"><i></i></a><div id="fragbit-663" class="collapse"><div class="fragmentcode">           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeparametricdistancealongraytosplitplane-0">Compute parametric distance along ray to split plane</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-664" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-664"><i></i></a><div id="fragbit-664" class="collapse"><div class="fragmentcode">              int axis = node-&gt;<a href="#KdAccelNode::SplitAxis" class="code">SplitAxis</a>();
              Float tPlane = (node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() - ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis]) * invDir[axis];</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Getnodechildrenpointersforray-0">Get node children pointers for ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-665" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-665"><i></i></a><div id="fragbit-665" class="collapse"><div class="fragmentcode">              const KdAccelNode *firstChild, *secondChild;
              int belowFirst = (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] &lt;  node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>()) ||
                               (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] == node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() &amp;&amp; ray.d[axis] &lt;= 0);
              if (belowFirst) {
                  firstChild = node + 1;
                  secondChild = &amp;nodes[node-&gt;AboveChild()];
              } else {
                  firstChild = &amp;nodes[node-&gt;AboveChild()];
                  secondChild = node + 1;
              }</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Advancetonextchildnodepossiblyenqueueotherchild-0">Advance to next child node, possibly enqueue other child</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-666" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-666"><i></i></a><div id="fragbit-666" class="collapse"><div class="fragmentcode">              if (tPlane &gt; tMax || tPlane &lt;= 0)
                  node = firstChild;
              else if (tPlane &lt; tMin)
                  node = secondChild;
              else {
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-EnqueuemonosecondChildintodolist-0">Enqueue <tt>secondChild</tt> in todo list</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-667" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-667"><i></i></a><div id="fragbit-667" class="collapse"><div class="fragmentcode">                     todo[todoPos].<a href="#KdToDo::node" class="code">node</a> = secondChild;
                     todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a> = tPlane;
                     todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a> = <a href="#KdToDo::tMax" class="code">tMax</a>;
                     ++todoPos;</div></div>
                  node = firstChild;
                  tMax = tPlane;
              }</div></div></div></div>
    } else {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkforintersectionsinsideleafnode-0">Check for intersections inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-668" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-668"><i></i></a><div id="fragbit-668" class="collapse"><div class="fragmentcode">           int <a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a> = node-&gt;<a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a>();
           if (<a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a> == 1) {
               const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;p = <a href="#KdTreeAccel::primitives" class="code">primitives</a>[node-&gt;<a href="#KdAccelNode::onePrimitive" class="code">onePrimitive</a>];
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkoneprimitiveinsideleafnode-0">Check one primitive inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-669" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-669"><i></i></a><div id="fragbit-669" class="collapse"><div class="fragmentcode">                  if (p-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect)) 
                      hit = true;</div></div>
           } else {
               for (int i = 0; i &lt; <a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a>; ++i) {
                   int index = <a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>[node-&gt;primitiveIndicesOffset + i];
                   const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;p = <a href="#KdTreeAccel::primitives" class="code">primitives</a>[index];
                   &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkoneprimitiveinsideleafnode-0">Check one primitive inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-670" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-670"><i></i></a><div id="fragbit-670" class="collapse"><div class="fragmentcode">                      if (p-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect)) 
                          hit = true;</div></div>
               }
           }</div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Grabnextnodetoprocessfromtodolist-0">Grab next node to process from todo list</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-671" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-671"><i></i></a><div id="fragbit-671" class="collapse"><div class="fragmentcode">           if (todoPos &gt; 0) {
               --todoPos;
               <a href="#KdToDo::node" class="code">node</a> = todo[todoPos].<a href="#KdToDo::node" class="code">node</a>;
               <a href="#KdToDo::tMin" class="code">tMin</a> = todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a>;
               <a href="#KdToDo::tMax" class="code">tMax</a> = todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a>;
           }
           else
               break;</div></div>
    }
}
return hit;</div><p>


</p>
<p>An intersection may have been previously found in a primitive that overlaps
multiple nodes.  If the intersection was outside the current node when first
detected, it is necessary to keep traversing the tree until we come to a node
where <tt>tMin</tt> is beyond the intersection. Only then is it certain that there is
no closer intersection with some other primitive.

</p>
<p></p>
<span class="anchor" id="fragment-Bailoutifwefoundahitcloserthanthecurrentnode-0"></span><div class="fragmentname">&lt;&lt;Bail out if we found a hit closer than the current node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::tMax" class="code">tMax</a> &lt; tMin) break;</div><p>


</p>
<p>For interior tree nodes the first thing to do is to intersect the ray with
the node&rsquo;s splitting plane; given the intersection point, we can determine
if one or both of the children nodes need to be processed and in what order
the ray passes through them.

</p>
<p></p>
<span class="anchor" id="fragment-Processkd-treeinteriornode-0"></span><div class="fragmentname">&lt;&lt;Process kd-tree interior node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-Computeparametricdistancealongraytosplitplane-0">Compute parametric distance along ray to split plane</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-672" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-672"><i></i></a><div id="fragbit-672" class="collapse"><div class="fragmentcode">   int axis = node-&gt;<a href="#KdAccelNode::SplitAxis" class="code">SplitAxis</a>();
   Float tPlane = (node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() - ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis]) * invDir[axis];</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Getnodechildrenpointersforray-0">Get node children pointers for ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-673" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-673"><i></i></a><div id="fragbit-673" class="collapse"><div class="fragmentcode">   const KdAccelNode *firstChild, *secondChild;
   int belowFirst = (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] &lt;  node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>()) ||
                    (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] == node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() &amp;&amp; ray.d[axis] &lt;= 0);
   if (belowFirst) {
       firstChild = node + 1;
       secondChild = &amp;nodes[node-&gt;AboveChild()];
   } else {
       firstChild = &amp;nodes[node-&gt;AboveChild()];
       secondChild = node + 1;
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Advancetonextchildnodepossiblyenqueueotherchild-0">Advance to next child node, possibly enqueue other child</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-674" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-674"><i></i></a><div id="fragbit-674" class="collapse"><div class="fragmentcode">   if (tPlane &gt; tMax || tPlane &lt;= 0)
       node = firstChild;
   else if (tPlane &lt; tMin)
       node = secondChild;
   else {
       &lt;&lt;<span class="fragmentname"><a href="#fragment-EnqueuemonosecondChildintodolist-0">Enqueue <tt>secondChild</tt> in todo list</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-675" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-675"><i></i></a><div id="fragbit-675" class="collapse"><div class="fragmentcode">          todo[todoPos].<a href="#KdToDo::node" class="code">node</a> = secondChild;
          todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a> = tPlane;
          todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a> = <a href="#KdToDo::tMax" class="code">tMax</a>;
          ++todoPos;</div></div>
       node = firstChild;
       tMax = tPlane;
   }</div></div></div><p>


</p>
<p>The parametric distance to the split plane is computed in the same manner as
was done in computing the intersection of a ray and an axis-aligned plane for
the ray&ndash;bounding box test.  We use the precomputed <tt>invDir</tt> value to
save a divide each time through the loop.

</p>
<p></p>
<span class="anchor" id="fragment-Computeparametricdistancealongraytosplitplane-0"></span><div class="fragmentname">&lt;&lt;Compute parametric distance along ray to split plane&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int axis = node-&gt;<a href="#KdAccelNode::SplitAxis" class="code">SplitAxis</a>();
Float tPlane = (node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() - ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis]) * invDir[axis];</div><p>


</p>
<p>
Now it is necessary to determine the order in which the ray encounters the children
nodes so that the tree is traversed in front-to-back order along the ray.
Figure&nbsp;<a href="#fig:kd-near-far-child">4.18</a> shows the geometry of this computation.
The position of the ray&rsquo;s origin with respect to the splitting plane is
enough to distinguish between the two cases, ignoring for now the case
where the ray doesn&rsquo;t actually pass through one of the two nodes.  The rare
case when the ray&rsquo;s origin lies on the splitting plane requires careful
handling in this case, as its direction needs to be used instead to
discriminate between the two cases. 

</p>
<p></p>
<span class="anchor" id="fig:kd-near-far-child"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Ray%20below%20above.svg" title=""><img src="Ray%20below%20above.svg" width=292 height=174 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 4.18: <span class="legend"> The position of the origin of the ray
with respect to the splitting plane can be used to determine which of the
node&rsquo;s children should be processed first.  If the origin of a ray like
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.103ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 905.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">r 1</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D45F" d="M436 377c0 -36 -28 -59 -55 -59s-38 19 -38 35c0 26 22 50 52 55c0 0 -16 12 -42 12c-43 0 -72 -26 -80 -33c-24 -22 -52 -69 -56 -82l-32 -130c-4 -18 -38 -154 -40 -158c-7 -20 -25 -28 -37 -28c-15 0 -29 9 -29 27c0 5 6 28 9 43l58 231c13 52 16 63 16 84 c0 38 -14 46 -31 46c-36 0 -56 -48 -73 -119c-6 -22 -7 -23 -17 -23c0 0 -12 0 -12 10c0 3 13 63 31 97c9 18 28 57 74 57c47 0 83 -32 91 -77c19 28 63 77 128 77c51 0 83 -30 83 -65Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D45F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-31" x="638" y="-213"></use>
</g>
</svg> is on the &ldquo;below&rdquo;
 side of the splitting plane, we should process the below
child before the above child, and vice versa.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Getnodechildrenpointersforray-0"></span><div class="fragmentname">&lt;&lt;Get node children pointers for ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">const KdAccelNode *firstChild, *secondChild;
int belowFirst = (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] &lt;  node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>()) ||
                 (ray.<a href="../Geometry_and_Transformations/Rays.html#Ray::o" class="code">o</a>[axis] == node-&gt;<a href="#KdAccelNode::SplitPos" class="code">SplitPos</a>() &amp;&amp; ray.d[axis] &lt;= 0);
if (belowFirst) {
    firstChild = node + 1;
    secondChild = &amp;nodes[node-&gt;AboveChild()];
} else {
    firstChild = &amp;nodes[node-&gt;AboveChild()];
    secondChild = node + 1;
}</div><p>


</p>
<p>
It may not be necessary to process both children of this node.
Figure&nbsp;<a href="#fig:kd-near-far-details">4.19</a> shows some configurations where the ray
only passes through one of the children.  The ray will
never miss both children, since otherwise the current interior node should
never have been visited.

</p>
<p></p>
<span class="anchor" id="fig:kd-near-far-details"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="kd%20skip%20a%20node.svg" title=""><img src="kd%20skip%20a%20node.svg" width=590 height=319 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 4.19: <span class="legend"> Two cases where both children of a
node don&rsquo;t need to be processed because the ray doesn&rsquo;t overlap them. 
(a)&nbsp;The top ray intersects the splitting plane beyond the ray&rsquo;s <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.131ex" height="2.343ex" style="vertical-align: -0.671ex;" viewBox="0 -719.6 1778.5 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal m normal a normal x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6D" d="M813 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31 c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c45 0 119 -11 133 -98c17 38 61 98 145 98c58 0 91 -20 105 -37c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-78" d="M516 0c-30 2 -69 3 -96 3l-108 -3v31c27 1 36 16 36 25c0 6 -13 22 -21 33l-76 100c-61 -72 -90 -105 -90 -127c0 -15 7 -28 29 -31v-31l-95 3c-26 0 -57 -1 -83 -3v31c21 0 80 2 128 60c47 57 47 59 94 119l-99 129c-47 60 -48 61 -118 61v31c27 -2 74 -3 95 -3l108 3 v-31c-20 -1 -35 -10 -35 -25c0 -6 0 -8 9 -18l78 -101l62 78c5 6 15 19 15 35s-8 29 -29 31v31c13 -1 66 -3 96 -3c26 0 56 1 82 3v-31c-47 -1 -88 -16 -119 -52c-24 -26 -62 -75 -92 -113l134 -173c23 -29 41 -31 95 -31v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-78" x="1334" y="0"></use>
</g>
</g>
</svg>
position and thus doesn&rsquo;t enter the far child.  The bottom ray is facing
away from the splitting plane, indicated by a negative <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.188ex" height="2.676ex" style="vertical-align: -1.005ex;" viewBox="0 -719.6 1803.2 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal s normal p normal l normal i normal t</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6C" d="M255 0l-111 3l-111 -3v31c67 0 78 0 78 45v520c0 49 -8 56 -78 56v31l144 11v-618c0 -45 11 -45 78 -45v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-70" x="394" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6C" x="951" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="1229" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1508" y="0"></use>
</g>
</g>
</svg> value. 
(b)&nbsp;The ray intersects the plane before the ray&rsquo;s <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.812ex" height="2.343ex" style="vertical-align: -0.671ex;" viewBox="0 -719.6 1641.3 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal m normal i normal n</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6D" d="M813 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31 c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c45 0 119 -11 133 -98c17 38 61 98 145 98c58 0 91 -20 105 -37c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6E" d="M535 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c58 0 91 -20 105 -37 c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6E" x="1112" y="0"></use>
</g>
</g>
</svg> value,
indicating that the near child doesn&rsquo;t need processing.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>The first <tt>if</tt> test in the following code corresponds to 
Figure&nbsp;<a href="#fig:kd-near-far-details">4.19</a>(a): only the near node needs to be processed if it can be shown that the
ray doesn&rsquo;t overlap the far node because it faces away from it or
doesn&rsquo;t overlap it because <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.417ex" height="2.676ex" style="vertical-align: -1.005ex;" viewBox="0 -719.6 4915.8 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">t Subscript normal s normal p normal l normal i normal t Baseline greater-than t Subscript normal m normal a normal x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D461" d="M330 420c0 -20 -10 -20 -30 -20h-94l-74 -295c-4 -17 -6 -24 -6 -48c0 -33 10 -46 31 -46c34 0 87 24 130 128c5 11 6 14 15 14c4 0 12 0 12 -10c0 -8 -57 -154 -159 -154c-54 0 -92 38 -92 92c0 18 4 35 76 319h-88c-20 0 -28 0 -28 12c0 19 10 19 30 19h94l39 159 c9 35 37 36 40 36c17 0 29 -10 29 -27c0 -6 -5 -26 -41 -168h88c18 0 28 0 28 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-73" d="M360 128c0 -72 -46 -139 -161 -139c-21 0 -66 1 -110 43c-18 -19 -18 -21 -20 -23c-19 -19 -20 -20 -25 -20c-11 0 -11 7 -11 24v132c0 18 0 25 13 25c10 0 11 -4 14 -17c19 -85 55 -142 139 -142c78 0 113 40 113 91c0 72 -82 88 -104 92c-72 14 -100 20 -132 46 c-27 22 -43 50 -43 85c0 56 38 123 160 123c15 0 56 0 94 -28c4 3 14 12 17 16c13 12 15 12 20 12c11 0 11 -7 11 -24v-101c0 -19 0 -24 -13 -24c0 0 -11 0 -12 9c-2 31 -7 121 -117 121c-86 0 -112 -41 -112 -76c0 -58 67 -71 123 -82c42 -8 81 -16 114 -48 c12 -12 42 -42 42 -95Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6C" d="M255 0l-111 3l-111 -3v31c67 0 78 0 78 45v520c0 49 -8 56 -78 56v31l144 11v-618c0 -45 11 -45 78 -45v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-74" d="M332 124c0 -64 -28 -135 -99 -135c-36 0 -129 12 -129 135v276h-85v22c98 4 128 111 129 193h25v-184h143v-31h-143v-278c0 -17 0 -108 67 -108c37 0 67 38 67 112v55h25v-57Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3E" d="M688 230l-581 -275c-25 -11 -42 25 -18 36l548 259l-548 259c-24 11 -7 47 18 36l581 -275c17 -8 17 -32 0 -40Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6D" d="M813 0l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31c67 0 78 0 78 45v233c0 57 -11 111 -74 111c-64 0 -135 -56 -135 -160v-184c0 -45 11 -45 78 -45v-31l-112 3l-113 -3v31 c67 0 78 0 78 45v268c0 49 -8 56 -78 56v31l141 11v-105c28 62 75 105 148 105c45 0 119 -11 133 -98c17 38 61 98 145 98c58 0 91 -20 105 -37c31 -36 31 -67 31 -153v-191c1 -30 26 -30 78 -30v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-61" d="M483 89c0 -81 -61 -95 -82 -95c-47 0 -74 42 -78 82c-19 -47 -65 -87 -131 -87c-63 0 -160 25 -160 106c0 44 25 96 100 130c63 30 133 33 184 36v37c0 89 -57 128 -106 128c-32 0 -81 -11 -108 -46c46 -1 51 -34 51 -46c0 -26 -18 -46 -46 -46c-26 0 -46 17 -46 47 c0 66 69 113 151 113c48 0 98 -16 137 -55c36 -37 36 -76 36 -118v-200c0 -5 4 -50 37 -50c11 0 36 6 36 64v56h25v-56zM316 140v100c-165 -6 -207 -89 -207 -144c0 -50 41 -85 90 -85c45 0 117 34 117 129Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-78" d="M516 0c-30 2 -69 3 -96 3l-108 -3v31c27 1 36 16 36 25c0 6 -13 22 -21 33l-76 100c-61 -72 -90 -105 -90 -127c0 -15 7 -28 29 -31v-31l-95 3c-26 0 -57 -1 -83 -3v31c21 0 80 2 128 60c47 57 47 59 94 119l-99 129c-47 60 -48 61 -118 61v31c27 -2 74 -3 95 -3l108 3 v-31c-20 -1 -35 -10 -35 -25c0 -6 0 -8 9 -18l78 -101l62 78c5 6 15 19 15 35s-8 29 -29 31v31c13 -1 66 -3 96 -3c26 0 56 1 82 3v-31c-47 -1 -88 -16 -119 -52c-24 -26 -62 -75 -92 -113l134 -173c23 -29 41 -31 95 -31v-31Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-73" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-70" x="394" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6C" x="951" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="1229" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-74" x="1508" y="0"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-3E" x="2081" y="0"></use>
<g transform="translate(3137,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D461" x="0" y="0"></use>
<g transform="translate(361,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-61" x="833" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-78" x="1334" y="0"></use>
</g>
</g>
</g>
</svg>.
Figure&nbsp;<a href="#fig:kd-near-far-details">4.19</a>(b)
shows the similar case tested in the second <tt>if</tt> test: the near node may
not need processing if the ray doesn&rsquo;t overlap it.  Otherwise, the <tt>else</tt>
clause handles the case of both children needing processing; the near node will
be processed next, and the far node goes on the <tt>todo</tt> list.

</p>
<p></p>
<span class="anchor" id="fragment-Advancetonextchildnodepossiblyenqueueotherchild-0"></span><div class="fragmentname">&lt;&lt;Advance to next child node, possibly enqueue other child&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (tPlane &gt; tMax || tPlane &lt;= 0)
    node = firstChild;
else if (tPlane &lt; tMin)
    node = secondChild;
else {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-EnqueuemonosecondChildintodolist-0">Enqueue <tt>secondChild</tt> in todo list</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-676" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-676"><i></i></a><div id="fragbit-676" class="collapse"><div class="fragmentcode">       todo[todoPos].<a href="#KdToDo::node" class="code">node</a> = secondChild;
       todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a> = tPlane;
       todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a> = <a href="#KdToDo::tMax" class="code">tMax</a>;
       ++todoPos;</div></div>
    node = firstChild;
    tMax = tPlane;
}</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-EnqueuemonosecondChildintodolist-0"></span><div class="fragmentname">&lt;&lt;Enqueue <tt>secondChild</tt> in todo list&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">todo[todoPos].<a href="#KdToDo::node" class="code">node</a> = secondChild;
todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a> = tPlane;
todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a> = <a href="#KdToDo::tMax" class="code">tMax</a>;
++todoPos;</div><p>


</p>
<p>If the current node is a leaf, intersection tests are performed against the
primitives in the leaf.

</p>
<p></p>
<span class="anchor" id="fragment-Checkforintersectionsinsideleafnode-0"></span><div class="fragmentname">&lt;&lt;Check for intersections inside leaf node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int <a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a> = node-&gt;<a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a>();
if (<a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a> == 1) {
    const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;p = <a href="#KdTreeAccel::primitives" class="code">primitives</a>[node-&gt;<a href="#KdAccelNode::onePrimitive" class="code">onePrimitive</a>];
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkoneprimitiveinsideleafnode-0">Check one primitive inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-677" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-677"><i></i></a><div id="fragbit-677" class="collapse"><div class="fragmentcode">       if (p-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect)) 
           hit = true;</div></div>
} else {
    for (int i = 0; i &lt; <a href="#KdAccelNode::nPrimitives" class="code">nPrimitives</a>; ++i) {
        int index = <a href="#KdTreeAccel::primitiveIndices" class="code">primitiveIndices</a>[node-&gt;primitiveIndicesOffset + i];
        const std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; &amp;p = <a href="#KdTreeAccel::primitives" class="code">primitives</a>[index];
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Checkoneprimitiveinsideleafnode-0">Check one primitive inside leaf node</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-678" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-678"><i></i></a><div id="fragbit-678" class="collapse"><div class="fragmentcode">           if (p-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect)) 
               hit = true;</div></div>
    }
}</div><p>


</p>
<p>Processing an individual primitive is just a matter of 
passing the intersection request on to the primitive.

</p>
<p></p>
<span class="anchor" id="fragment-Checkoneprimitiveinsideleafnode-0"></span><div class="fragmentname">&lt;&lt;Check one primitive inside leaf node&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (p-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect)) 
    hit = true;</div><p>


</p>
<p>After doing the intersection tests at the leaf node, the next node to process
is loaded from the <tt>todo</tt> array.  If no more nodes remain, then 
the ray has passed through the tree without hitting anything.

</p>
<p></p>
<span class="anchor" id="fragment-Grabnextnodetoprocessfromtodolist-0"></span><div class="fragmentname">&lt;&lt;Grab next node to process from todo list&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (todoPos &gt; 0) {
    --todoPos;
    <a href="#KdToDo::node" class="code">node</a> = todo[todoPos].<a href="#KdToDo::node" class="code">node</a>;
    <a href="#KdToDo::tMin" class="code">tMin</a> = todo[todoPos].<a href="#KdToDo::tMin" class="code">tMin</a>;
    <a href="#KdToDo::tMax" class="code">tMax</a> = todo[todoPos].<a href="#KdToDo::tMax" class="code">tMax</a>;
}
else
    break;</div><p>


</p>
<p>Like the <a href="../Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#BVHAccel"><tt>BVHAccel</tt></a>, the <a href="#KdTreeAccel"><tt>KdTreeAccel</tt></a> has a specialized
intersection method for shadow rays that is not shown here.  It is similar
to the <tt>Intersect()</tt> method but calls the <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::IntersectP"><tt>Primitive::IntersectP()</tt></a>
method and returns <tt>true</tt> as soon as it finds any intersection without
worrying about finding the closest one.

</p>
<p></p>
<span class="anchor" id="fragment-KdTreeAccelPublicMethods-0"></span><div class="fragmentname">&lt;&lt;KdTreeAccel Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">bool <span class="anchor" id="KdTreeAccel::IntersectP"></span>IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray) const;</div><p>


</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <div class="container-fluid-nav">
    <!--  <ul class="nav navbar-nav navbar-center"> -->
      <span class="navbar-text" style="text-align: center;">
        Thanks to Jay Patel and 43 others for generously supporting <i>Physically
        Based Rendering</i> online
        through <a href="https://patreon.com/pbrbook">Patreon</a>.
    </span>
  </div>
</nav>

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>, &copy; 2004-2019 Matt Pharr, Wenzel Jakob, and Greg Humphreys</span>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Primitives_and_Intersection_Acceleration/Further_Reading.html">Primitives and Intersection Acceleration / Further Reading</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
