
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
        
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>Points</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Geometry_and_Transformations.html">Geometry and Transformations</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Points</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Geometry_and_Transformations/Vectors.html">(Previous: Vectors)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<h2>2.3 Points</h2><p>


</p>
<p> A point is a zero-dimensional location in 2D or 3D space.  The
<tt>Point2</tt> and <a href="#Point3"><tt>Point3</tt></a> classes in <tt>pbrt</tt> represent points in the
obvious way: using <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg>, <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.086ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 467.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">z</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D467" d="M467 432c0 -4 -22 -52 -117 -145c-36 -36 -98 -90 -98 -90c-36 -31 -65 -56 -119 -114c9 3 27 3 27 3c21 0 36 -4 70 -17c21 -7 39 -13 59 -13c33 0 97 19 120 84c3 7 5 13 14 13c8 0 12 -5 12 -10c0 -27 -58 -154 -157 -154c-29 0 -47 16 -64 37c-25 29 -35 38 -58 38 c-32 0 -62 -27 -85 -62c-6 -11 -8 -13 -16 -13c0 0 -12 0 -12 10c0 7 35 64 103 131l90 84c19 16 103 88 139 131c-26 0 -37 0 -77 15c-23 8 -42 15 -63 15c-8 0 -66 -1 -85 -47c-2 -6 -4 -11 -13 -11s-12 6 -12 11c0 21 46 114 121 114c33 0 50 -20 69 -43 c15 -17 27 -32 51 -32s45 16 75 64c5 9 8 11 15 11c0 0 11 0 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D467" x="0" y="0"></use>
</g>
</svg> (in 3D) coordinates with respect to
a coordinate system.  Although the same representation is
used for vectors, the fact that a point represents a position whereas a
vector represents a direction leads to a number of important differences
in how they are treated.  Points are denoted in text by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.293ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 556.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal p Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="0" y="0"></use>
</g>
</svg>.

</p>
<p>In this section, we&rsquo;ll continue the approach of only including
implementations of the 3D point methods in the <tt>Point3</tt> class here.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-PointDeclarations-0"></span><div class="fragmentname">&lt;&lt;Point Declarations&gt;&gt;=&nbsp;<a href="#fragment-PointDeclarations-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename T&gt; class <span class="anchor" id="Point2"></span>Point2 {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Point2PublicMethods-0">Point2 Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-89" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-89"><i></i></a><div id="fragbit-89" class="collapse"><div class="fragmentcode">       explicit Point2(const Point3&lt;T&gt; &amp;p) : x(p.x), y(p.y) {
           Assert(!HasNaNs());
       }
       Point2() { x = y = 0; }
       Point2(T xx, T yy)
           : x(xx), y(yy) {
           Assert(!HasNaNs());
       }
       
       template &lt;typename U&gt; explicit Point2(const Point2&lt;U&gt; &amp;p) {
           x = (T)p.x;
           y = (T)p.y;
           Assert(!HasNaNs());
       }
       
       template &lt;typename U&gt; explicit Point2(const Vector2&lt;U&gt; &amp;p) {
           x = (T)p.x;
           y = (T)p.y;
           Assert(!HasNaNs());
       }
       
       template &lt;typename U&gt; explicit operator Vector2&lt;U&gt;() const {
           return Vector2&lt;U&gt;(x, y);
       }
       
       #ifndef NDEBUG
       Point2(const Point2&lt;T&gt; &amp;p) {
           Assert(!p.HasNaNs());
           x = p.x; y = p.y;
       }
       
       Point2&lt;T&gt; &amp;operator=(const Point2&lt;T&gt; &amp;p) {
           Assert(!p.HasNaNs());
           x = p.x; y = p.y;
           return *this;
       }
       #endif // !NDEBUG
       friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Point2&lt;T&gt; &amp;p) {
           os &lt;&lt; "[" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; "]";
           return os;
       }
       
       Point2&lt;T&gt; operator+(const Vector2&lt;T&gt; &amp;v) const {
           Assert(!v.HasNaNs());
           return Point2&lt;T&gt;(x + v.x, y + v.y);
       }
       
       Point2&lt;T&gt; &amp;operator+=(const Vector2&lt;T&gt; &amp;v) {
           Assert(!v.HasNaNs());
           x += v.x; y += v.y;
           return *this;
       }
       Vector2&lt;T&gt; operator-(const Point2&lt;T&gt; &amp;p) const {
           Assert(!p.HasNaNs());
           return Vector2&lt;T&gt;(x - p.x, y - p.y);
       }
       
       Point2&lt;T&gt; operator-(const Vector2&lt;T&gt; &amp;v) const {
           Assert(!v.HasNaNs());
           return Point2&lt;T&gt;(x - v.x, y - v.y);
       }
       Point2&lt;T&gt; operator-() const { return Point2&lt;T&gt;(-x, -y); }
       Point2&lt;T&gt; &amp;operator-=(const Vector2&lt;T&gt; &amp;v) {
           Assert(!v.HasNaNs());
           x -= v.x; y -= v.y;
           return *this;
       }
       Point2&lt;T&gt; &amp;operator+=(const Point2&lt;T&gt; &amp;p) {
           Assert(!p.HasNaNs());
           x += p.x; y += p.y;
           return *this;
       }
       Point2&lt;T&gt; operator+(const Point2&lt;T&gt; &amp;p) const {
           Assert(!p.HasNaNs());
           return Point2&lt;T&gt;(x + p.x, y + p.y);
       }
       Point2&lt;T&gt; operator* (T f) const {
           return Point2&lt;T&gt;(f*x, f*y);
       }
       Point2&lt;T&gt; &amp;operator*=(T f) {
           x *= f; y *= f;
           return *this;
       }
       Point2&lt;T&gt; operator/ (T f) const {
           Float inv = (Float)1 / f;
           return Point2&lt;T&gt;(inv*x, inv*y);
       }
       Point2&lt;T&gt; &amp;operator/=(T f) {
           Float inv = (Float)1 / f;
           x *= inv; y *= inv;
           return *this;
       }
       T operator[](int i) const {
           Assert(i &gt;= 0 &amp;&amp; i &lt;= 1);
           if (i == 0) return x;
           return y;
       }
       
       T &amp;operator[](int i) {
           Assert(i &gt;= 0 &amp;&amp; i &lt;= 1);
           if (i == 0) return x;
           return y;
       }
       bool operator==(const Point2&lt;T&gt; &amp;p) const {
           return x == p.x &amp;&amp; y == p.y;
       }
       bool operator!=(const Point2&lt;T&gt; &amp;p) const {
           return x != p.x || y != p.y;
       }
       bool HasNaNs() const {
           return std::isnan(x) || std::isnan(y);
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Point2PublicData-0">Point2 Public Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-90" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-90"><i></i></a><div id="fragbit-90" class="collapse"><div class="fragmentcode">       T x, y;</div></div>
};</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-PointDeclarations-1"></span><div class="fragmentname">&lt;&lt;Point Declarations&gt;&gt;+=&nbsp;<a href="#fragment-PointDeclarations-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-PointDeclarations-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename T&gt; class <span class="anchor" id="Point3"></span>Point3 {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Point3PublicMethods-0">Point3 Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-91" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-91"><i></i></a><div id="fragbit-91" class="collapse"><div class="fragmentcode">       Point3() { x = y = z = 0; }
       Point3(T x, T y, T z) : x(x), y(y), z(z) {
           Assert(!HasNaNs());
       }
       template &lt;typename U&gt; explicit Point3(const Point3&lt;U&gt; &amp;p)
           : x((T)p.x), y((T)p.y), z((T)p.z) { 
           Assert(!HasNaNs());
       }
       template &lt;typename U&gt; explicit operator Vector3&lt;U&gt;() const {
           return Vector3&lt;U&gt;(x, y, z);
       }
       #ifndef NDEBUG
       Point3(const Point3&lt;T&gt; &amp;p) {
           Assert(!p.HasNaNs());
           x = p.x; y = p.y; z = p.z;
       }
       
       Point3&lt;T&gt; &amp;operator=(const Point3&lt;T&gt; &amp;p) {
           Assert(!p.HasNaNs());
           x = p.x; y = p.y; z = p.z;
           return *this;
       }
       #endif // !NDEBUG
       friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Point3&lt;T&gt; &amp;p) {
           os &lt;&lt; "[" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ", " &lt;&lt; p.z &lt;&lt; "]";
           return os;
       }
       Point3&lt;T&gt; operator+(const Vector3&lt;T&gt; &amp;v) const {
           return Point3&lt;T&gt;(x + v.x, y + v.y, z + v.z);
       }
       Point3&lt;T&gt; &amp;operator+=(const Vector3&lt;T&gt; &amp;v) {
           x += v.x; y += v.y; z += v.z;
           return *this;
       }
       Vector3&lt;T&gt; operator-(const Point3&lt;T&gt; &amp;p) const {
           return Vector3&lt;T&gt;(x - p.x, y - p.y, z - p.z);
       }
       Point3&lt;T&gt; operator-(const Vector3&lt;T&gt; &amp;v) const {
           return Point3&lt;T&gt;(x - v.x, y - v.y, z - v.z);
       }
       Point3&lt;T&gt; &amp;operator-=(const Vector3&lt;T&gt; &amp;v) {
           x -= v.x; y -= v.y; z -= v.z;
           return *this;
       }
       Point3&lt;T&gt; &amp;operator+=(const Point3&lt;T&gt; &amp;p) {
           x += p.x; y += p.y; z += p.z;
           return *this;
       }
       Point3&lt;T&gt; operator+(const Point3&lt;T&gt; &amp;p) const {
           return Point3&lt;T&gt;(x + p.x, y + p.y, z + p.z);
       }
       Point3&lt;T&gt; operator*(T f) const {
           return Point3&lt;T&gt;(f*x, f*y, f*z);
       }
       Point3&lt;T&gt; &amp;operator*=(T f) {
           x *= f; y *= f; z *= f;
           return *this;
       }
       Point3&lt;T&gt; operator/(T f) const {
           Float inv = (Float)1 / f;
           return Point3&lt;T&gt;(inv*x, inv*y, inv*z);
       }
       Point3&lt;T&gt; &amp;operator/=(T f) {
           Float inv = (Float)1 / f;
           x *= inv; y *= inv; z *= inv;
           return *this;
       }
       T operator[](int i) const { 
           Assert(i &gt;= 0 &amp;&amp; i &lt;= 2);
           if (i == 0) return x;
           if (i == 1) return y;
           return z;
       }
       
       T &amp;operator[](int i) { 
           Assert(i &gt;= 0 &amp;&amp; i &lt;= 2);
           if (i == 0) return x;
           if (i == 1) return y;
           return z;
       }
       bool operator==(const Point3&lt;T&gt; &amp;p) const {
           return x == p.x &amp;&amp; y == p.y &amp;&amp; z == p.z;
       }
       bool operator!=(const Point3&lt;T&gt; &amp;p) const {
           return x != p.x || y != p.y || z != p.z;
       }
       bool HasNaNs() const {
           return std::isnan(x) || std::isnan(y) || std::isnan(z);
       }
       Point3&lt;T&gt; operator-() const { return Point3&lt;T&gt;(-x, -y, -z); }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Point3PublicData-0">Point3 Public Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-92" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-92"><i></i></a><div id="fragbit-92" class="collapse"><div class="fragmentcode">       T x, y, z;</div></div>
};</div><p>


</p>
<p>As with vectors, it&rsquo;s helpful to have shorter type names for commonly used
point types.

</p>
<p></p>
<span class="anchor" id="fragment-PointDeclarations-2"></span><div class="fragmentname">&lt;&lt;Point Declarations&gt;&gt;+=&nbsp;<a href="#fragment-PointDeclarations-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">typedef Point2&lt;<a href="../Utilities/Main_Include_File.html#Float" class="code">Float</a>&gt; <span class="anchor" id="Point2f"></span>Point2f;
typedef Point2&lt;int&gt;   <span class="anchor" id="Point2i"></span>Point2i;
typedef Point3&lt;<a href="../Utilities/Main_Include_File.html#Float" class="code">Float</a>&gt; <span class="anchor" id="Point3f"></span>Point3f;
typedef Point3&lt;int&gt;   <span class="anchor" id="Point3i"></span>Point3i;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Point2PublicData-0"></span><div class="fragmentname">&lt;&lt;Point2 Public Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">T <span class="anchor" id="Point2::x"></span>x, <span class="anchor" id="Point2::y"></span>y;</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Point3PublicData-0"></span><div class="fragmentname">&lt;&lt;Point3 Public Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">T <span class="anchor" id="Point3::x"></span>x, <span class="anchor" id="Point3::y"></span>y, <span class="anchor" id="Point3::z"></span>z;</div><p>


</p>
<p>

</p>
<p> Also like vectors, a <tt>Point3</tt> constructor takes parameters
to set the <tt>x</tt>, <tt>y</tt>, and <tt>z</tt> coordinate values.

</p>
<p></p>
<span class="anchor" id="fragment-Point3PublicMethods-0"></span><div class="fragmentname">&lt;&lt;Point3 Public Methods&gt;&gt;=&nbsp;<a href="#fragment-Point3PublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Point3() { x = y = z = 0; }
Point3(T x, T y, T z) : x(x), y(y), z(z) {
    Assert(!HasNaNs());
}</div><p>


</p>
<p>It can be useful to convert a <tt>Point3</tt> to a <tt>Point2</tt> by dropping
the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.086ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 467.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">z</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D467" d="M467 432c0 -4 -22 -52 -117 -145c-36 -36 -98 -90 -98 -90c-36 -31 -65 -56 -119 -114c9 3 27 3 27 3c21 0 36 -4 70 -17c21 -7 39 -13 59 -13c33 0 97 19 120 84c3 7 5 13 14 13c8 0 12 -5 12 -10c0 -27 -58 -154 -157 -154c-29 0 -47 16 -64 37c-25 29 -35 38 -58 38 c-32 0 -62 -27 -85 -62c-6 -11 -8 -13 -16 -13c0 0 -12 0 -12 10c0 7 35 64 103 131l90 84c19 16 103 88 139 131c-26 0 -37 0 -77 15c-23 8 -42 15 -63 15c-8 0 -66 -1 -85 -47c-2 -6 -4 -11 -13 -11s-12 6 -12 11c0 21 46 114 121 114c33 0 50 -20 69 -43 c15 -17 27 -32 51 -32s45 16 75 64c5 9 8 11 15 11c0 0 11 0 11 -10Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D467" x="0" y="0"></use>
</g>
</svg> coordinate.  The constructor that does this conversion has the
<tt>explicit</tt> qualifier so that this conversion can&rsquo;t happen without an
explicit cast, lest it happen unintentionally.

</p>
<p></p>
<span class="anchor" id="fragment-Point2PublicMethods-0"></span><div class="fragmentname">&lt;&lt;Point2 Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">explicit Point2(const Point3&lt;T&gt; &amp;p) : x(p.x), y(p.y) {
    Assert(!HasNaNs());
}</div><p>


</p>
<p>It&rsquo;s also useful to be able to convert a point with one element type
(e.g., a <tt>Point3f</tt>) to a point of another one (e.g., <tt>Point3i</tt>) as
well as to be able to convert a point to a vector with a different
underlying element type. The following constructor and conversion operator
provide these conversions.  Both also require an explicit cast, to make it
clear in source code when they are being used.

</p>
<p></p>
<span class="anchor" id="fragment-Point3PublicMethods-1"></span><div class="fragmentname">&lt;&lt;Point3 Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-Point3PublicMethods-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Point3PublicMethods-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename U&gt; explicit Point3(const Point3&lt;U&gt; &amp;p)
    : x((T)p.x), y((T)p.y), z((T)p.z) { 
    Assert(!HasNaNs());
}
template &lt;typename U&gt; explicit operator Vector3&lt;U&gt;() const {
    return Vector3&lt;U&gt;(x, y, z);
}</div><p>


</p>
<p>

</p>
<p>There are certain <a href="#Point3"><tt>Point3</tt></a> methods that either return or take a
<a href="../Geometry_and_Transformations/Vectors.html#Vector3"><tt>Vector3</tt></a>.  For instance, one can add a vector to a point, offsetting
it in the given direction to obtain a new point.  

</p>
<p></p>
<span class="anchor" id="fragment-Point3PublicMethods-2"></span><div class="fragmentname">&lt;&lt;Point3 Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-Point3PublicMethods-1"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Point3PublicMethods-3"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Point3&lt;T&gt; operator+(const Vector3&lt;T&gt; &amp;v) const {
    return Point3&lt;T&gt;(x + v.x, y + v.y, z + v.z);
}
Point3&lt;T&gt; &amp;operator+=(const Vector3&lt;T&gt; &amp;v) {
    x += v.x; y += v.y; z += v.z;
    return *this;
}</div><p>


</p>
<p>Alternately, one can subtract one point from another, obtaining
the vector between them, as shown in Figure&nbsp;<a href="#fig:pointsub">2.6</a>.

</p>
<p></p>
<span class="anchor" id="fig:pointsub"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Vec%20from%20points.svg" title=""><img src="Vec%20from%20points.svg" width=340 height=77 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 2.6: Obtaining the Vector between Two Points. <span class="legend"> The vector
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.836ex" height="2.676ex" style="vertical-align: -0.671ex;" viewBox="0 -863.1 4665.6 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold v equals normal p prime minus normal p Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D42F" d="M580 397c-64 0 -68 -7 -74 -21l-166 -356c-10 -21 -20 -24 -37 -24c-13 0 -26 0 -38 25l-175 376h-64v47l114 -3l124 3v-47h-54l127 -273l116 250c5 10 5 12 5 12c0 8 -29 11 -48 11v47l91 -3c25 0 54 1 79 3v-47Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-3D" d="M722 347c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20zM722 153c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2212" d="M722 250c0 -11 -9 -20 -20 -20h-626c-11 0 -20 9 -20 20s9 20 20 20h626c11 0 20 -9 20 -20Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D42F" x="0" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-3D" x="885" y="0"></use>
<g transform="translate(1941,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="787" y="513"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2212" x="3108" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="4109" y="0"></use>
</g>
</svg> is given by the component-wise subtraction of the points
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.194ex" height="2.676ex" style="vertical-align: -0.671ex;" viewBox="0 -863.1 944.6 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal p prime</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
<path stroke-width="1" id="E1-LATINMODERNVARIANTS-2032" d="M340 496c0 -10 -3 -20 -8 -28l-227 -372h-38l171 424c6 15 26 29 48 29c30 0 54 -24 54 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNVARIANTS-2032" x="787" y="513"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.293ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 556.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal p Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="0" y="0"></use>
</g>
</svg>.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Point3PublicMethods-3"></span><div class="fragmentname">&lt;&lt;Point3 Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-Point3PublicMethods-2"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-Point3PublicMethods-4"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">Vector3&lt;T&gt; operator-(const Point3&lt;T&gt; &amp;p) const {
    return Vector3&lt;T&gt;(x - p.x, y - p.y, z - p.z);
}</div><p>


</p>
<p>Subtracting a vector from a point gives a new point.

</p>
<p></p>
<span class="anchor" id="fragment-Point3PublicMethods-4"></span><div class="fragmentname">&lt;&lt;Point3 Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-Point3PublicMethods-3"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">Point3&lt;T&gt; operator-(const Vector3&lt;T&gt; &amp;v) const {
    return Point3&lt;T&gt;(x - v.x, y - v.y, z - v.z);
}
Point3&lt;T&gt; &amp;operator-=(const Vector3&lt;T&gt; &amp;v) {
    x -= v.x; y -= v.y; z -= v.z;
    return *this;
}</div><p>


</p>
<p>The distance between two points can be computed by subtracting them to
compute the vector between them and then finding the length of that vector:
 
</p>
<span class="anchor" id="fragment-GeometryInlineFunctions-11"></span><div class="fragmentname">&lt;&lt;Geometry Inline Functions&gt;&gt;+=&nbsp;<a href="Vectors.html#fragment-GeometryInlineFunctions-10"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-GeometryInlineFunctions-12"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename T&gt; inline Float
<span class="anchor" id="Distance"></span>Distance(const Point3&lt;T&gt; &amp;p1, const Point3&lt;T&gt; &amp;p2) {
    return (p1 - p2).Length();
}
template &lt;typename T&gt; inline Float
<span class="anchor" id="DistanceSquared"></span>DistanceSquared(const Point3&lt;T&gt; &amp;p1, const Point3&lt;T&gt; &amp;p2) {
    return (p1 - p2).LengthSquared();
}</div><p>


</p>
<p>Although in general it doesn&rsquo;t make sense mathematically to weight points
by a scalar or add two points together, the point classes still allow
these operations in order to be able to compute weighted sums of points,
which is mathematically meaningful as long as the weights used all sum to
one.  The code for scalar multiplication and addition with points is
identical to the corresponding code for vectors, so it is not shown here.

</p>
<p>

</p>
<p>On a related note, it&rsquo;s useful to be able to linearly interpolate between
two points. <tt>Lerp()</tt> returns <tt>p0</tt> at <tt>t==0</tt>, <tt>p1</tt> at
<tt>t==1</tt>, and linearly interpolates between them at other values of
<tt>t</tt>.  For <tt>t&lt;0</tt> or <tt>t&gt;1</tt>, <tt>Lerp()</tt>
extrapolates.

</p>
<p></p>
<span class="anchor" id="fragment-GeometryInlineFunctions-12"></span><div class="fragmentname">&lt;&lt;Geometry Inline Functions&gt;&gt;+=&nbsp;<a href="#fragment-GeometryInlineFunctions-11"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-GeometryInlineFunctions-13"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename T&gt; Point3&lt;T&gt;
<span class="anchor" id="Point3::Lerp"></span><span class="anchor" id="Point2::Lerp"></span><a href="../Utilities/Mathematical_Routines.html#Lerp" class="code">Lerp</a>(Float t, const Point3&lt;T&gt; &amp;p0, const Point3&lt;T&gt; &amp;p1) {
    return (1 - t) * p0 + t * p1;
}</div><p>


</p>
<p>The <tt>Min()</tt> and <tt>Max()</tt> functions return points representing the
component-wise minimums and maximums of the two given
points.

</p>
<p></p>
<span class="anchor" id="fragment-GeometryInlineFunctions-13"></span><div class="fragmentname">&lt;&lt;Geometry Inline Functions&gt;&gt;+=&nbsp;<a href="#fragment-GeometryInlineFunctions-12"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-GeometryInlineFunctions-14"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename T&gt; Point3&lt;T&gt;
<span class="anchor" id="Point2::Min"></span><span class="anchor" id="Point3::Min"></span>Min(const Point3&lt;T&gt; &amp;p1, const Point3&lt;T&gt; &amp;p2) {
    return Point3&lt;T&gt;(std::min(p1.x, p2.x), std::min(p1.y, p2.y), 
                     std::min(p1.z, p2.z));
}
template &lt;typename T&gt; Point3&lt;T&gt;
<span class="anchor" id="Point2::Max"></span><span class="anchor" id="Point3::Max"></span>Max(const Point3&lt;T&gt; &amp;p1, const Point3&lt;T&gt; &amp;p2) {
    return Point3&lt;T&gt;(std::max(p1.x, p2.x), std::max(p1.y, p2.y), 
                     std::max(p1.z, p2.z));
}</div><p>

 
<tt>Floor()</tt>, <tt>Ceil()</tt>, and <tt>Abs()</tt> apply the
corresponding operation component-wise to the given
point.

</p>
<p></p>
<span class="anchor" id="fragment-GeometryInlineFunctions-14"></span><div class="fragmentname">&lt;&lt;Geometry Inline Functions&gt;&gt;+=&nbsp;<a href="#fragment-GeometryInlineFunctions-13"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-GeometryInlineFunctions-15"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename T&gt; Point3&lt;T&gt; <span class="anchor" id="Point2::Floor"></span><span class="anchor" id="Point3::Floor"></span>Floor(const Point3&lt;T&gt; &amp;p) {
    return Point3&lt;T&gt;(std::floor(p.x), std::floor(p.y), std::floor(p.z));
}
template &lt;typename T&gt; Point3&lt;T&gt; <span class="anchor" id="Point2::Ceil"></span><span class="anchor" id="Point3::Ceil"></span>Ceil(const Point3&lt;T&gt; &amp;p) {
    return Point3&lt;T&gt;(std::ceil(p.x), std::ceil(p.y), std::ceil(p.z));
}
template &lt;typename T&gt; Point3&lt;T&gt; <span class="anchor" id="Point2::Abs"></span><span class="anchor" id="Point3::Abs"></span>Abs(const Point3&lt;T&gt; &amp;p) {
    return Point3&lt;T&gt;(std::abs(p.x), std::abs(p.y), std::abs(p.z));
}</div><p>


</p>
<p>

</p>
<p>

</p>
<p>And finally, <tt>Permute()</tt> permutes the coordinate values according to
the provided permutation.

</p>
<p></p>
<span class="anchor" id="fragment-GeometryInlineFunctions-15"></span><div class="fragmentname">&lt;&lt;Geometry Inline Functions&gt;&gt;+=&nbsp;<a href="#fragment-GeometryInlineFunctions-14"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="Normals.html#fragment-GeometryInlineFunctions-16"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">template &lt;typename T&gt; Point3&lt;T&gt;
<span class="anchor" id="Point2::Permute"></span><span class="anchor" id="Point3::Permute"></span>Permute(const Point3&lt;T&gt; &amp;p, int x, int y, int z) {
    return Point3&lt;T&gt;(p[x], p[y], p[z]);
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <div class="container-fluid-nav">
    <!--  <ul class="nav navbar-nav navbar-center"> -->
      <span class="navbar-text" style="text-align: center;">
        Thanks to William Newhall and 34 others for generously supporting <i>Physically
        Based Rendering</i> online
        through <a href="https://patreon.com/pbrbook">Patreon</a>.
    </span>
  </div>
</nav>

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>, &copy; 2004-2021 Matt Pharr, Wenzel Jakob, and Greg Humphreys under the <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a> license. (<a href="https://github.com/mmp/pbr-book-website/">github</a>)</span>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Geometry_and_Transformations/Normals.html">Geometry and Transformations / Normals</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
