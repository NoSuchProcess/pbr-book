
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link href="https://fonts.googleapis.com/css?family=Domine|Roboto+Mono" rel="stylesheet">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
        
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <title>Exercises</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Light_Sources.html">Light Sources</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">Exercises</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Light_Sources/Further_Reading.html">(Previous: Further Reading)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<h2>Exercises</h2><p>


</p>
<p></p>
<ol>

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Shadow mapping is a technique for rendering shadows from
point and distant light sources based on rendering an image from the light
source&rsquo;s perspective that records depth in each pixel of the image and then
projecting points onto the shadow map and comparing their depth to the
depth of the first visible object as seen from the light in that direction.
This method was first described by Williams (<a href="Further_Reading.html#cite:Williams78">1978</a>), and
Reeves, Salesin, and Cook (<a href="Further_Reading.html#cite:Reeves87">1987</a>) developed a number of key improvements.
Modify <tt>pbrt</tt> to be able to render depth map images into a file and then
use them for shadow testing for lights in place of tracing shadow rays.
How much faster can this be?  Discuss the advantages and disadvantages of
the two approaches.

 <li class="exercise"><span class="exerciseicon">&#9312;</span> Through algebraic manipulation and precomputation of one
more value in the constructor, the <a href="../Light_Sources/Point_Lights.html#SpotLight::Falloff"><tt>SpotLight::Falloff()</tt></a> method can be
rewritten to compute the exact same result (modulo floating-point
differences) while using no square root computations and no divides (recall
that the <a href="../Geometry_and_Transformations/Vectors.html#Vector3::Normalize"><tt>Vector3::Normalize()</tt></a> method performs both a square root and a
divide).  Derive and implement this optimization.  How much is running time
improved on a spotlight-heavy scene?

 <li class="exercise"><span class="exerciseicon">&#9312;</span> The functionality of the <tt>SpotLight</tt> could be
replicated by using a suitable image in conjunction with the
<tt>ProjectionLight</tt>.  Discuss the advantages and disadvantages of
providing this specific functionality separately with the <tt>SpotLight</tt>
class.

 <li class="exercise"><span class="exerciseicon">&#9314;</span> The current light source implementations don&rsquo;t support
animated transformations.  Modify <tt>pbrt</tt> to include this functionality, and
render images showing off the effect of animating light positions.

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Modify the <a href="../Light_Sources/Point_Lights.html#ProjectionLight"><tt>ProjectionLight</tt></a> to also support orthographic
projections.  This variant is particularly useful even without an image
map, since it gives a directional light source with a beam of user-defined
extent.

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Write an <a href="../Light_Sources/Area_Lights.html#AreaLight"><tt>AreaLight</tt></a> implementation that improves on
the <a href="../Light_Sources/Area_Lights.html#DiffuseAreaLight"><tt>DiffuseAreaLight</tt></a> by supporting spatially and directionally
varying emitted radiance, specified via either image maps or
<a href="../Texture/Texture_Interface_and_Basic_Textures.html#Texture"><tt>Texture</tt></a>s.  Use it to render images with effects like a television
illuminating a dark room or a stained-glass window lit from behind.

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Many of the <a href="../Light_Sources/Light_Interface.html#Light::Power"><tt>Light::Power()</tt></a> method implementations
only compute approximations to the actual emitted power for their lights.
In particular, all of the lights that use images (<a href="../Light_Sources/Point_Lights.html#ProjectionLight"><tt>ProjectionLight</tt></a>,
<a href="../Light_Sources/Point_Lights.html#GonioPhotometricLight"><tt>GonioPhotometricLight</tt></a>, and <a href="../Light_Sources/Infinite_Area_Lights.html#InfiniteAreaLight"><tt>InfiniteAreaLight</tt></a>) all neglect the fact
that for each of them, different pixels subtend different solid angles and
therefore contribute differently to the emitted power.  Derive accurate
models for the emitted power of these light sources, and implement them in
<tt>pbrt</tt>.  How much error do the current implementations have when used in
some of the <tt>pbrt</tt> example scenes?  Can you construct contrived scenes to
show the maximum error introduced by the current implementation? 

 <li class="exercise"><span class="exerciseicon">&#9313;</span> Read some of the papers in the &ldquo;Further Reading&rdquo;
section that discuss the shadow cache, and add this optimization to <tt>pbrt</tt>.
Measure how much it speeds up the system for a variety of scenes.  What
techniques can you come up with that make it work better in the presence of
multiple levels of reflection?

 <li class="exercise"><span class="exerciseicon">&#9314;</span> Modify <tt>pbrt</tt> to support the shaft culling algorithm
(<a href="Further_Reading.html#cite:Haines94">Haines and Wallace 1994</a>).  Measure the performance difference for scenes with area
light sources.  Make sure that your implementation still performs well even
with very large light sources (like a hemispherical skylight).

 <li class="exercise"><span class="exerciseicon">&#9314;</span> Read the paper by Vel&aacute;zquez-Armend&aacute;riz et&nbsp;al. (<a href="Further_Reading.html#cite:xEntityList:Velcmd::azquez-Armendcmd::ariz2015">2015</a>),
and implement their method for efficiently rendering scenes with complex
light sources. Create or find models of a few complex lights, including
many shapes that exhibit specular reflection and/or transmission. Compare
results using your implementation to renderings using one or more of the
bidirectional integrators from Chapter&nbsp;<a href="../Light_Transport_III_Bidirectional_Methods.html#chap:bidir-methods">16</a> (which are best suited to
handling this challenge). Note that you may need to set very long maximum
integrator path lengths for the current implementation of <tt>pbrt</tt> to be able to render
these scenes at all.

How much more efficiently does your implementation render images of scenes
lit by these lights than the built-in integrators? Do results from the
two approaches match?

</ol><p>



</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>, &copy; 2004-2019 Matt Pharr, Wenzel Jakob, and Greg Humphreys</span>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Monte_Carlo_Integration.html">Monte Carlo Integration</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
