
<!doctype html>
<html lang="en">
<head>

<!-- all praise to https://realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="../pbrstyle.css">
  <link rel="stylesheet" href="/fontawesome-free-5.15.3-web/css/all.css">

  <script async src="https://cse.google.com/cse.js?cx=003601324460585362024:4xwpwgaitgd"></script>
  <script src="/react.min.js"></script>
  <script src="/react-dom.min.js"></script>
  <script src="/jeri.min.js"></script>
  <link rel="preload" href="/exr.worker.js" as="script" crossorigin="anonymous">
        
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/bootstrap.min.css">

  <title>pbrt: System Overview</title>
</head>
        
<body>

<nav class="fixed-top-lg-navbar navbar navbar-expand bg-light navbar-light">
  <ul class="nav navbar-nav">
    <a class="navbar-brand" href="../contents.html"><img src="../pbr.jpg" width=25 height=25></a>
    <li class="nav-item"><a class="nav-link" href="../Introduction.html">Introduction</a></li>
    <span class="navbar-text">/</span>
    <li class="nav-item"><a class="nav-link" href="#">pbrt: System Overview</a></li>
    <span class="navbar-text">&nbsp;&nbsp;</span>
    <li class="nav-item"><a class="nav-link" href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html">(Previous: Photorealistic Rendering and the Ray-Tracing Algorithm)</a></li>
  </ul>

  <ul class="nav navbar-nav ml-auto d-none d-md-block">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
  <ul class="nav navbar-nav d-block d-md-none">
        <li class="nav-item"><div class="gcse-search"></div></li>
    </ul>
</nav>

<div class="maincontainer">
<div class="container-fluid">

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">

</div>
<div class="col-md-10 col-lg-8">

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#"><i class="fas fa-link "></i></a>
</div>
<div class="col-md-10 col-lg-8">
<h2>1.3 pbrt: System Overview</h2><p>


</p>
<p> <tt>pbrt</tt> is structured using standard object-oriented techniques:
abstract base classes are defined for important entities (e.g., a
<tt>Shape</tt> abstract base class defines the interface that all geometric
shapes must implement, the <tt>Light</tt> abstract base class acts similarly
for lights, etc.).  The majority of the system is implemented purely in
terms of the interfaces provided by these abstract base classes; for
example, the code that checks for occluding objects between a light source
and a point being shaded calls the <tt>Shape</tt> intersection methods and
doesn&rsquo;t need to consider the particular types of shapes that are
present in the scene.  This approach makes it easy to extend the system, as
adding a new shape only requires implementing a class that implements the
<tt>Shape</tt> interface and linking it into the system.

</p>
<p><tt>pbrt</tt> is written using a total of 10 key abstract base classes, summarized
in Table&nbsp;<a href="#fig:plug-in-types">1.1</a>.  Adding a new implementation of one of
these types to the system is straightforward; the implementation must
inherit from the appropriate base class, be compiled and linked into the
executable, and the object creation routines in Appendix&nbsp;B must be modified
to create instances of the object as needed as the scene description file
is parsed.  Section&nbsp;<a href="../Scene_Description_Interface/Adding_New_Object_Implementations.html#sec:adding-plugins">A.4</a> discusses extending the system
in this manner in more detail.

</p>
<p></p>
<span class="anchor" id="fig:plug-in-types"></span><div class="card outerfigure"><div class="card-body figure"><p>

</p>
<figcaption class="caption">Table 1.1: Main Interface Types. <span class="legend"> Most of <tt>pbrt</tt> is implemented in
  terms of 10 key abstract base classes, listed here.  Implementations of
  each of these can easily be added to the system to extend its
  functionality.
</span>
</figcaption><p>


<table class="table table-hover table-light table-sm"><thead><tr>
<th>Base class</th><th> Directory</th><th> Section</th></tr>
</thead>
<tbody>
<tr>
<td><a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a></td><td> <tt>shapes/</tt></td><td> <a href="../Shapes/Basic_Shape_Interface.html#sec:shape-interface">3.1</a></td></tr>
<tr>
<td><a href="../Primitives_and_Intersection_Acceleration/Aggregates.html#Aggregate"><tt>Aggregate</tt></a></td><td> <tt>accelerators/</tt></td><td> <a href="../Primitives_and_Intersection_Acceleration/Aggregates.html#sec:aggregates">4.2</a></td></tr>
<tr>
<td><a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a></td><td> <tt>cameras/</tt></td><td> <a href="../Camera_Models/Camera_Model.html#sec:camera-model">6.1</a></td></tr>
<tr>
<td><a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a></td><td> <tt>samplers/</tt></td><td> <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#sec:sampling-interface">7.2</a></td></tr>
<tr>
<td><a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#Filter"><tt>Filter</tt></a></td><td> <tt>filters/</tt></td><td> <a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#sec:image-reconstruction">7.8</a></td></tr>
<tr>
<td><a href="../Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a></td><td> <tt>materials/</tt></td><td> <a href="../Materials/Material_Interface_and_Implementations.html#sec:material-interface">9.2</a></td></tr>
<tr>
<td><a href="../Texture/Texture_Interface_and_Basic_Textures.html#Texture"><tt>Texture</tt></a></td><td> <tt>textures/</tt></td><td> <a href="../Texture/Texture_Interface_and_Basic_Textures.html#sec:texture-interface">10.3</a></td></tr>
<tr>
<td><a href="../Volume_Scattering/Media.html#Medium"><tt>Medium</tt></a></td><td> <tt>media/</tt></td><td> <a href="../Volume_Scattering/Media.html#sec:media">11.3</a></td></tr>
<tr>
<td><a href="../Light_Sources/Light_Interface.html#Light"><tt>Light</tt></a></td><td> <tt>lights/</tt></td><td> <a href="../Light_Sources/Light_Interface.html#sec:light">12.2</a></td></tr>
<tr>
<td><a href="#Integrator"><tt>Integrator</tt></a> </td><td> <tt>integrators/</tt></td><td> <a href="#sec:integrator-intro">1.3.3</a> </td></tr>
</tbody></table>

</p>
</div></div><p>


</p>
<p>The <tt>pbrt</tt> source code distribution is available from <a href="https://pbrt.org">pbrt.org</a>.
(A <a href="http://pbrt.org/scenes-v3.html">large collection of example scenes</a> is also available as a separate
download.)
All of the code for the <tt>pbrt</tt> core is in
the <tt>src/core</tt> directory, and the <a href="#main"><tt>main()</tt></a> function is contained
in the short file <a href="https://github.com/mmp/pbrt-v3/tree/master/src/main/pbrt.cpp"><tt>main/pbrt.cpp</tt></a>. Various implementations of
instances of the abstract base classes are in separate directories:
<tt>src/shapes</tt> has implementations of the <tt>Shape</tt> base class,
<tt>src/materials</tt> has implementations of <tt>Material</tt>, and so forth.

</p>
<p>Throughout this section are a number of images rendered with extended
versions of <tt>pbrt</tt>.  Of them, Figures&nbsp;<a href="#fig:competition-snow">1.11</a> through
<a href="#fig:competition-dog">1.14</a> are notable: not only are they visually
impressive but also each of them was created by a student in a rendering course
where the final class project was to extend <tt>pbrt</tt> with new functionality
in order to render an interesting image.  These images are among the best
from those courses.

</p>
<p>


</p>
<p>
</p>
<span class="anchor" id="fig:competition-snow"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="nightsnow.png" style="max-width: 100%; height: auto;" width=1369 height=1027>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.11: <span class="legend"> Guillaume Poncin and Pramod
Sharma extended <tt>pbrt</tt> in numerous ways, implementing a number of complex
rendering algorithms, to make this prize-winning image for Stanford&rsquo;s
cs348b rendering competition.  The trees are
modeled procedurally with L-systems, a glow image processing filter
increases the apparent realism of the lights on the tree, snow was modeled
procedurally with metaballs, and a subsurface scattering algorithm gave
the snow its realistic appearance by accounting for the effect of light
that travels beneath the snow for some distance before leaving it.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>
</p>
<div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="icecave.png" style="max-width: 100%; height: auto;" width=1388 height=1388>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.12: <span class="legend">
Abe Davis, David Jacobs, and Jongmin Baek rendered this amazing image of an
ice cave to take the grand prize in the 2009 Stanford CS348b rendering
competition.
They first implemented a simulation of the physical process of glaciation,
the process where snow falls, melts, and refreezes over the course of many
years, forming stratified layers of ice.  They then simulated erosion of
the ice due to melted water runoff before generating a geometric model of
the ice.  Scattering of light inside the volume was simulated with
volumetric photon mapping; the blue color of the ice is entirely due to
modeling the wavelength-dependent absorption of light in the ice volume.
</span>
</figcaption><p>

</p>
</div></div><p>


</p>
<p></p>
<div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="cloth.png" style="max-width: 100%; height: auto;" width=1388 height=1388>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.13: <span class="legend">
Lingfeng Yang implemented a bidirectional texture function to simulate the
appearance of cloth, adding an analytic self-shadowing model, to render
this image that took first prize in the 2009 Stanford CS348b rendering
competition.</span>
</figcaption><p>

</p>
</div></div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#PhasesofExecution"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="PhasesofExecution"></span><h3>1.3.1  Phases of Execution</h3><p>


</p>
<p> <tt>pbrt</tt> can be conceptually divided into two phases of
execution.  First, it parses the scene description file provided by the
user.  The scene description is a text file that specifies the geometric
shapes that make up the scene, their material properties, the lights that
illuminate them, where the virtual camera is positioned in the scene, and
parameters to all of the individual algorithms used throughout the system.
Each statement in the input file has a direct mapping to one of the
routines in Appendix&nbsp;<a href="../Scene_Description_Interface.html#chap:API">A</a>; these routines comprise the procedural
interface for describing a scene.  
The scene file format is documented on the <tt>pbrt</tt> Web site, <a href="https://pbrt.org">pbrt.org</a>.

</p>
<p>The end results of the parsing phase are an instance of the <a href="#Scene"><tt>Scene</tt></a>
class and an instance of the <a href="#Integrator"><tt>Integrator</tt></a> class.  The <a href="#Scene"><tt>Scene</tt></a>
contains a representation of the contents of the scene (geometric objects,
lights, etc.), and the <a href="#Integrator"><tt>Integrator</tt></a> implements an algorithm to render
it.  The integrator is so-named because its main task is to evaluate the
integral from Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>).

</p>
<p>Once the scene has been specified, the second phase of execution begins, and
the main rendering loop executes.  This phase is where <tt>pbrt</tt> usually
spends the majority of its running time, and most of this book describes
code that executes during this phase.  The rendering loop is performed by
executing an implementation of the <a href="#Integrator::Render"><tt>Integrator::Render()</tt></a> method, which
is the focus of Section&nbsp;<a href="#sec:rendering-loop">1.3.4</a>.

</p>
<p>This chapter will describe a particular <a href="#Integrator"><tt>Integrator</tt></a> subclass named
<a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a>, whose <tt>Render()</tt>
method determines the light arriving at a virtual film plane for a large
number of rays that model the process of image formation.  After the
contributions of all of these film samples have been computed,

the final
image is written to a file.  The scene description data in memory are
deallocated, and the system then resumes processing statements from the
scene description file until no more remain, allowing the user to specify
another scene to be rendered, if desired.

</p>
<p></p>
<span class="anchor" id="fig:competition-dog"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="furrydog.png" style="max-width: 100%; height: auto;" width=1800 height=1800>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.14: <span class="legend"> Jared Jacobs and Michael Turitzin added
an implementation of Kajiya and Kay&rsquo;s texel-based fur rendering
algorithm (Kajiya and Kay&nbsp;<a href="Further_Reading.html#cite:Kajiya89">1989</a>) to <tt>pbrt</tt> and rendered this image, where both the
fur on the dog and the shag carpet are rendered with the texel fur algorithm.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>Figures&nbsp;<a href="#fig:lux1">1.15</a> and&nbsp;<a href="#fig:lux2">1.16</a> were
rendered with <em>LuxRender</em>, a GPL-licensed rendering system originally
based on the <tt>pbrt</tt> source code from the first edition of the book.  (See
<a href="http://www.luxrender.net">www.luxrender.net</a> for more information about <em>LuxRender</em>.)

</p>
<p></p>
<span class="anchor" id="fig:lux1"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="lux-indoor.png" style="max-width: 100%; height: auto;" width=1388 height=781>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.15: <span class="legend">
This contemporary indoor scene was modeled and rendered by Florent Boyer.
The image was rendered using
<em>LuxRender</em>, a GPL-licensed
physically-based rendering system originally based on <tt>pbrt</tt>&rsquo;s source code.
Modeling and texturing were done using Blender.
</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fig:lux2"></span><div class="card outerfigure"><div class="card-body figure"><p>


</p>
<div class="figure-row">
<img src="crown.png" style="max-width: 100%; height: auto;" width=900 height=1125>
</div>
<p>

</p>
<figcaption class="caption">Figure 1.16: <span class="legend">
Martin Lubich modeled this scene of the Austrian Imperial Crown and
rendered it using <em>LuxRender</em>, an open source fork of the
<tt>pbrt</tt> codebase.  The
scene was modeled in Blender and consists of approximately 1.8 million
vertices.  It is illuminated by six area light sources with emission
spectra based on measured data from a real-world light source and was
rendered with 1280 samples per pixel in 73 hours of computation on a
quad-core CPU.  See Martin&rsquo;s Web site, <a href="http://www.loramel.net">www.loramel.net</a>, for more
information, including downloadable Blender scene files.
</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#SceneRepresentation"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span id="SceneRepresentation"></span><h3>1.3.2  Scene Representation</h3><p>


</p>
<p>

</p>
<p> <tt>pbrt</tt>&rsquo;s <a href="#main"><tt>main()</tt></a> function can be found in the file
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/main/pbrt.cpp"><tt>main/pbrt.cpp</tt></a>. This function is quite simple; it first loops over the
provided command-line arguments in <tt>argv</tt>, initializing values in the
<tt>Options</tt> structure and storing the filenames provided in the
arguments.  Running <tt>pbrt</tt> with <tt>&ndash;help</tt> as a command-line argument
prints all of the options that can be specified on the command line.

The fragment that parses the command-line arguments, &lt;&lt;<span class="fragmentname">Process
command-line arguments</span>&gt;&gt;, is straightforward and therefore not included in
the book here.

</p>
<p>The options structure is then passed to the <tt>pbrtInit()</tt> function,
which does systemwide initialization.  The <tt>main()</tt> function then
parses the given scene description(s), leading to the creation of a
<a href="#Scene"><tt>Scene</tt></a> and an <a href="#Integrator"><tt>Integrator</tt></a>.  After all rendering is done,
<a href="../Scene_Description_Interface/Initialization_and_Rendering_Options.html#pbrtCleanup"><tt>pbrtCleanup()</tt></a> does final cleanup before the system exits.

</p>
<p>The <a href="../Scene_Description_Interface/Initialization_and_Rendering_Options.html#pbrtInit"><tt>pbrtInit()</tt></a> and <a href="../Scene_Description_Interface/Initialization_and_Rendering_Options.html#pbrtCleanup"><tt>pbrtCleanup()</tt></a> functions appear in a
<em>mini-index</em> in the page margin, along with the number of the page
where they are actually defined.  The mini-indices have pointers to the
definitions of almost all of the functions, classes, methods, and member
variables used or referred to on each page.

</p>
<p></p>
<span class="anchor" id="fragment-Mainprogram-0"></span><div class="fragmentname">&lt;&lt;Main program&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int <span class="anchor" id="main"></span>main(int argc, char *argv[]) {
    Options options;
    std::vector&lt;std::string&gt; filenames;
    &lt;&lt;<span class="fragmentname">Process command-line arguments</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-1" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-1"><i></i></a><div id="fragbit-1" class="collapse"><div class="fragmentcode">       for (int i = 1; i &lt; argc; ++i) {
           if (!strcmp(argv[i], "--ncores") || !strcmp(argv[i], "--nthreads"))
               options.nThreads = atoi(argv[++i]);
           else if (!strcmp(argv[i], "--outfile")) options.imageFile = argv[++i];
           else if (!strcmp(argv[i], "--quick")) options.quickRender = true;
           else if (!strcmp(argv[i], "--quiet")) options.quiet = true;
           else if (!strcmp(argv[i], "--verbose")) options.verbose = true;
           else if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-h")) {
               printf("usage: pbrt [--nthreads n] [--outfile filename] [--quick] [--quiet] "
                      "[--verbose] [--help] &lt;filename.pbrt&gt; ...\n");
               return 0;
           }
           else filenames.push_back(argv[i]);
       }</div></div>
    <a href="../Scene_Description_Interface/Initialization_and_Rendering_Options.html#pbrtInit" class="code">pbrtInit</a>(options);
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Processscenedescription-0">Process scene description</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-2" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-2"><i></i></a><div id="fragbit-2" class="collapse"><div class="fragmentcode">       if (filenames.size() == 0) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Parsescenefromstandardinput-0">Parse scene from standard input</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-3" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-3"><i></i></a><div id="fragbit-3" class="collapse"><div class="fragmentcode">              <a href="#ParseFile" class="code">ParseFile</a>("-");</div></div>
       } else {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Parsescenefrominputfiles-0">Parse scene from input files</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-4" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-4"><i></i></a><div id="fragbit-4" class="collapse"><div class="fragmentcode">              for (const std::string &amp;f : filenames)
                  if (!<a href="#ParseFile" class="code">ParseFile</a>(f))
                      <a href="../Utilities/Communicating_with_the_User.html#Error" class="code">Error</a>("Couldn't open scene file \"%s\"", f.c_str());</div></div>
       }</div></div>
    <a href="../Scene_Description_Interface/Initialization_and_Rendering_Options.html#pbrtCleanup" class="code">pbrtCleanup</a>();
    return 0;
}</div><p>


</p>
<p>

</p>
<p>If <tt>pbrt</tt> is run with no input filenames provided, then the scene
description is read from standard input.  Otherwise it loops through the
provided filenames, processing each file in turn.

</p>
<p></p>
<span class="anchor" id="fragment-Processscenedescription-0"></span><div class="fragmentname">&lt;&lt;Process scene description&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">if (filenames.size() == 0) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Parsescenefromstandardinput-0">Parse scene from standard input</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-5" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-5"><i></i></a><div id="fragbit-5" class="collapse"><div class="fragmentcode">       <a href="#ParseFile" class="code">ParseFile</a>("-");</div></div>
} else {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Parsescenefrominputfiles-0">Parse scene from input files</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-6" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-6"><i></i></a><div id="fragbit-6" class="collapse"><div class="fragmentcode">       for (const std::string &amp;f : filenames)
           if (!<a href="#ParseFile" class="code">ParseFile</a>(f))
               <a href="../Utilities/Communicating_with_the_User.html#Error" class="code">Error</a>("Couldn't open scene file \"%s\"", f.c_str());</div></div>
}</div><p>


</p>
<p>
<span class="anchor" id="ParseFile"></span> The <a href="#ParseFile"><tt>ParseFile()</tt></a> function parses a scene
description file, either from standard input or from a file on disk; it returns
<tt>false</tt> if it was unable to open the file.  The mechanics of parsing scene
description files will not be described in this book; the parser implementation
can be found in the <tt>lex</tt> and <tt>yacc</tt> files
<tt>core/pbrtlex.ll</tt> and
<tt>core/pbrtparse.y</tt>, respectively.  Readers who want to understand the
parsing subsystem but are not familiar with these tools may wish to consult
Levine, Mason, and Brown (<a href="Further_Reading.html#cite:Levine:LexYacc">1992</a>). 

</p>
<p>We use the common UNIX idiom that a file named &ldquo;<tt>-</tt>&rdquo; represents
standard input:

</p>
<p></p>
<span class="anchor" id="fragment-Parsescenefromstandardinput-0"></span><div class="fragmentname">&lt;&lt;Parse scene from standard input&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#ParseFile" class="code">ParseFile</a>("-");</div><p>


</p>
<p>If a particular input file can&rsquo;t be opened, the <a href="../Utilities/Communicating_with_the_User.html#Error"><tt>Error()</tt></a> routine reports
this information to the user.  <a href="../Utilities/Communicating_with_the_User.html#Error"><tt>Error()</tt></a> uses the same format string
semantics as <tt>printf()</tt>.

</p>
<p></p>
<span class="anchor" id="fragment-Parsescenefrominputfiles-0"></span><div class="fragmentname">&lt;&lt;Parse scene from input files&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (const std::string &amp;f : filenames)
    if (!<a href="#ParseFile" class="code">ParseFile</a>(f))
        <a href="../Utilities/Communicating_with_the_User.html#Error" class="code">Error</a>("Couldn't open scene file \"%s\"", f.c_str());</div><p>


</p>
<p>As the scene file is parsed, objects are created that represent the lights
and geometric primitives in the scene.  These are all stored in the
<a href="#Scene"><tt>Scene</tt></a> object, which is created by the
<a href="../Scene_Description_Interface/Scene_Definition.html#RenderOptions::MakeScene"><tt>RenderOptions::MakeScene()</tt></a> method in
Section&nbsp;<a href="../Scene_Description_Interface/Scene_Definition.html#sec:api-scene-creation">A.3.7</a> in Appendix&nbsp;B.  The <a href="#Scene"><tt>Scene</tt></a> class
is declared in <a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/scene.h"><tt>core/scene.h</tt></a><span class="anchor" id="scene.h"></span> and defined in
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/scene.cpp"><tt>core/scene.cpp</tt></a><span class="anchor" id="scene.cpp"></span>.

</p>
<p>

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-SceneDeclarations-0"></span><div class="fragmentname">&lt;&lt;Scene Declarations&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="Scene"></span>Scene {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ScenePublicMethods-0">Scene Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-7" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-7"><i></i></a><div id="fragbit-7" class="collapse"><div class="fragmentcode">       <a href="#Scene" class="code">Scene</a>(std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; <a href="#Scene::aggregate" class="code">aggregate</a>,
             const std::vector&lt;std::shared_ptr&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt;&gt; &amp;<a href="#Scene::lights" class="code">lights</a>)
           : <a href="#Scene::lights" class="code">lights</a>(<a href="#Scene::lights" class="code">lights</a>), <a href="#Scene::aggregate" class="code">aggregate</a>(<a href="#Scene::aggregate" class="code">aggregate</a>) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-SceneConstructorImplementation-0">Scene Constructor Implementation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-8" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-8"><i></i></a><div id="fragbit-8" class="collapse"><div class="fragmentcode">              <a href="#Scene::worldBound" class="code">worldBound</a> = aggregate-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::WorldBound" class="code">WorldBound</a>();
              for (const auto &amp;light : <a href="#Scene::lights" class="code">lights</a>)
                  light-&gt;<a href="../Light_Sources/Light_Interface.html#Light::Preprocess" class="code">Preprocess</a>(*this);</div></div>
       }
       const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;WorldBound() const { return <a href="#Scene::worldBound" class="code">worldBound</a>; }
       bool Intersect(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect) const;
       bool IntersectP(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray) const;
       bool IntersectTr(<a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> ray, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect,
           <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> *transmittance) const;</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ScenePublicData-0">Scene Public Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-9" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-9"><i></i></a><div id="fragbit-9" class="collapse"><div class="fragmentcode">       std::vector&lt;std::shared_ptr&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt;&gt; lights;</div></div>
private:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ScenePrivateData-0">Scene Private Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-10" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-10"><i></i></a><div id="fragbit-10" class="collapse"><div class="fragmentcode">       std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; aggregate;
       <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> worldBound;</div></div>
};</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-ScenePublicMethods-0"></span><div class="fragmentname">&lt;&lt;Scene Public Methods&gt;&gt;=&nbsp;<a href="#fragment-ScenePublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#Scene" class="code">Scene</a>(std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; <a href="#Scene::aggregate" class="code">aggregate</a>,
      const std::vector&lt;std::shared_ptr&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt;&gt; &amp;<a href="#Scene::lights" class="code">lights</a>)
    : <a href="#Scene::lights" class="code">lights</a>(<a href="#Scene::lights" class="code">lights</a>), <a href="#Scene::aggregate" class="code">aggregate</a>(<a href="#Scene::aggregate" class="code">aggregate</a>) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SceneConstructorImplementation-0">Scene Constructor Implementation</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-11" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-11"><i></i></a><div id="fragbit-11" class="collapse"><div class="fragmentcode">       <a href="#Scene::worldBound" class="code">worldBound</a> = aggregate-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::WorldBound" class="code">WorldBound</a>();
       for (const auto &amp;light : <a href="#Scene::lights" class="code">lights</a>)
           light-&gt;<a href="../Light_Sources/Light_Interface.html#Light::Preprocess" class="code">Preprocess</a>(*this);</div></div>
}</div><p>


</p>
<p>Each light source in the scene is represented by a <a href="../Light_Sources/Light_Interface.html#Light"><tt>Light</tt></a> object, which
specifies the shape of a light and the distribution of energy that it emits.
The <a href="#Scene"><tt>Scene</tt></a> stores all of the lights using a <tt>vector</tt> of
<tt>shared_ptr</tt> instances from the C++ standard library. <tt>pbrt</tt> uses shared
pointers to track how many times objects are referenced by other instances.
When the last instance holding a reference (the <a href="#Scene"><tt>Scene</tt></a> in this case) is
destroyed, the reference count reaches zero and the <tt>Light</tt> can be
safely freed, which happens automatically at that point.

</p>
<p>While some renderers
support separate light lists per geometric object, allowing a light to
illuminate only some of the objects in the scene, this idea does not map
well to the physically based rendering approach taken in <tt>pbrt</tt>, so <tt>pbrt</tt> only
supports a single global per-scene list.  Many parts of the system need
access to the lights, so the <tt>Scene</tt> makes them available as a public
member variable.

</p>
<p></p>
<span class="anchor" id="fragment-ScenePublicData-0"></span><div class="fragmentname">&lt;&lt;Scene Public Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::vector&lt;std::shared_ptr&lt;<a href="../Light_Sources/Light_Interface.html#Light" class="code">Light</a>&gt;&gt; <span class="anchor" id="Scene::lights"></span>lights;</div><p>


</p>
<p>Each geometric object in the scene is represented by a <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a>,
which combines two objects: a <a href="../Shapes/Basic_Shape_Interface.html#Shape"><tt>Shape</tt></a> that specifies its geometry, and
a <a href="../Materials/Material_Interface_and_Implementations.html#Material"><tt>Material</tt></a> that describes its appearance (e.g., the object&rsquo;s color,
whether it has a dull or glossy finish).  All of the geometric primitives
are collected into a single aggregate <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a> in the <a href="#Scene"><tt>Scene</tt></a>
member variable <a href="#Scene::aggregate"><tt>Scene::aggregate</tt></a>.  This aggregate is a special kind
of primitive that itself holds references to many other primitives.
Because it implements the <a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive"><tt>Primitive</tt></a> interface it appears no different
from a single primitive to the rest of the system.  The aggregate
implementation stores all the scene&rsquo;s primitives in an acceleration data
structure that reduces the number of unnecessary ray intersection tests
with primitives that are far away from a given ray.

</p>
<p></p>
<span class="anchor" id="fragment-ScenePrivateData-0"></span><div class="fragmentname">&lt;&lt;Scene Private Data&gt;&gt;=&nbsp;<a href="#fragment-ScenePrivateData-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">std::shared_ptr&lt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive" class="code">Primitive</a>&gt; <span class="anchor" id="Scene::aggregate"></span>aggregate;</div><p>


</p>
<p>The constructor caches the bounding box of the scene geometry in the
<tt>worldBound</tt> member variable.

</p>
<p></p>
<span class="anchor" id="fragment-SceneConstructorImplementation-0"></span><div class="fragmentname">&lt;&lt;Scene Constructor Implementation&gt;&gt;=&nbsp;<a href="#fragment-SceneConstructorImplementation-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#Scene::worldBound" class="code">worldBound</a> = aggregate-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::WorldBound" class="code">WorldBound</a>();</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-ScenePrivateData-1"></span><div class="fragmentname">&lt;&lt;Scene Private Data&gt;&gt;+=&nbsp;<a href="#fragment-ScenePrivateData-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> <span class="anchor" id="Scene::worldBound"></span>worldBound;</div><p>


</p>
<p>The bound is made available via the <tt>WorldBound()</tt> method.

</p>
<p></p>
<span class="anchor" id="fragment-ScenePublicMethods-1"></span><div class="fragmentname">&lt;&lt;Scene Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-ScenePublicMethods-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">const <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds3f" class="code">Bounds3f</a> &amp;<span class="anchor" id="Scene::WorldBound"></span>WorldBound() const { return <a href="#Scene::worldBound" class="code">worldBound</a>; }</div><p>


</p>
<p>Some <tt>Light</tt> implementations find it useful to do some additional
initialization after the scene has been defined but before rendering
begins.  The <tt>Scene</tt> constructor calls their <tt>Preprocess()</tt>
methods to allow them to do so.

</p>
<p></p>
<span class="anchor" id="fragment-SceneConstructorImplementation-1"></span><div class="fragmentname">&lt;&lt;Scene Constructor Implementation&gt;&gt;+=&nbsp;<a href="#fragment-SceneConstructorImplementation-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">for (const auto &amp;light : <a href="#Scene::lights" class="code">lights</a>)
    light-&gt;<a href="../Light_Sources/Light_Interface.html#Light::Preprocess" class="code">Preprocess</a>(*this);</div><p>


</p>
<p>The <a href="#Scene"><tt>Scene</tt></a> class provides two methods related to ray&ndash;primitive
intersection.  Its <tt>Intersect()</tt> method traces the given ray into the
scene and returns a Boolean value indicating whether the ray intersected
any of the primitives.  If so, it fills in the provided
<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> structure with information about the closest
intersection point along the ray.  The <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> structure
is defined in Section&nbsp;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#sec:primitives">4.1</a>.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-SceneMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;Scene Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-SceneMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">bool <span class="anchor" id="Scene::Intersect"></span><a href="#Scene" class="code">Scene</a>::<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray, <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> *isect) const {
    return <a href="#Scene::aggregate" class="code">aggregate</a>-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::Intersect" class="code">Intersect</a>(ray, isect);
}</div><p>


</p>
<p>A closely related method is <a href="#Scene::IntersectP"><tt>Scene::IntersectP()</tt></a>, which checks for the
existence of intersections along the ray but does not return any
information about those intersections.  Because this routine doesn&rsquo;t need
to search for the closest intersection or compute any additional
information about intersections, it is generally more efficient than
<a href="#Scene::Intersect"><tt>Scene::Intersect()</tt></a>.  This routine is used for shadow rays.

</p>
<p></p>
<span class="anchor" id="fragment-SceneMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;Scene Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-SceneMethodDefinitions-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="../Volume_Scattering/Media.html#fragment-SceneMethodDefinitions-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">bool <span class="anchor" id="Scene::IntersectP"></span><a href="#Scene" class="code">Scene</a>::<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::IntersectP" class="code">IntersectP</a>(const <a href="../Geometry_and_Transformations/Rays.html#Ray" class="code">Ray</a> &amp;ray) const {
    return <a href="#Scene::aggregate" class="code">aggregate</a>-&gt;<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#Primitive::IntersectP" class="code">IntersectP</a>(ray);
}</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#IntegratorInterfaceandSamplerIntegrator"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:integrator-intro"></span><span id="IntegratorInterfaceandSamplerIntegrator"></span><h3>1.3.3  Integrator Interface and SamplerIntegrator</h3><p>



</p>
<p> Rendering an image of the scene is handled by an instance of a
class that implements the <tt>Integrator</tt> interface.  <a href="#Integrator"><tt>Integrator</tt></a> is
an abstract base class that defines the <tt>Render()</tt> method that must be provided by
all integrators.  In this section, we will define one <a href="#Integrator"><tt>Integrator</tt></a> implementation, the
<a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a>.  The basic integrator interfaces are defined in
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/integrator.h"><tt>core/integrator.h</tt></a>, and some utility functions used by integrators
are in <a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/integrator.cpp"><tt>core/integrator.cpp</tt></a>.  The implementations of the various
integrators are in the <tt>integrators</tt> directory.

</p>
<p>

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorDeclarations-0"></span><div class="fragmentname">&lt;&lt;Integrator Declarations&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="Integrator"></span>Integrator {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-IntegratorInterface-0">Integrator Interface</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-12" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-12"><i></i></a><div id="fragbit-12" class="collapse"><div class="fragmentcode">       virtual ~<a href="#Integrator" class="code">Integrator</a>();
       virtual void Render(const <a href="#Scene" class="code">Scene</a> &amp;scene) = 0;</div></div>
};</div><p>


</p>
<p>

</p>
<p>
The method that <a href="#Integrator"><tt>Integrator</tt></a>s must provide is <tt>Render()</tt>; it
is passed a reference to the <a href="#Scene"><tt>Scene</tt></a> to use to compute
an image of the scene or more generally, a set of measurements of the scene
lighting.  This interface is intentionally kept very general to permit a
wide range of implementations&mdash;for example, one could implement an
<a href="#Integrator"><tt>Integrator</tt></a> that takes measurements only at a sparse set of
positions distributed through the scene rather than generating a regular
2D image.

</p>
<p></p>
<span class="anchor" id="fragment-IntegratorInterface-0"></span><div class="fragmentname">&lt;&lt;Integrator Interface&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">virtual void <span class="anchor" id="Integrator::Render"></span>Render(const <a href="#Scene" class="code">Scene</a> &amp;scene) = 0;</div><p>


</p>
<p>In this chapter, we&rsquo;ll focus on <a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a>, which is an
<a href="#Integrator"><tt>Integrator</tt></a> subclass, and the <a href="#WhittedIntegrator"><tt>WhittedIntegrator</tt></a>, which
implements the <a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a> interface. (Implementations of other
<a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a>s will be introduced in Chapters&nbsp;<a href="../Light_Transport_I_Surface_Reflection.html#chap:light-transport">14</a> and&nbsp;<a href="../Light_Transport_II_Volume_Rendering.html#chap:volume-integration">15</a>; the
integrators in Chapter&nbsp;<a href="../Light_Transport_III_Bidirectional_Methods.html#chap:bidir-methods">16</a> inherit directly from
<a href="#Integrator"><tt>Integrator</tt></a>.)  The name of the <tt>SamplerIntegrator</tt> derives from
the fact that its rendering process is driven by a stream of <em>sample</em>s
from a <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>; each such sample identifies a point on the image at
which the integrator should compute the arriving light to form the image.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorDeclarations-0"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Declarations&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="SamplerIntegrator"></span>SamplerIntegrator : public <a href="#Integrator" class="code">Integrator</a> {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SamplerIntegratorPublicMethods-0">SamplerIntegrator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-13" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-13"><i></i></a><div id="fragbit-13" class="collapse"><div class="fragmentcode">       <a href="#SamplerIntegrator" class="code">SamplerIntegrator</a>(std::shared_ptr&lt;const <a href="../Camera_Models/Camera_Model.html#Camera" class="code">Camera</a>&gt; <a href="#SamplerIntegrator::camera" class="code">camera</a>,
               std::shared_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; <a href="#SamplerIntegrator::sampler" class="code">sampler</a>)
           : <a href="#SamplerIntegrator::camera" class="code">camera</a>(<a href="#SamplerIntegrator::camera" class="code">camera</a>), <a href="#SamplerIntegrator::sampler" class="code">sampler</a>(<a href="#SamplerIntegrator::sampler" class="code">sampler</a>) { }
       virtual void Preprocess(const <a href="#Scene" class="code">Scene</a> &amp;scene, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;<a href="#SamplerIntegrator::sampler" class="code">sampler</a>) { }
       void Render(const <a href="#Scene" class="code">Scene</a> &amp;scene);
       virtual <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> Li(const RayDifferential &amp;ray, const <a href="#Scene" class="code">Scene</a> &amp;scene,
           <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;<a href="#SamplerIntegrator::sampler" class="code">sampler</a>, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, int depth = 0) const = 0;
       <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> SpecularReflect(const RayDifferential &amp;ray,
           const <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;isect, const <a href="#Scene" class="code">Scene</a> &amp;scene, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;<a href="#SamplerIntegrator::sampler" class="code">sampler</a>,
           <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, int depth) const;
       <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> SpecularTransmit(const RayDifferential &amp;ray,
           const <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;isect, const <a href="#Scene" class="code">Scene</a> &amp;scene, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;<a href="#SamplerIntegrator::sampler" class="code">sampler</a>,
           <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, int depth) const;</div></div>
protected:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SamplerIntegratorProtectedData-0">SamplerIntegrator Protected Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-14" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-14"><i></i></a><div id="fragbit-14" class="collapse"><div class="fragmentcode">       std::shared_ptr&lt;const <a href="../Camera_Models/Camera_Model.html#Camera" class="code">Camera</a>&gt; camera;</div></div>
private:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-SamplerIntegratorPrivateData-0">SamplerIntegrator Private Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-15" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-15"><i></i></a><div id="fragbit-15" class="collapse"><div class="fragmentcode">       std::shared_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; sampler;</div></div>
};</div><p>


</p>
<p>The <a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a> stores a pointer to a <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a>.  The role
of the sampler is subtle, but its implementation can substantially affect
the quality of the images that the system generates.  First, the sampler is
responsible for choosing the points on the image plane from which rays are
traced.  Second, it is responsible for supplying the sample positions used
by integrators for estimating the value of the light transport integral,
Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>). For example, some integrators need
to choose random points on light sources to compute illumination from area
lights.  Generating a good distribution of these samples is an important
part of the rendering process that can substantially affect overall
efficiency; this topic is the main focus of
Chapter&nbsp;<a href="../Sampling_and_Reconstruction.html#chap:sampling-reconstruction">7</a>.

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorPrivateData-0"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Private Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::shared_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; <span class="anchor" id="SamplerIntegrator::sampler"></span>sampler;</div><p>


</p>
<p>The <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a> object controls the viewing and lens parameters such as
position, orientation, focus, and field of view.  A <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a> member
variable inside the <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a> class handles image storage.  The
<a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a> classes are described in Chapter&nbsp;<a href="../Camera_Models.html#chap:camera">6</a>, and
<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a> is described in Section&nbsp;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#sec:image-pipeline">7.9</a>.  The
<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a> is responsible for writing the final image to a file and
possibly displaying it on the screen as it is being computed.

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorProtectedData-0"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Protected Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::shared_ptr&lt;const <a href="../Camera_Models/Camera_Model.html#Camera" class="code">Camera</a>&gt; <span class="anchor" id="SamplerIntegrator::camera"></span>camera;</div><p>


</p>
<p>The <a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a> constructor stores pointers to these
objects in member variables.  The <a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a> is created in the
<a href="../Scene_Description_Interface/Scene_Definition.html#RenderOptions::MakeIntegrator"><tt>RenderOptions::MakeIntegrator()</tt></a> method, which is in turn called by
<a href="../Scene_Description_Interface/Scene_Definition.html#pbrtWorldEnd"><tt>pbrtWorldEnd()</tt></a>, which is called by the input file parser when it is done
parsing a scene description from an input file and is ready to render the
scene.

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Public Methods&gt;&gt;=&nbsp;<a href="#fragment-SamplerIntegratorPublicMethods-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode"><a href="#SamplerIntegrator" class="code">SamplerIntegrator</a>(std::shared_ptr&lt;const <a href="../Camera_Models/Camera_Model.html#Camera" class="code">Camera</a>&gt; <a href="#SamplerIntegrator::camera" class="code">camera</a>,
        std::shared_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; <a href="#SamplerIntegrator::sampler" class="code">sampler</a>)
    : <a href="#SamplerIntegrator::camera" class="code">camera</a>(<a href="#SamplerIntegrator::camera" class="code">camera</a>), <a href="#SamplerIntegrator::sampler" class="code">sampler</a>(<a href="#SamplerIntegrator::sampler" class="code">sampler</a>) { }</div><p>


</p>
<p><tt>SamplerIntegrator</tt> implementations may optionally implement the
<tt>Preprocess()</tt> method.  It is called after the <a href="#Scene"><tt>Scene</tt></a> has been
fully initialized and gives the integrator a chance to do scene-dependent
computation, such as allocating additional data structures that are
dependent on the number of lights in the scene, or precomputing a rough
representation of the distribution of radiance in the scene.
Implementations that don&rsquo;t need to do anything along these lines can leave
this method unimplemented.

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorPublicMethods-1"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-SamplerIntegratorPublicMethods-0"><span class="fa fa-caret-up"></span></a>&nbsp;<a href="#fragment-SamplerIntegratorPublicMethods-2"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">virtual void <span class="anchor" id="SamplerIntegrator::Preprocess"></span>Preprocess(const <a href="#Scene" class="code">Scene</a> &amp;scene, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler) { }</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#TheMainRenderingLoop"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:rendering-loop"></span><span id="TheMainRenderingLoop"></span><h3>1.3.4  The Main Rendering Loop</h3><p>



</p>
<p> After the <a href="#Scene"><tt>Scene</tt></a> and the <a href="#Integrator"><tt>Integrator</tt></a> have been allocated
and initialized, the <a href="#Integrator::Render"><tt>Integrator::Render()</tt></a> method is invoked, starting
the second phase of <tt>pbrt</tt>&rsquo;s execution: the main rendering loop.  In the
<a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a>&rsquo;s implementation of this method, at each of a series
of positions on the image plane, the method uses the <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a> and the
<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> to generate a ray into the scene and then uses the
<tt>Li()</tt> method to determine the amount of light arriving at the image plane
along that ray.  This value is passed to the <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a>, which records the
light&rsquo;s contribution.  Figure&nbsp;<a href="#fig:main-render-loop-classes">1.17</a> summarizes
the main classes used in this method and the flow of data among them.

</p>
<p></p>
<span class="anchor" id="fig:main-render-loop-classes"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Class%20Relationships.svg" title=""><img src="Class%20Relationships.svg" width=893 height=262 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 1.17: Class Relationships for the Main
Rendering Loop in the
<a href="#SamplerIntegrator::Render"><tt>SamplerIntegrator::Render()</tt></a> Method in
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/integrator.cpp"><tt>core/integrator.cpp</tt></a>. <span class="legend">  The <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> provides a
sequence of sample values,
one for each image sample to be taken.  The <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a> turns a sample
into a corresponding ray from the film plane, and the <tt>Li()</tt> method implementation
computes the radiance along that ray arriving at the film.  The sample and
its radiance are given to the <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a>, which stores their contribution
in an image.  This process repeats until the <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> has provided as
many samples as are necessary to generate the final image.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Method Definitions&gt;&gt;=&nbsp;<a href="#fragment-SamplerIntegratorMethodDefinitions-1"><span class="fa fa-caret-down"></span></a></div>
<div class="fragmentcode">void <span class="anchor" id="SamplerIntegrator::Render"></span><a href="#SamplerIntegrator" class="code">SamplerIntegrator</a>::Render(const <a href="#Scene" class="code">Scene</a> &amp;scene) {
    <a href="#SamplerIntegrator::Preprocess" class="code">Preprocess</a>(scene, *sampler);
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Renderimagetilesinparallel-0">Render image tiles in parallel</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-16" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-16"><i></i></a><div id="fragbit-16" class="collapse"><div class="fragmentcode">       &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputenumberoftilesmononTilestouseforparallelrendering-0">Compute number of tiles, <tt>nTiles</tt>, to use for parallel rendering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-17" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-17"><i></i></a><div id="fragbit-17" class="collapse"><div class="fragmentcode">          Bounds2i sampleBounds = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetSampleBounds" class="code">GetSampleBounds</a>();
          Vector2i sampleExtent = sampleBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Diagonal" class="code">Diagonal</a>();
          const int tileSize = 16;
          <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> nTiles((sampleExtent.x + tileSize - 1) / tileSize,
                         (sampleExtent.y + tileSize - 1) / tileSize);</div></div>
       <a href="../Utilities/Parallelism.html#ParallelFor2D" class="code">ParallelFor2D</a>(
           [&amp;](<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> tile) {
               &lt;&lt;<span class="fragmentname"><a href="#fragment-Rendersectionofimagecorrespondingtomonotile-0">Render section of image corresponding to <tt>tile</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-18" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-18"><i></i></a><div id="fragbit-18" class="collapse"><div class="fragmentcode">                  &lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoMemoryArenafortile-0">Allocate <tt>MemoryArena</tt> for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-19" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-19"><i></i></a><div id="fragbit-19" class="collapse"><div class="fragmentcode">                     <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> arena;</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Getsamplerinstancefortile-0">Get sampler instance for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-20" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-20"><i></i></a><div id="fragbit-20" class="collapse"><div class="fragmentcode">                     int seed = tile.y * nTiles.x + tile.x;
                     std::unique_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; tileSampler = sampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Clone" class="code">Clone</a>(seed);</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Computesampleboundsfortile-0">Compute sample bounds for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-21" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-21"><i></i></a><div id="fragbit-21" class="collapse"><div class="fragmentcode">                     int x0 = sampleBounds.pMin.x + tile.x * tileSize;
                     int x1 = std::min(x0 + tileSize, sampleBounds.pMax.x);
                     int y0 = sampleBounds.pMin.y + tile.y * tileSize;
                     int y1 = std::min(y0 + tileSize, sampleBounds.pMax.y);
                     Bounds2i tileBounds(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x0, y0), <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x1, y1));</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-GetmonoFilmTilefortile-0">Get <tt>FilmTile</tt> for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-22" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-22"><i></i></a><div id="fragbit-22" class="collapse"><div class="fragmentcode">                     std::unique_ptr&lt;FilmTile&gt; filmTile =
                         <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetFilmTile" class="code">GetFilmTile</a>(tileBounds);</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-Loopoverpixelsintiletorenderthem-0">Loop over pixels in tile to render them</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-23" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-23"><i></i></a><div id="fragbit-23" class="collapse"><div class="fragmentcode">                     for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pixel : tileBounds) {
                         tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixel" class="code">StartPixel</a>(pixel);
                         do {
                             &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoCameraSampleforcurrentsample-0">Initialize <tt>CameraSample</tt> for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-24" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-24"><i></i></a><div id="fragbit-24" class="collapse"><div class="fragmentcode">                                CameraSample cameraSample = tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::GetCameraSample" class="code">GetCameraSample</a>(pixel);</div></div>
                             &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecamerarayforcurrentsample-0">Generate camera ray for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-25" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-25"><i></i></a><div id="fragbit-25" class="collapse"><div class="fragmentcode">                                RayDifferential ray;
                                <a href="../Utilities/Main_Include_File.html#Float" class="code">Float</a> rayWeight = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::GenerateRayDifferential" class="code">GenerateRayDifferential</a>(cameraSample, &amp;ray);
                                ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(1 / std::sqrt(tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::samplesPerPixel" class="code">samplesPerPixel</a>));
                                </div></div>
                             &lt;&lt;<span class="fragmentname"><a href="#fragment-Evaluateradiancealongcameraray-0">Evaluate radiance along camera ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-26" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-26"><i></i></a><div id="fragbit-26" class="collapse"><div class="fragmentcode">                                <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> L(0.f);
                                if (rayWeight &gt; 0)
                                    L = <a href="#SamplerIntegrator::Li" class="code">Li</a>(ray, scene, *tileSampler, arena);
                                &lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-27" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-27"><i></i></a><div id="fragbit-27" class="collapse"><div class="fragmentcode">                                   if (L.HasNaNs()) {
                                       Error("Not-a-number radiance value returned "
                                             "for image sample.  Setting to black.");
                                       L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                                   }
                                   else if (L.y() &lt; -1e-5) {
                                       Error("Negative luminance value, %f, returned "
                                             "for image sample.  Setting to black.", L.y());
                                       L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                                   }
                                   else if (std::isinf(L.y())) {
                                       Error("Infinite luminance value returned "
                                             "for image sample.  Setting to black.");
                                       L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                                   }</div></div></div></div>
                             &lt;&lt;<span class="fragmentname"><a href="#fragment-Addcamerarayscontributiontoimage-0">Add camera ray&rsquo;s contribution to image</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-28" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-28"><i></i></a><div id="fragbit-28" class="collapse"><div class="fragmentcode">                                filmTile-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#FilmTile::AddSample" class="code">AddSample</a>(cameraSample.<a href="../Camera_Models/Camera_Model.html#CameraSample::pFilm" class="code">pFilm</a>, L, rayWeight);</div></div>
                             &lt;&lt;<span class="fragmentname"><a href="#fragment-FreeuseMemoryArenamemoryfromcomputingimagesamplevalue-0">Free <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> memory from computing image sample value</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-29" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-29"><i></i></a><div id="fragbit-29" class="collapse"><div class="fragmentcode">                                arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Reset" class="code">Reset</a>();</div></div>
                         } while (tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartNextSample" class="code">StartNextSample</a>());
                     }</div></div>
                  &lt;&lt;<span class="fragmentname"><a href="#fragment-MergeimagetileintomonoFilm-0">Merge image tile into <tt>Film</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-30" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-30"><i></i></a><div id="fragbit-30" class="collapse"><div class="fragmentcode">                     <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::MergeFilmTile" class="code">MergeFilmTile</a>(std::move(filmTile));
                     </div></div></div></div>
           }, nTiles);
       </div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Savefinalimageafterrendering-0">Save final image after rendering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-31" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-31"><i></i></a><div id="fragbit-31" class="collapse"><div class="fragmentcode">       <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::WriteImage" class="code">WriteImage</a>();</div></div>
}</div><p>


</p>
<p>So that rendering can proceed in parallel on systems with multiple
processing cores, the image is decomposed into small tiles of pixels.  Each
tile can be processed independently and in parallel.  The
<tt>ParallelFor()</tt> function, which is described in more detail in
Section&nbsp;<a href="../Utilities/Parallelism.html#sec:parallelism">A.6</a>, implements a parallel <tt>for</tt> loop, where
multiple iterations may run in parallel.  A C++ lambda expression provides
the loop body.  Here, a variant of <tt>ParallelFor()</tt> that loops over a
2D domain is used to iterate over the image tiles.

</p>
<p></p>
<span class="anchor" id="fragment-Renderimagetilesinparallel-0"></span><div class="fragmentname">&lt;&lt;Render image tiles in parallel&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-ComputenumberoftilesmononTilestouseforparallelrendering-0">Compute number of tiles, <tt>nTiles</tt>, to use for parallel rendering</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-32" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-32"><i></i></a><div id="fragbit-32" class="collapse"><div class="fragmentcode">   Bounds2i sampleBounds = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetSampleBounds" class="code">GetSampleBounds</a>();
   Vector2i sampleExtent = sampleBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Diagonal" class="code">Diagonal</a>();
   const int tileSize = 16;
   <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> nTiles((sampleExtent.x + tileSize - 1) / tileSize,
                  (sampleExtent.y + tileSize - 1) / tileSize);</div></div>
<a href="../Utilities/Parallelism.html#ParallelFor2D" class="code">ParallelFor2D</a>(
    [&amp;](<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> tile) {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Rendersectionofimagecorrespondingtomonotile-0">Render section of image corresponding to <tt>tile</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-33" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-33"><i></i></a><div id="fragbit-33" class="collapse"><div class="fragmentcode">           &lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoMemoryArenafortile-0">Allocate <tt>MemoryArena</tt> for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-34" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-34"><i></i></a><div id="fragbit-34" class="collapse"><div class="fragmentcode">              <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> arena;</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Getsamplerinstancefortile-0">Get sampler instance for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-35" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-35"><i></i></a><div id="fragbit-35" class="collapse"><div class="fragmentcode">              int seed = tile.y * nTiles.x + tile.x;
              std::unique_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; tileSampler = sampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Clone" class="code">Clone</a>(seed);</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Computesampleboundsfortile-0">Compute sample bounds for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-36" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-36"><i></i></a><div id="fragbit-36" class="collapse"><div class="fragmentcode">              int x0 = sampleBounds.pMin.x + tile.x * tileSize;
              int x1 = std::min(x0 + tileSize, sampleBounds.pMax.x);
              int y0 = sampleBounds.pMin.y + tile.y * tileSize;
              int y1 = std::min(y0 + tileSize, sampleBounds.pMax.y);
              Bounds2i tileBounds(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x0, y0), <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x1, y1));</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-GetmonoFilmTilefortile-0">Get <tt>FilmTile</tt> for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-37" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-37"><i></i></a><div id="fragbit-37" class="collapse"><div class="fragmentcode">              std::unique_ptr&lt;FilmTile&gt; filmTile =
                  <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetFilmTile" class="code">GetFilmTile</a>(tileBounds);</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Loopoverpixelsintiletorenderthem-0">Loop over pixels in tile to render them</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-38" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-38"><i></i></a><div id="fragbit-38" class="collapse"><div class="fragmentcode">              for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pixel : tileBounds) {
                  tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixel" class="code">StartPixel</a>(pixel);
                  do {
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoCameraSampleforcurrentsample-0">Initialize <tt>CameraSample</tt> for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-39" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-39"><i></i></a><div id="fragbit-39" class="collapse"><div class="fragmentcode">                         CameraSample cameraSample = tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::GetCameraSample" class="code">GetCameraSample</a>(pixel);</div></div>
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecamerarayforcurrentsample-0">Generate camera ray for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-40" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-40"><i></i></a><div id="fragbit-40" class="collapse"><div class="fragmentcode">                         RayDifferential ray;
                         <a href="../Utilities/Main_Include_File.html#Float" class="code">Float</a> rayWeight = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::GenerateRayDifferential" class="code">GenerateRayDifferential</a>(cameraSample, &amp;ray);
                         ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(1 / std::sqrt(tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::samplesPerPixel" class="code">samplesPerPixel</a>));
                         </div></div>
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-Evaluateradiancealongcameraray-0">Evaluate radiance along camera ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-41" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-41"><i></i></a><div id="fragbit-41" class="collapse"><div class="fragmentcode">                         <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> L(0.f);
                         if (rayWeight &gt; 0)
                             L = <a href="#SamplerIntegrator::Li" class="code">Li</a>(ray, scene, *tileSampler, arena);
                         &lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-42" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-42"><i></i></a><div id="fragbit-42" class="collapse"><div class="fragmentcode">                            if (L.HasNaNs()) {
                                Error("Not-a-number radiance value returned "
                                      "for image sample.  Setting to black.");
                                L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                            }
                            else if (L.y() &lt; -1e-5) {
                                Error("Negative luminance value, %f, returned "
                                      "for image sample.  Setting to black.", L.y());
                                L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                            }
                            else if (std::isinf(L.y())) {
                                Error("Infinite luminance value returned "
                                      "for image sample.  Setting to black.");
                                L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                            }</div></div></div></div>
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-Addcamerarayscontributiontoimage-0">Add camera ray&rsquo;s contribution to image</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-43" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-43"><i></i></a><div id="fragbit-43" class="collapse"><div class="fragmentcode">                         filmTile-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#FilmTile::AddSample" class="code">AddSample</a>(cameraSample.<a href="../Camera_Models/Camera_Model.html#CameraSample::pFilm" class="code">pFilm</a>, L, rayWeight);</div></div>
                      &lt;&lt;<span class="fragmentname"><a href="#fragment-FreeuseMemoryArenamemoryfromcomputingimagesamplevalue-0">Free <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> memory from computing image sample value</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-44" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-44"><i></i></a><div id="fragbit-44" class="collapse"><div class="fragmentcode">                         arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Reset" class="code">Reset</a>();</div></div>
                  } while (tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartNextSample" class="code">StartNextSample</a>());
              }</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-MergeimagetileintomonoFilm-0">Merge image tile into <tt>Film</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-45" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-45"><i></i></a><div id="fragbit-45" class="collapse"><div class="fragmentcode">              <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::MergeFilmTile" class="code">MergeFilmTile</a>(std::move(filmTile));
              </div></div></div></div>
    }, nTiles);
</div><p>


</p>
<p>There are two factors to trade off in deciding how large to make the image
tiles: load-balancing and per-tile overhead.  On one hand, we&rsquo;d like to
have significantly more tiles than there are processors in the system:
consider a four-core computer with only four tiles.  In general, it&rsquo;s
likely that some of the tiles will take less processing time than others;
the ones that are responsible for parts of the image where the scene is
relatively simple will usually take less processing time than parts of the
image where the scene is relatively complex.  Therefore, if the number of
tiles was equal to the number of processors, some processors would finish
before others and sit idle while waiting for the processor that had the
longest running tile.  Figure&nbsp;<a href="#fig:task-time-distribution">1.18</a> illustrates
this issue; it shows the distribution of execution time for the tiles used
to render the shiny sphere scene in
Figure&nbsp;<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#fig:intro-raytracing-example">1.7</a>.  The longest running one took
151 times longer than the shortest one.

</p>
<p></p>
<span class="anchor" id="fig:task-time-distribution"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="bucket-time.svg" title=""><img src="bucket-time.svg" width=360 height=218 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 1.18: Histogram of Time Spent Rendering Each Tile for the
  Scene in Figure&nbsp;<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#fig:intro-raytracing-example">1.7</a>. <span class="legend">
The horizontal axis measures time in seconds.
Note the wide variation in execution time, illustrating
that different parts of the image required substantially different amounts of
computation.
</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>On the other hand, having tiles that are too small is also inefficient.
There is a small fixed overhead for a processing core to determine which
loop iteration it should run next; the more tiles there are, the more times
this overhead must be paid.

</p>
<p>For simplicity, <tt>pbrt</tt> always uses <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.49ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 3224.9 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">16 times 16</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-36" d="M457 204c0 -132 -95 -226 -206 -226c-93 0 -209 71 -209 338c0 221 135 350 263 350c83 0 127 -48 127 -108c0 -39 -30 -48 -46 -48c-22 0 -46 15 -46 46c0 45 40 45 55 45c-22 34 -64 40 -88 40c-51 0 -175 -36 -175 -289v-24c20 48 57 99 125 99 c111 0 200 -96 200 -223zM367 205c0 49 0 100 -18 137c-31 62 -77 62 -93 62c-90 0 -122 -100 -122 -178c0 -18 0 -98 18 -145c6 -15 36 -75 99 -75c23 0 69 5 99 65c17 36 17 86 17 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-D7" d="M624 15c-7 -8 -20 -8 -28 0l-207 207l-207 -207c-8 -8 -21 -8 -28 0c-8 7 -8 20 0 28l207 207l-207 207c-8 8 -8 21 0 28c7 8 20 8 28 0l207 -207l207 207c8 8 21 8 28 0c8 -7 8 -20 0 -28l-207 -207l207 -207c8 -8 8 -21 0 -28Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-D7" x="1223" y="0"></use>
<g transform="translate(2223,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
</g>
</g>
</svg> tiles; this granularity
works well for almost all images, except for very low-resolution ones.  We
implicitly assume that the small image case isn&rsquo;t particularly important to
render at maximum efficiency.  The <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a>&rsquo;s
<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetSampleBounds"><tt>GetSampleBounds()</tt></a>
method returns the extent of pixels over which
samples must be generated for the image being rendered.
The addition of <tt>tileSize - 1</tt> in the computation of <tt>nTiles</tt>
results in a number of tiles that is rounded to the next higher integer when
the sample bounds along an axis are not exactly divisible by <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.325ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 1001 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">16</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-36" d="M457 204c0 -132 -95 -226 -206 -226c-93 0 -209 71 -209 338c0 221 135 350 263 350c83 0 127 -48 127 -108c0 -39 -30 -48 -46 -48c-22 0 -46 15 -46 46c0 45 40 45 55 45c-22 34 -64 40 -88 40c-51 0 -175 -36 -175 -289v-24c20 48 57 99 125 99 c111 0 200 -96 200 -223zM367 205c0 49 0 100 -18 137c-31 62 -77 62 -93 62c-90 0 -122 -100 -122 -178c0 -18 0 -98 18 -145c6 -15 36 -75 99 -75c23 0 69 5 99 65c17 36 17 86 17 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
</g>
</svg>. This means
that the lambda function invoked by <a href="../Utilities/Parallelism.html#ParallelFor"><tt>ParallelFor()</tt></a> must be able to deal with
partial tiles containing some unused pixels.

</p>
<p></p>
<span class="anchor" id="fragment-ComputenumberoftilesmononTilestouseforparallelrendering-0"></span><div class="fragmentname">&lt;&lt;Compute number of tiles, <tt>nTiles</tt>, to use for parallel rendering&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">Bounds2i sampleBounds = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetSampleBounds" class="code">GetSampleBounds</a>();
Vector2i sampleExtent = sampleBounds.<a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2::Diagonal" class="code">Diagonal</a>();
const int tileSize = 16;
<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> nTiles((sampleExtent.x + tileSize - 1) / tileSize,
               (sampleExtent.y + tileSize - 1) / tileSize);</div><p>


</p>
<p>When the parallel <tt>for</tt> loop implementation that is defined in
Appendix&nbsp;<a href="../Utilities/Parallelism.html#sec:parallel-for">A.6.4</a> decides to run a loop iteration on a particular
processor, the lambda will be called with the tile&rsquo;s coordinates.  It
starts by doing a little bit of setup work, determining which part of the film
plane it is responsible for and allocating space for some temporary data
before using the <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> to generate image samples, the <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a>
to determine corresponding rays leaving the film plane, and the
<tt>Li()</tt> method to compute radiance along those rays arriving at the
film.

</p>
<p></p>
<span class="anchor" id="fragment-Rendersectionofimagecorrespondingtomonotile-0"></span><div class="fragmentname">&lt;&lt;Render section of image corresponding to <tt>tile</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-AllocatemonoMemoryArenafortile-0">Allocate <tt>MemoryArena</tt> for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-46" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-46"><i></i></a><div id="fragbit-46" class="collapse"><div class="fragmentcode">   <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> arena;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Getsamplerinstancefortile-0">Get sampler instance for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-47" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-47"><i></i></a><div id="fragbit-47" class="collapse"><div class="fragmentcode">   int seed = tile.y * nTiles.x + tile.x;
   std::unique_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; tileSampler = sampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Clone" class="code">Clone</a>(seed);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computesampleboundsfortile-0">Compute sample bounds for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-48" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-48"><i></i></a><div id="fragbit-48" class="collapse"><div class="fragmentcode">   int x0 = sampleBounds.pMin.x + tile.x * tileSize;
   int x1 = std::min(x0 + tileSize, sampleBounds.pMax.x);
   int y0 = sampleBounds.pMin.y + tile.y * tileSize;
   int y1 = std::min(y0 + tileSize, sampleBounds.pMax.y);
   Bounds2i tileBounds(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x0, y0), <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x1, y1));</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-GetmonoFilmTilefortile-0">Get <tt>FilmTile</tt> for tile</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-49" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-49"><i></i></a><div id="fragbit-49" class="collapse"><div class="fragmentcode">   std::unique_ptr&lt;FilmTile&gt; filmTile =
       <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetFilmTile" class="code">GetFilmTile</a>(tileBounds);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Loopoverpixelsintiletorenderthem-0">Loop over pixels in tile to render them</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-50" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-50"><i></i></a><div id="fragbit-50" class="collapse"><div class="fragmentcode">   for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pixel : tileBounds) {
       tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixel" class="code">StartPixel</a>(pixel);
       do {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoCameraSampleforcurrentsample-0">Initialize <tt>CameraSample</tt> for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-51" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-51"><i></i></a><div id="fragbit-51" class="collapse"><div class="fragmentcode">              CameraSample cameraSample = tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::GetCameraSample" class="code">GetCameraSample</a>(pixel);</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecamerarayforcurrentsample-0">Generate camera ray for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-52" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-52"><i></i></a><div id="fragbit-52" class="collapse"><div class="fragmentcode">              RayDifferential ray;
              <a href="../Utilities/Main_Include_File.html#Float" class="code">Float</a> rayWeight = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::GenerateRayDifferential" class="code">GenerateRayDifferential</a>(cameraSample, &amp;ray);
              ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(1 / std::sqrt(tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::samplesPerPixel" class="code">samplesPerPixel</a>));
              </div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Evaluateradiancealongcameraray-0">Evaluate radiance along camera ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-53" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-53"><i></i></a><div id="fragbit-53" class="collapse"><div class="fragmentcode">              <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> L(0.f);
              if (rayWeight &gt; 0)
                  L = <a href="#SamplerIntegrator::Li" class="code">Li</a>(ray, scene, *tileSampler, arena);
              &lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-54" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-54"><i></i></a><div id="fragbit-54" class="collapse"><div class="fragmentcode">                 if (L.HasNaNs()) {
                     Error("Not-a-number radiance value returned "
                           "for image sample.  Setting to black.");
                     L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                 }
                 else if (L.y() &lt; -1e-5) {
                     Error("Negative luminance value, %f, returned "
                           "for image sample.  Setting to black.", L.y());
                     L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                 }
                 else if (std::isinf(L.y())) {
                     Error("Infinite luminance value returned "
                           "for image sample.  Setting to black.");
                     L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
                 }</div></div></div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Addcamerarayscontributiontoimage-0">Add camera ray&rsquo;s contribution to image</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-55" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-55"><i></i></a><div id="fragbit-55" class="collapse"><div class="fragmentcode">              filmTile-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#FilmTile::AddSample" class="code">AddSample</a>(cameraSample.<a href="../Camera_Models/Camera_Model.html#CameraSample::pFilm" class="code">pFilm</a>, L, rayWeight);</div></div>
           &lt;&lt;<span class="fragmentname"><a href="#fragment-FreeuseMemoryArenamemoryfromcomputingimagesamplevalue-0">Free <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> memory from computing image sample value</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-56" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-56"><i></i></a><div id="fragbit-56" class="collapse"><div class="fragmentcode">              arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Reset" class="code">Reset</a>();</div></div>
       } while (tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartNextSample" class="code">StartNextSample</a>());
   }</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-MergeimagetileintomonoFilm-0">Merge image tile into <tt>Film</tt></a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-57" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-57"><i></i></a><div id="fragbit-57" class="collapse"><div class="fragmentcode">   <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::MergeFilmTile" class="code">MergeFilmTile</a>(std::move(filmTile));
   </div></div></div><p>


</p>
<p>Implementations of the <tt>Li()</tt> method will generally need to temporarily
allocate small amounts of memory for each radiance computation. The large
number of resulting allocations can easily overwhelm the system&rsquo;s regular memory
allocation routines (e.g., <tt>malloc()</tt> or <tt>new</tt>), which must maintain
and synchronize elaborate internal data structures to track sets of free memory
regions among processors. A naive implementation could potentially spend a
fairly large fraction of its computation time in the memory allocator.

</p>
<p>To address this issue, we will pass an instance of the <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> class
to the <tt>Li()</tt> method. <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> instances manage pools of memory to
enable higher performance allocation than what is possible with the standard
library routines.

</p>
<p>The arena&rsquo;s memory pool is always released in its entirety, which removes the
need for complex internal data structures. Instances of this class can only be
used by a single thread&mdash;concurrent access without additional synchronization
is not permitted. We create a unique <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> for each loop iteration
that can be used directly, which also ensures that the arena is only accessed
by a single thread.

</p>
<p></p>
<span class="anchor" id="fragment-AllocatemonoMemoryArenafortile-0"></span><div class="fragmentname">&lt;&lt;Allocate <tt>MemoryArena</tt> for tile&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> arena;</div><p>


</p>
<p>Most <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler"><tt>Sampler</tt></a> implementations find it useful to maintain some state,
such as the coordinates of the current pixel being sampled.  This means that
multiple processing threads cannot use a single <tt>Sampler</tt>
concurrently.  Therefore, <tt>Sampler</tt>s provide a <tt>Clone()</tt> method
to create a new instance of a given <tt>Sampler</tt>; it takes a seed that is
used by some implementations to seed a pseudo-random number generator so
that the same sequence of pseudo-random numbers isn&rsquo;t generated in every
tile.  (Note that not all <tt>Sampler</tt>s use pseudo-random numbers; those
that don&rsquo;t just ignore the seed.)

</p>
<p></p>
<span class="anchor" id="fragment-Getsamplerinstancefortile-0"></span><div class="fragmentname">&lt;&lt;Get sampler instance for tile&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int seed = tile.y * nTiles.x + tile.x;
std::unique_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; tileSampler = sampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Clone" class="code">Clone</a>(seed);</div><p>


</p>
<p>Next, the extent of pixels to be sampled in this loop iteration is computed
based on the tile indices.  Two issues must be accounted for in this
computation: first, the overall pixel bounds to be sampled may not be equal
to the full image resolution.  For example, the user may have specified a
&ldquo;crop window&rdquo; of just a subset of pixels to sample.  Second, if the image
resolution isn&rsquo;t an exact multiple of 16, then the tiles on the right and
bottom images won&rsquo;t be a full <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.49ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 3224.9 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">16 times 16</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-31" d="M419 0c-35 3 -122 3 -162 3s-127 0 -162 -3v31h32c90 0 93 12 93 48v518c-52 -26 -111 -26 -131 -26v31c32 0 120 0 182 64c23 0 23 -2 23 -26v-561c0 -37 3 -48 93 -48h32v-31Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-36" d="M457 204c0 -132 -95 -226 -206 -226c-93 0 -209 71 -209 338c0 221 135 350 263 350c83 0 127 -48 127 -108c0 -39 -30 -48 -46 -48c-22 0 -46 15 -46 46c0 45 40 45 55 45c-22 34 -64 40 -88 40c-51 0 -175 -36 -175 -289v-24c20 48 57 99 125 99 c111 0 200 -96 200 -223zM367 205c0 49 0 100 -18 137c-31 62 -77 62 -93 62c-90 0 -122 -100 -122 -178c0 -18 0 -98 18 -145c6 -15 36 -75 99 -75c23 0 69 5 99 65c17 36 17 86 17 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-D7" d="M624 15c-7 -8 -20 -8 -28 0l-207 207l-207 -207c-8 -8 -21 -8 -28 0c-8 7 -8 20 0 28l207 207l-207 207c-8 8 -8 21 0 28c7 8 20 8 28 0l207 -207l207 207c8 8 21 8 28 0c8 -7 8 -20 0 -28l-207 -207l207 -207c8 -8 8 -21 0 -28Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-D7" x="1223" y="0"></use>
<g transform="translate(2223,0)">
 <use xlink:href="#E1-LATINMODERNMAIN-31"></use>
 <use xlink:href="#E1-LATINMODERNMAIN-36" x="500" y="0"></use>
</g>
</g>
</svg>.

</p>
<p></p>
<span class="anchor" id="fragment-Computesampleboundsfortile-0"></span><div class="fragmentname">&lt;&lt;Compute sample bounds for tile&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">int x0 = sampleBounds.pMin.x + tile.x * tileSize;
int x1 = std::min(x0 + tileSize, sampleBounds.pMax.x);
int y0 = sampleBounds.pMin.y + tile.y * tileSize;
int y1 = std::min(y0 + tileSize, sampleBounds.pMax.y);
Bounds2i tileBounds(<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x0, y0), <a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a>(x1, y1));</div><p>


</p>
<p>Finally, a <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#FilmTile"><tt>FilmTile</tt></a> is acquired from the <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a>.  This class
provides a small buffer of memory to store pixel values for the current
tile.  Its storage is private to the loop iteration, so pixel values can be
updated without worrying about other threads concurrently modifying the
same pixels.  The tile is merged into the film&rsquo;s storage once the work for
rendering it is done; serializing concurrent updates to the image is
handled then.

</p>
<p></p>
<span class="anchor" id="fragment-GetmonoFilmTilefortile-0"></span><div class="fragmentname">&lt;&lt;Get <tt>FilmTile</tt> for tile&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">std::unique_ptr&lt;FilmTile&gt; filmTile =
    <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::GetFilmTile" class="code">GetFilmTile</a>(tileBounds);</div><p>


</p>
<p>Rendering can now proceed.  The implementation loops over all of the pixels
in the tile using a range-based <tt>for</tt> loop that automatically uses iterators
provided by the <a href="../Geometry_and_Transformations/Bounding_Boxes.html#Bounds2"><tt>Bounds2</tt></a> class.  The cloned <tt>Sampler</tt> is notified
that it should start generating samples for the current pixel, and samples
are processed in turn until <tt>StartNextSample()</tt> returns <tt>false</tt>.
(As we&rsquo;ll see in Chapter&nbsp;<a href="../Sampling_and_Reconstruction.html#chap:sampling-reconstruction">7</a>, taking multiple samples per pixel can greatly
improve final image quality.)

</p>
<p></p>
<span class="anchor" id="fragment-Loopoverpixelsintiletorenderthem-0"></span><div class="fragmentname">&lt;&lt;Loop over pixels in tile to render them&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (<a href="../Geometry_and_Transformations/Points.html#Point2i" class="code">Point2i</a> pixel : tileBounds) {
    tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartPixel" class="code">StartPixel</a>(pixel);
    do {
        &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializemonoCameraSampleforcurrentsample-0">Initialize <tt>CameraSample</tt> for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-58" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-58"><i></i></a><div id="fragbit-58" class="collapse"><div class="fragmentcode">           CameraSample cameraSample = tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::GetCameraSample" class="code">GetCameraSample</a>(pixel);</div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Generatecamerarayforcurrentsample-0">Generate camera ray for current sample</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-59" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-59"><i></i></a><div id="fragbit-59" class="collapse"><div class="fragmentcode">           RayDifferential ray;
           <a href="../Utilities/Main_Include_File.html#Float" class="code">Float</a> rayWeight = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::GenerateRayDifferential" class="code">GenerateRayDifferential</a>(cameraSample, &amp;ray);
           ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(1 / std::sqrt(tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::samplesPerPixel" class="code">samplesPerPixel</a>));
           </div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Evaluateradiancealongcameraray-0">Evaluate radiance along camera ray</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-60" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-60"><i></i></a><div id="fragbit-60" class="collapse"><div class="fragmentcode">           <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> L(0.f);
           if (rayWeight &gt; 0)
               L = <a href="#SamplerIntegrator::Li" class="code">Li</a>(ray, scene, *tileSampler, arena);
           &lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-61" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-61"><i></i></a><div id="fragbit-61" class="collapse"><div class="fragmentcode">              if (L.HasNaNs()) {
                  Error("Not-a-number radiance value returned "
                        "for image sample.  Setting to black.");
                  L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
              }
              else if (L.y() &lt; -1e-5) {
                  Error("Negative luminance value, %f, returned "
                        "for image sample.  Setting to black.", L.y());
                  L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
              }
              else if (std::isinf(L.y())) {
                  Error("Infinite luminance value returned "
                        "for image sample.  Setting to black.");
                  L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
              }</div></div></div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-Addcamerarayscontributiontoimage-0">Add camera ray&rsquo;s contribution to image</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-62" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-62"><i></i></a><div id="fragbit-62" class="collapse"><div class="fragmentcode">           filmTile-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#FilmTile::AddSample" class="code">AddSample</a>(cameraSample.<a href="../Camera_Models/Camera_Model.html#CameraSample::pFilm" class="code">pFilm</a>, L, rayWeight);</div></div>
        &lt;&lt;<span class="fragmentname"><a href="#fragment-FreeuseMemoryArenamemoryfromcomputingimagesamplevalue-0">Free <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> memory from computing image sample value</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-63" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-63"><i></i></a><div id="fragbit-63" class="collapse"><div class="fragmentcode">           arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Reset" class="code">Reset</a>();</div></div>
    } while (tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::StartNextSample" class="code">StartNextSample</a>());
}</div><p>


</p>
<p>The <a href="../Camera_Models/Camera_Model.html#CameraSample"><tt>CameraSample</tt></a> structure records the position on the film for which
the camera should generate the corresponding ray.  It also stores time and
lens position sample values, which are used when rendering scenes with moving
objects and for camera models that simulate non-pinhole apertures,
respectively.

</p>
<p></p>
<span class="anchor" id="fragment-InitializemonoCameraSampleforcurrentsample-0"></span><div class="fragmentname">&lt;&lt;Initialize <tt>CameraSample</tt> for current sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">CameraSample cameraSample = tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::GetCameraSample" class="code">GetCameraSample</a>(pixel);</div><p>


</p>
<p>The <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a> interface provides two methods to generate rays:
<a href="../Camera_Models/Camera_Model.html#Camera::GenerateRay"><tt>Camera::GenerateRay()</tt></a>, which returns the ray for a given image sample
position, and
<a href="../Camera_Models/Camera_Model.html#Camera::GenerateRayDifferential"><tt>Camera::GenerateRayDifferential()</tt></a>, which returns a
<em>ray differential</em>, which incorporates information about the rays that
the <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a> would generate for samples that are one pixel away on the
image plane in both the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 572.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">x</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D465" d="M527 376c0 -40 -32 -58 -54 -58c-27 0 -38 19 -38 35c0 24 20 49 48 54c-21 13 -45 13 -50 13c-70 0 -93 -92 -99 -118l-34 -137c-11 -44 -17 -66 -17 -88c0 -34 16 -66 55 -66c32 0 100 24 133 131c2 7 4 11 13 11c3 0 12 0 12 -10c0 -25 -57 -154 -160 -154 c-60 0 -96 39 -108 76c-3 -6 -39 -76 -105 -76c-44 0 -94 20 -94 66c0 32 25 58 55 58c15 0 37 -8 37 -35c0 -28 -22 -49 -47 -54c21 -13 44 -13 50 -13c44 0 79 42 95 104c37 140 54 207 54 238c0 58 -35 67 -54 67c-34 0 -100 -25 -134 -131c-2 -9 -5 -11 -13 -11 c0 0 -12 0 -12 10c0 25 57 154 161 154c29 0 83 -10 108 -76c12 23 47 76 105 76c34 0 93 -14 93 -66Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D465" x="0" y="0"></use>
</g>
</svg> and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.139ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 490.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">y</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D466" d="M490 404c0 -7 0 -9 -4 -23l-96 -382c-28 -113 -131 -204 -234 -204c-62 0 -106 37 -106 87c0 49 33 65 56 65c10 0 37 -4 37 -35c0 -19 -10 -32 -20 -41c-14 -12 -27 -12 -43 -12c17 -39 62 -42 76 -42c46 0 84 29 110 63c40 53 52 102 65 154c-28 -28 -62 -45 -101 -45 c-59 0 -122 30 -122 119c0 47 18 104 58 210c7 19 17 45 17 70c0 32 -17 32 -25 32c-34 0 -74 -30 -101 -124c-5 -16 -6 -18 -16 -18c0 0 -12 0 -12 10c0 9 37 154 132 154c50 0 82 -37 82 -82c0 -20 -4 -31 -20 -72c-34 -88 -51 -150 -51 -196c0 -37 11 -81 62 -81 c66 0 109 70 113 85l45 180l20 80c4 18 12 49 14 54c9 15 25 21 35 21c15 0 29 -9 29 -27Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D466" x="0" y="0"></use>
</g>
</svg> directions.  Ray differentials are used
to get better results from some of the texture functions defined in
Chapter&nbsp;<a href="../Texture.html#chap:texture">10</a>, making it possible to compute how quickly a
texture varies with respect to the pixel spacing, a key component of
texture antialiasing.

</p>
<p>After the ray differential has been returned, the
<tt>ScaleDifferentials()</tt> method scales the differential rays to account
for the actual spacing between samples on the film plane for the case where
multiple samples are taken per pixel.

</p>
<p>The camera also returns a floating-point weight associated with the ray.
For simple camera models, each ray is weighted equally, but 
camera models that more accurately model the process of image formation by
lens systems may generate some rays that contribute more than others.  Such
a camera model might simulate the effect of less light arriving at the
edges of the film plane than at the center, an effect called
<em>vignetting</em>.  The returned weight will be used later to scale the
ray&rsquo;s contribution to the image.

</p>
<p></p>
<span class="anchor" id="fragment-Generatecamerarayforcurrentsample-0"></span><div class="fragmentname">&lt;&lt;Generate camera ray for current sample&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">RayDifferential ray;
<a href="../Utilities/Main_Include_File.html#Float" class="code">Float</a> rayWeight = <a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::GenerateRayDifferential" class="code">GenerateRayDifferential</a>(cameraSample, &amp;ray);
ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ScaleDifferentials" class="code">ScaleDifferentials</a>(1 / std::sqrt(tileSampler-&gt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::samplesPerPixel" class="code">samplesPerPixel</a>));
</div><p>


</p>
<p>Note the capitalized floating-point type <a href="../Utilities/Main_Include_File.html#Float"><tt>Float</tt></a>: depending on the
compilation flags of <tt>pbrt</tt>, this is an alias for either <tt>float</tt> or
<tt>double</tt>. More detail on this design choice is provided in
Section&nbsp;<a href="../Utilities/Main_Include_File.html#sec:main-include">A.1</a>.

</p>
<p>Given a ray, the next task is to determine the radiance arriving at the
image plane along that ray.  The <tt>Li()</tt> method takes care of this
task.

</p>
<p></p>
<span class="anchor" id="fragment-Evaluateradiancealongcameraray-0"></span><div class="fragmentname">&lt;&lt;Evaluate radiance along camera ray&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> L(0.f);
if (rayWeight &gt; 0)
    L = <a href="#SamplerIntegrator::Li" class="code">Li</a>(ray, scene, *tileSampler, arena);
&lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-64" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-64"><i></i></a><div id="fragbit-64" class="collapse"><div class="fragmentcode">   if (L.HasNaNs()) {
       Error("Not-a-number radiance value returned "
             "for image sample.  Setting to black.");
       L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
   }
   else if (L.y() &lt; -1e-5) {
       Error("Negative luminance value, %f, returned "
             "for image sample.  Setting to black.", L.y());
       L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
   }
   else if (std::isinf(L.y())) {
       Error("Infinite luminance value returned "
             "for image sample.  Setting to black.");
       L = <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);
   }</div></div></div><p>


</p>
<p><tt>Li()</tt> is a pure virtual method that returns the incident
radiance at the origin of a given ray; each subclass of
<a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a> must provide an implementation of this method.
The parameters to <tt>Li()</tt> are the following:
</p>
<ul>
<li> <tt>ray</tt>: the ray along which the incident radiance should be
evaluated.

<li> <tt>scene</tt>: the <a href="#Scene"><tt>Scene</tt></a> being rendered.  The
implementation will query the scene for information about the lights and
geometry, and so on.

<li> <tt>sampler</tt>: a sample generator used to solve the light transport
equation via Monte Carlo integration.

<li> <tt>arena</tt>: a <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> for efficient temporary memory
  allocation by the integrator.  The integrator should assume that any
  memory it allocates with the arena will be freed shortly after the 
  <tt>Li()</tt> method returns and thus should not use the arena to
  allocate any memory that must persist for longer than is needed for 
  the current ray.

<li> <tt>depth</tt>: the number of ray bounces from the camera that have
occurred up until the current call to <tt>Li()</tt>.
</ul><p>

The method returns a <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum"><tt>Spectrum</tt></a> that represents the incident radiance
at the origin of the ray:

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorPublicMethods-2"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Public Methods&gt;&gt;+=&nbsp;<a href="#fragment-SamplerIntegratorPublicMethods-1"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode">virtual <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> <span class="anchor" id="SamplerIntegrator::Li"></span>Li(const RayDifferential &amp;ray, const <a href="#Scene" class="code">Scene</a> &amp;scene,
    <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, int depth = 0) const = 0;</div><p>


</p>
<p>
A common side effect of bugs in the rendering process is that impossible
radiance values are computed.  For example, division by zero results in
radiance values equal either to the IEEE floating-point infinity or &ldquo;not a
number&rdquo; value.  The renderer looks for this possibility, as well as for
spectra with negative contributions, and prints an error message when it
encounters them.  Here we won&rsquo;t include the fragment that does this,
&lt;&lt;<span class="fragmentname">Issue warning if unexpected radiance value is returned</span>&gt;&gt;.  See the
implementation in <a href="https://github.com/mmp/pbrt-v3/tree/master/src/core/integrator.cpp"><tt>core/integrator.cpp</tt></a> if you&rsquo;re interested in its
details.

</p>
<p>

</p>
<p>After the radiance arriving at the ray&rsquo;s origin is known, the image can be
updated: the <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#FilmTile::AddSample"><tt>FilmTile::AddSample()</tt></a> method updates the pixels in the
tile&rsquo;s image given the results from a sample.  The details of how sample
values are recorded in the film
are explained in Sections&nbsp;<a href="../Sampling_and_Reconstruction/Image_Reconstruction.html#sec:image-reconstruction">7.8</a>
and&nbsp;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#sec:image-pipeline">7.9</a>.

</p>
<p></p>
<span class="anchor" id="fragment-Addcamerarayscontributiontoimage-0"></span><div class="fragmentname">&lt;&lt;Add camera ray&rsquo;s contribution to image&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">filmTile-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#FilmTile::AddSample" class="code">AddSample</a>(cameraSample.<a href="../Camera_Models/Camera_Model.html#CameraSample::pFilm" class="code">pFilm</a>, L, rayWeight);</div><p>


</p>
<p>After processing a sample, all of the allocated memory in the
<a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> is freed together when <a href="../Utilities/Memory_Management.html#MemoryArena::Reset"><tt>MemoryArena::Reset()</tt></a> is
called.  (See Section&nbsp;<a href="../Materials/BSDFs.html#sec:bsdf-memory-management">9.1.1</a> for an explanation
of how the <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> is used to allocate memory to represent BSDFs
at intersection points.)

</p>
<p></p>
<span class="anchor" id="fragment-FreeuseMemoryArenamemoryfromcomputingimagesamplevalue-0"></span><div class="fragmentname">&lt;&lt;Free <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> memory from computing image sample value&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">arena.<a href="../Utilities/Memory_Management.html#MemoryArena::Reset" class="code">Reset</a>();</div><p>


</p>
<p>Once radiance values for all of the samples in a tile have been computed,
the <tt>FilmTile</tt> is handed off to the <tt>Film</tt>&rsquo;s
<tt>MergeFilmTile()</tt> method, which handles adding the tile&rsquo;s pixel
contributions to the final image.  Note that the <tt>std::move()</tt>
function is used to transfer ownership of the <tt>unique_ptr</tt>
to <tt>MergeFilmTile()</tt>.
 
</p>
<span class="anchor" id="fragment-MergeimagetileintomonoFilm-0"></span><div class="fragmentname">&lt;&lt;Merge image tile into <tt>Film</tt>&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::MergeFilmTile" class="code">MergeFilmTile</a>(std::move(filmTile));
</div><p>


</p>
<p>After all of the loop iterations have finished, the
<a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a>&rsquo;s <tt>Render()</tt> method calls the <a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film"><tt>Film</tt></a>&rsquo;s
<a href="../Utilities/Image_File_Input_and_Output.html#WriteImage"><tt>WriteImage()</tt></a> method to write the image out to a file.

</p>
<p></p>
<span class="anchor" id="fragment-Savefinalimageafterrendering-0"></span><div class="fragmentname">&lt;&lt;Save final image after rendering&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="#SamplerIntegrator::camera" class="code">camera</a>-&gt;<a href="../Camera_Models/Camera_Model.html#Camera::film" class="code">film</a>-&gt;<a href="../Sampling_and_Reconstruction/Film_and_the_Imaging_Pipeline.html#Film::WriteImage" class="code">WriteImage</a>();</div><p>


</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

<div class="row">
<div class="col-md-1 col-lg-2 leftcolumn">
<a href="#AnIntegratorforWhittedRayTracing"><i class="fas fa-link h3h4marginlink"></i></a>
</div>
<div class="col-md-10 col-lg-8">
<span class="anchor" id="sec:whitted-integrator"></span><span id="AnIntegratorforWhittedRayTracing"></span><h3>1.3.5  An Integrator for Whitted Ray Tracing</h3><p>



</p>
<p> Chapters&nbsp;<a href="../Light_Transport_I_Surface_Reflection.html#chap:light-transport">14</a>
and&nbsp;<a href="../Light_Transport_II_Volume_Rendering.html#chap:volume-integration">15</a> include the implementations of many
different integrators, based on a variety of algorithms with differing
levels of accuracy.  Here we will present an integrator based on Whitted&rsquo;s
ray-tracing algorithm.  This integrator accurately computes reflected and
transmitted light from specular surfaces like glass, mirrors, and water,
although it doesn&rsquo;t account for other types of indirect lighting effects
like light bouncing off a wall and illuminating a room.  The
<a href="#WhittedIntegrator"><tt>WhittedIntegrator</tt></a> class can be found in the
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/integrators/whitted.h"><tt>integrators/whitted.h</tt></a><span class="anchor" id="integratorswhitted.h"></span> and
<a href="https://github.com/mmp/pbrt-v3/tree/master/src/integrators/whitted.cpp"><tt>integrators/whitted.cpp</tt></a><span class="anchor" id="integratorswhitted.cpp"></span> files in
the <tt>pbrt</tt> distribution.

</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-WhittedIntegratorDeclarations-0"></span><div class="fragmentname">&lt;&lt;WhittedIntegrator Declarations&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">class <span class="anchor" id="WhittedIntegrator"></span>WhittedIntegrator : public <a href="#SamplerIntegrator" class="code">SamplerIntegrator</a> {
public:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-WhittedIntegratorPublicMethods-0">WhittedIntegrator Public Methods</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-65" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-65"><i></i></a><div id="fragbit-65" class="collapse"><div class="fragmentcode">       WhittedIntegrator(int <a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>, std::shared_ptr&lt;const <a href="../Camera_Models/Camera_Model.html#Camera" class="code">Camera</a>&gt; camera,
               std::shared_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; sampler)
           : <a href="#SamplerIntegrator" class="code">SamplerIntegrator</a>(camera, sampler), <a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>(<a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>) { }
       <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> Li(const RayDifferential &amp;ray, const <a href="#Scene" class="code">Scene</a> &amp;scene,
           <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, int depth) const;</div></div>
private:
    &lt;&lt;<span class="fragmentname"><a href="#fragment-WhittedIntegratorPrivateData-0">WhittedIntegrator Private Data</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-66" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-66"><i></i></a><div id="fragbit-66" class="collapse"><div class="fragmentcode">       const int maxDepth;</div></div>
};</div><p>


</p>
<p></p>
<span class="anchor" id="fragment-WhittedIntegratorPublicMethods-0"></span><div class="fragmentname">&lt;&lt;WhittedIntegrator Public Methods&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">WhittedIntegrator(int <a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>, std::shared_ptr&lt;const <a href="../Camera_Models/Camera_Model.html#Camera" class="code">Camera</a>&gt; camera,
        std::shared_ptr&lt;<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a>&gt; sampler)
    : <a href="#SamplerIntegrator" class="code">SamplerIntegrator</a>(camera, sampler), <a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>(<a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>) { }</div><p>


</p>
<p>The Whitted integrator works by recursively evaluating radiance along
reflected and refracted ray directions.  It stops the recursion at a
predetermined maximum depth, <a href="#WhittedIntegrator::maxDepth"><tt>WhittedIntegrator::maxDepth</tt></a>.  By
default, the maximum recursion depth is five.  Without this termination
criterion, the recursion might never terminate (imagine, e.g., a
hall-of-mirrors scene). This member variable is initialized in the
<a href="#WhittedIntegrator"><tt>WhittedIntegrator</tt></a> constructor based on
parameters set in the scene description file.

</p>
<p></p>
<span class="anchor" id="fragment-WhittedIntegratorPrivateData-0"></span><div class="fragmentname">&lt;&lt;WhittedIntegrator Private Data&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">const int <span class="anchor" id="WhittedIntegrator::maxDepth"></span>maxDepth;</div><p>


</p>
<p>As a <tt>SamplerIntegrator</tt> implementation, the <tt>WhittedIntegrator</tt>
must provide an implementation of the <tt>Li()</tt> method, which returns the
radiance arriving at the origin of the given ray.
Figure&nbsp;<a href="#fig:integration-classes">1.19</a> summarizes the data flow among the
main classes used during integration at surfaces.

</p>
<p> </p>
<span class="anchor" id="fig:integration-classes"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Surface%20Integration%20Class%20Relationships.svg" title=""><img src="Surface%20Integration%20Class%20Relationships.svg" width=791 height=257 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 1.19: Class Relationships for Surface Integration. <span class="legend"> The main
rendering loop in the <a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a> computes a camera ray and passes
it to the <tt>Li()</tt> method, which returns the radiance
along that ray arriving at the ray&rsquo;s origin.
After finding the closest intersection, it computes the material properties
at the intersection point, representing them in the form of a BSDF. It then
uses the Lights in the Scene to determine the illumination there.
Together, these give the information needed to compute the radiance
reflected back along the ray at the intersection point.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-WhittedIntegratorMethodDefinitions-0"></span><div class="fragmentname">&lt;&lt;WhittedIntegrator Method Definitions&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> WhittedIntegrator::<span class="anchor" id="WhittedIntegrator::Li"></span>Li(const RayDifferential &amp;ray,
        const <a href="#Scene" class="code">Scene</a> &amp;scene, <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena,
        int depth) const {
    <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> L(0.);
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Findclosestrayintersectionorreturnbackgroundradiance-0">Find closest ray intersection or return background radiance</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-67" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-67"><i></i></a><div id="fragbit-67" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> isect;
       if (!scene.<a href="#Scene::Intersect" class="code">Intersect</a>(ray, &amp;isect)) {
           for (const auto &amp;light : scene.<a href="#Scene::lights" class="code">lights</a>)
               L += light-&gt;<a href="../Light_Sources/Infinite_Area_Lights.html#Light::Le" class="code">Le</a>(ray);
           return L;
       }</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeemittedandreflectedlightatrayintersectionpoint-0">Compute emitted and reflected light at ray intersection point</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-68" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-68"><i></i></a><div id="fragbit-68" class="collapse"><div class="fragmentcode">       &lt;&lt;<span class="fragmentname"><a href="#fragment-InitializecommonvariablesforWhittedintegrator-0">Initialize common variables for Whitted integrator</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-69" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-69"><i></i></a><div id="fragbit-69" class="collapse"><div class="fragmentcode">          <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>;
          <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>;</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Computescatteringfunctionsforsurfaceinteraction-0">Compute scattering functions for surface interaction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-70" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-70"><i></i></a><div id="fragbit-70" class="collapse"><div class="fragmentcode">          isect.<a href="../Materials/Material_Interface_and_Implementations.html#SurfaceInteraction::ComputeScatteringFunctions" class="code">ComputeScatteringFunctions</a>(ray, arena);
          </div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Computeemittedlightifrayhitanarealightsource-0">Compute emitted light if ray hit an area light source</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-71" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-71"><i></i></a><div id="fragbit-71" class="collapse"><div class="fragmentcode">          L += isect.<a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a>(wo);</div></div>
       &lt;&lt;<span class="fragmentname"><a href="#fragment-Addcontributionofeachlightsource-0">Add contribution of each light source</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-72" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-72"><i></i></a><div id="fragbit-72" class="collapse"><div class="fragmentcode">          for (const auto &amp;light : scene.<a href="#Scene::lights" class="code">lights</a>) {
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi;
              Float pdf;
              <a href="../Light_Sources/Light_Interface.html#VisibilityTester" class="code">VisibilityTester</a> visibility;
              <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> Li = light-&gt;<a href="../Light_Sources/Light_Interface.html#Light::Sample_Li" class="code">Sample_Li</a>(isect, sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>(), &amp;wi,
                                             &amp;pdf, &amp;visibility);
              if (Li.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() || pdf == 0) continue;
              <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> <a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a> = isect.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#SurfaceInteraction::bsdf" class="code">bsdf</a>-&gt;<a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a>(wo, wi);
              if (!<a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a>.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() &amp;&amp; visibility.<a href="../Light_Sources/Light_Interface.html#VisibilityTester::Unoccluded" class="code">Unoccluded</a>(scene))
                  L += <a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a> * Li * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, n) / pdf;
          }</div></div>
       if (depth + 1 &lt; <a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>) {
           &lt;&lt;<span class="fragmentname"><a href="#fragment-Traceraysforspecularreflectionandrefraction-0">Trace rays for specular reflection and refraction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-73" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-73"><i></i></a><div id="fragbit-73" class="collapse"><div class="fragmentcode">              L += <a href="#SamplerIntegrator::SpecularReflect" class="code">SpecularReflect</a>(ray, isect, scene, sampler, arena, depth);
              L += <a href="#SamplerIntegrator::SpecularTransmit" class="code">SpecularTransmit</a>(ray, isect, scene, sampler, arena, depth);</div></div>
       }</div></div>
    return L;
}</div><p>


</p>
<p>The first step is to find the first intersection of the ray with the
shapes in the scene. The <a href="#Scene::Intersect"><tt>Scene::Intersect()</tt></a> method takes a ray and
returns a Boolean value indicating whether it intersected a shape.  For
rays where an intersection was found, it initializes the provided
<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction"><tt>SurfaceInteraction</tt></a> with geometric information about the intersection.

</p>
<p>If no intersection was found, radiance may be carried along the ray due to light
sources that don&rsquo;t have associated geometry.  One example of such a light
is the <a href="../Light_Sources/Infinite_Area_Lights.html#InfiniteAreaLight"><tt>InfiniteAreaLight</tt></a>, which can represent illumination from the
sky.  The <a href="../Light_Sources/Infinite_Area_Lights.html#Light::Le"><tt>Light::Le()</tt></a> method allows such lights to return their
radiance along a given ray. 

</p>
<p></p>
<span class="anchor" id="fragment-Findclosestrayintersectionorreturnbackgroundradiance-0"></span><div class="fragmentname">&lt;&lt;Find closest ray intersection or return background radiance&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> isect;
if (!scene.<a href="#Scene::Intersect" class="code">Intersect</a>(ray, &amp;isect)) {
    for (const auto &amp;light : scene.<a href="#Scene::lights" class="code">lights</a>)
        L += light-&gt;<a href="../Light_Sources/Infinite_Area_Lights.html#Light::Le" class="code">Le</a>(ray);
    return L;
}</div><p>


</p>
<p>Otherwise a valid intersection has been found.  The integrator must
determine how light is scattered by the surface of the shape at the
intersection point, determine how much illumination is arriving from light
sources at the point, and apply an approximation to
Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>) to compute how much light is leaving
the surface in the viewing direction.  Because this integrator ignores the
effect of participating media like smoke or fog, the radiance leaving the
intersection point is the same as the radiance arriving at the ray&rsquo;s
origin.
 
</p>
<span class="anchor" id="fragment-Computeemittedandreflectedlightatrayintersectionpoint-0"></span><div class="fragmentname">&lt;&lt;Compute emitted and reflected light at ray intersection point&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">&lt;&lt;<span class="fragmentname"><a href="#fragment-InitializecommonvariablesforWhittedintegrator-0">Initialize common variables for Whitted integrator</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-74" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-74"><i></i></a><div id="fragbit-74" class="collapse"><div class="fragmentcode">   <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>;
   <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>;</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computescatteringfunctionsforsurfaceinteraction-0">Compute scattering functions for surface interaction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-75" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-75"><i></i></a><div id="fragbit-75" class="collapse"><div class="fragmentcode">   isect.<a href="../Materials/Material_Interface_and_Implementations.html#SurfaceInteraction::ComputeScatteringFunctions" class="code">ComputeScatteringFunctions</a>(ray, arena);
   </div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Computeemittedlightifrayhitanarealightsource-0">Compute emitted light if ray hit an area light source</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-76" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-76"><i></i></a><div id="fragbit-76" class="collapse"><div class="fragmentcode">   L += isect.<a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a>(wo);</div></div>
&lt;&lt;<span class="fragmentname"><a href="#fragment-Addcontributionofeachlightsource-0">Add contribution of each light source</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-77" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-77"><i></i></a><div id="fragbit-77" class="collapse"><div class="fragmentcode">   for (const auto &amp;light : scene.<a href="#Scene::lights" class="code">lights</a>) {
       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi;
       Float pdf;
       <a href="../Light_Sources/Light_Interface.html#VisibilityTester" class="code">VisibilityTester</a> visibility;
       <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> Li = light-&gt;<a href="../Light_Sources/Light_Interface.html#Light::Sample_Li" class="code">Sample_Li</a>(isect, sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>(), &amp;wi,
                                      &amp;pdf, &amp;visibility);
       if (Li.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() || pdf == 0) continue;
       <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> <a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a> = isect.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#SurfaceInteraction::bsdf" class="code">bsdf</a>-&gt;<a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a>(wo, wi);
       if (!<a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a>.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() &amp;&amp; visibility.<a href="../Light_Sources/Light_Interface.html#VisibilityTester::Unoccluded" class="code">Unoccluded</a>(scene))
           L += <a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a> * Li * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, n) / pdf;
   }</div></div>
if (depth + 1 &lt; <a href="#WhittedIntegrator::maxDepth" class="code">maxDepth</a>) {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Traceraysforspecularreflectionandrefraction-0">Trace rays for specular reflection and refraction</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-78" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-78"><i></i></a><div id="fragbit-78" class="collapse"><div class="fragmentcode">       L += <a href="#SamplerIntegrator::SpecularReflect" class="code">SpecularReflect</a>(ray, isect, scene, sampler, arena, depth);
       L += <a href="#SamplerIntegrator::SpecularTransmit" class="code">SpecularTransmit</a>(ray, isect, scene, sampler, arena, depth);</div></div>
}</div><p>


</p>
<p>Figure&nbsp;<a href="#fig:whitted-setting">1.20</a> shows a few quantities that will be used
frequently in the fragments to come. <tt>n</tt> is the surface normal at the
intersection point and the normalized direction from the hit point back to
the ray origin is stored in <tt>wo</tt>; <a href="../Camera_Models/Camera_Model.html#Camera"><tt>Camera</tt></a>s are
responsible for normalizing the direction component of generated rays,
so there&rsquo;s no need to renormalize it here.  Normalized directions are denoted
by the <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.446ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 622.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
</g>
</svg> symbol in this book, and in <tt>pbrt</tt>&rsquo;s code we will use 
<tt>wo</tt> to represent <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.5ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1076.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal o</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
</svg>, the outgoing direction of scattered light.

</p>
<p></p>
<span class="anchor" id="fig:whitted-setting"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Whitted%20integration%20setting.svg" title=""><img src="Whitted%20integration%20setting.svg" width=466 height=298 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 1.20: Geometric Setting for the Whitted
Integrator. <span class="legend"> <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.293ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 556.5 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">normal p Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-70" d="M521 216c0 -129 -104 -227 -223 -227c-76 0 -118 54 -123 70v-9v-168c0 -45 11 -45 78 -45v-31l-113 3l-112 -3v31c67 0 78 0 78 45v468c0 44 -7 50 -78 50v31l144 11v-66c20 22 62 66 140 66c112 0 209 -99 209 -226zM438 216c0 113 -61 201 -134 201 c-51 0 -100 -29 -129 -80v-223c0 -20 0 -21 14 -42c27 -41 65 -61 105 -61c74 0 144 84 144 205Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-70" x="0" y="0"></use>
</g>
</svg> is the ray intersection
point and <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.485ex" height="1.676ex" style="vertical-align: -0.338ex;" viewBox="0 -576.1 639.5 721.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">bold n Subscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D427" d="M615 0l-126 3l-126 -3v47h69v270c0 76 -21 97 -55 97c-63 0 -149 -49 -149 -158v-209h69v-47l-126 3l-126 -3v47h69v309c0 39 -7 39 -69 39v47l172 8v-108c26 51 79 108 175 108c100 0 154 -39 154 -144v-259h69v-47Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D427" x="0" y="0"></use>
</g>
</svg> is its surface normal. The direction in which we&rsquo;d like
to compute reflected radiance is
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.5ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1076.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal o</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
</svg>; it is the vector pointing in the opposite direction of the incident
ray.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-InitializecommonvariablesforWhittedintegrator-0"></span><div class="fragmentname">&lt;&lt;Initialize common variables for Whitted integrator&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>;
<a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>;</div><p>


</p>
<p>If an intersection was found, it&rsquo;s necessary to determine how the surface&rsquo;s
material scatters light.  The <tt>ComputeScatteringFunctions()</tt> method
handles this task, evaluating texture functions to determine surface
properties and then initializing a representation of the BSDF (and possibly
BSSRDF) at the point.  This method generally needs to allocate memory for
the objects that constitute this representation; because this memory only
needs to be available for the current ray, the <a href="../Utilities/Memory_Management.html#MemoryArena"><tt>MemoryArena</tt></a> is
provided for it to use for its allocations.

</p>
<p></p>
<span class="anchor" id="fragment-Computescatteringfunctionsforsurfaceinteraction-0"></span><div class="fragmentname">&lt;&lt;Compute scattering functions for surface interaction&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">isect.<a href="../Materials/Material_Interface_and_Implementations.html#SurfaceInteraction::ComputeScatteringFunctions" class="code">ComputeScatteringFunctions</a>(ray, arena);
</div><p>


</p>
<p>In case the ray happened to hit geometry that is emissive (such as an area
light source), the integrator accounts for any emitted radiance by calling the
<a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le"><tt>SurfaceInteraction::Le()</tt></a> method.  This gives the first term of the light
transport equation, Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>).  If
the object is not emissive, this method returns a black spectrum.

</p>
<p></p>
<span class="anchor" id="fragment-Computeemittedlightifrayhitanarealightsource-0"></span><div class="fragmentname">&lt;&lt;Compute emitted light if ray hit an area light source&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">L += isect.<a href="../Light_Sources/Area_Lights.html#SurfaceInteraction::Le" class="code">Le</a>(wo);</div><p>


</p>
<p>For each light, the integrator calls the <a href="../Light_Sources/Light_Interface.html#Light::Sample_Li"><tt>Light::Sample_Li()</tt></a> method to
compute the radiance from that light falling on the surface at the point
being shaded.  This method also returns the direction vector from the point
being shaded to the light source, which is stored in the variable <tt>wi</tt>
(denoting an incident direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.135ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 919.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
</svg>).<button style="button" data-toggle="tooltip" data-placement="right" data-html="true" class="btn footnote-button" title="When considering
light scattering at a surface location, <tt>pbrt</tt> uses the
convention that &omega;<sub>i</sub> always refers to the direction from which the quantity of
interest (radiance in this case) arrives, rather than the direction from which
the <tt>Integrator</tt> reached the surface.">
      <sup>&dagger;</sup>
    </button>
		

</p>
<p>The spectrum returned by this method does not account for the possibility
that some other shape may block light from the light and prevent it from
reaching the point being shaded.  Instead, it returns a
<a href="../Light_Sources/Light_Interface.html#VisibilityTester"><tt>VisibilityTester</tt></a> object that can be used to determine if any
primitives block the surface point from the light source.  This test is
done by tracing a shadow ray between the point being shaded and the light
to verify that the path is clear.  <tt>pbrt</tt>&rsquo;s code is organized in this way so
that it can avoid tracing the shadow ray unless necessary:
this way it can first make sure that the light falling on the surface
<em>would</em> be scattered in the direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.5ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1076.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal o</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
</svg> if the light isn&rsquo;t
blocked.  For example, if the surface is not transmissive, then light
arriving at the back side of the surface doesn&rsquo;t contribute to reflection.

</p>
<p>The <tt>Sample_Li()</tt> method also returns the probability density for the
light to have sampled the direction <tt>wi</tt> in the <tt>pdf</tt> variable.
This value is used for Monte Carlo integration with complex area light
sources where light is arriving at the point from many directions even
though just one direction is sampled here; for simple lights like point
lights, the value of <tt>pdf</tt> is one.  The details of how this
probability density is computed and used in rendering is the topic of
Chapters&nbsp;<a href="../Monte_Carlo_Integration.html#chap:mc">13</a> and&nbsp;<a href="../Light_Transport_I_Surface_Reflection.html#chap:light-transport">14</a>; in the end, the light&rsquo;s contribution must be divided by
<tt>pdf</tt>, so this is done by the implementation here.

</p>
<p>If the arriving radiance is nonzero and the BSDF indicates that some of the
incident light from the direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.135ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 919.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
</svg> is in fact scattered to the
outgoing direction <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.5ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 1076.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal o</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
</svg>, then the integrator multiplies the radiance value
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.272ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 978.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper L Subscript normal i Superscript</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D43F" d="M643 247c0 0 0 -3 -4 -14l-79 -216c-6 -17 -7 -17 -31 -17h-463c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 12 20 19 20l133 -3l148 3c5 0 16 0 16 -12 c0 -19 -8 -19 -38 -19c-94 0 -97 -11 -106 -47l-135 -540c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h94c173 0 217 114 251 206c7 16 8 21 17 21s12 -7 12 -11Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="963" y="-213"></use>
</g>
</svg> by the value of the BSDF <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.283ex" height="2.509ex" style="vertical-align: -0.671ex;" viewBox="0 -791.3 552.5 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">f</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D453" d="M552 636c0 -38 -29 -60 -55 -60c-19 0 -37 12 -37 35c0 15 10 50 54 54c-19 18 -45 18 -49 18c-21 0 -38 -15 -47 -34c-6 -12 -20 -83 -24 -104c-11 -58 -10 -56 -21 -114h83c17 0 27 0 27 -11c0 -20 -10 -20 -30 -20h-86l-60 -317c-1 -7 -24 -128 -56 -191 c-18 -38 -58 -97 -113 -97c-41 0 -85 24 -85 69c0 38 29 60 55 60c19 0 37 -12 37 -35c0 -15 -9 -51 -55 -54c19 -18 44 -18 48 -18c52 0 69 91 87 188l75 395h-66c-19 0 -28 0 -28 12c0 19 11 19 30 19h69c24 126 27 136 33 157c30 99 93 117 127 117c41 0 87 -23 87 -69Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D453" x="0" y="0"></use>
</g>
</svg> and the cosine term.
The cosine term is computed using the <a href="../Geometry_and_Transformations/Vectors.html#AbsDot"><tt>AbsDot()</tt></a> function,
which returns the absolute value of the dot product between two vectors.
If the vectors are normalized, as both <tt>wi</tt> and <tt>n</tt> are here,
this is equal to the absolute value of the cosine of the angle between them
(Section&nbsp;<a href="../Geometry_and_Transformations/Vectors.html#sec:dot-cross-product">2.2.1</a>).

</p>
<p>This product represents the light&rsquo;s contribution to the light transport
equation integral, Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>), and it is added
to the total reflected radiance <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.176ex" style="vertical-align: -0.338ex;" viewBox="0 -791.3 681.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">upper L</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D43F" d="M643 247c0 0 0 -3 -4 -14l-79 -216c-6 -17 -7 -17 -31 -17h-463c-18 0 -27 0 -27 11c0 20 10 20 27 20c79 0 81 8 91 47l134 537c3 12 4 15 4 19c0 13 -9 14 -27 16c-17 2 -38 2 -38 2c-19 0 -28 0 -28 11c0 20 12 20 19 20l133 -3l148 3c5 0 16 0 16 -12 c0 -19 -8 -19 -38 -19c-94 0 -97 -11 -106 -47l-135 -540c-5 -18 -5 -20 -5 -23c0 -8 3 -9 13 -10c6 -1 8 -1 22 -1h94c173 0 217 114 251 206c7 16 8 21 17 21s12 -7 12 -11Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D43F" x="0" y="0"></use>
</g>
</svg>.  After all lights have been
considered, the integrator has computed the total contribution of
<em>direct lighting</em>&mdash;light that arrives at the surface directly from
emissive objects (as opposed to light that has reflected off other objects
in the scene before arriving at the point).

</p>
<p></p>
<span class="anchor" id="fragment-Addcontributionofeachlightsource-0"></span><div class="fragmentname">&lt;&lt;Add contribution of each light source&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">for (const auto &amp;light : scene.<a href="#Scene::lights" class="code">lights</a>) {
    <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> wi;
    Float pdf;
    <a href="../Light_Sources/Light_Interface.html#VisibilityTester" class="code">VisibilityTester</a> visibility;
    <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> Li = light-&gt;<a href="../Light_Sources/Light_Interface.html#Light::Sample_Li" class="code">Sample_Li</a>(isect, sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>(), &amp;wi,
                                   &amp;pdf, &amp;visibility);
    if (Li.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() || pdf == 0) continue;
    <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> <a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a> = isect.<a href="../Primitives_and_Intersection_Acceleration/Primitive_Interface_and_Geometric_Primitives.html#SurfaceInteraction::bsdf" class="code">bsdf</a>-&gt;<a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a>(wo, wi);
    if (!<a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a>.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() &amp;&amp; visibility.<a href="../Light_Sources/Light_Interface.html#VisibilityTester::Unoccluded" class="code">Unoccluded</a>(scene))
        L += <a href="../Materials/BSDFs.html#BSDF::f" class="code">f</a> * Li * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, n) / pdf;
}</div><p>


</p>
<p>This integrator also handles light scattered by perfectly specular surfaces
like mirrors or glass.  It is fairly simple to use properties of mirrors to
find the reflected directions (Figure&nbsp;<a href="#fig:law-of-reflection">1.21</a>) and to
use Snell&rsquo;s law to find the transmitted directions
(Section&nbsp;<a href="../Reflection_Models/Specular_Reflection_and_Transmission.html#sec:specular-reflect-transmit">8.2</a>).  The integrator can then
recursively follow the appropriate ray in the new direction and add its
contribution to the reflected radiance at the point originally seen from
the camera.  The computation of the effect of specular reflection and
transmission is handled in separate utility methods so these functions can
easily be reused by other <a href="#SamplerIntegrator"><tt>SamplerIntegrator</tt></a> implementations.

</p>
<p></p>
<span class="anchor" id="fig:law-of-reflection"></span><div class="card outerfigure"><div class="card-body figure"><p>



</p>
<div class="figure-row">
  <a href="Perfect%20specular%20reflection.svg" title=""><img src="Perfect%20specular%20reflection.svg" width=466 height=298 style="max-width: 100%;"></a>
</div>
<p>


</p>
<figcaption class="caption">Figure 1.21: <span class="legend"> Reflected rays due to perfect specular reflection make the same angle
with the surface normal as the incident ray.</span>
</figcaption><p>


</p>
</div></div><p>


</p>
<p></p>
<span class="anchor" id="fragment-Traceraysforspecularreflectionandrefraction-0"></span><div class="fragmentname">&lt;&lt;Trace rays for specular reflection and refraction&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">L += <a href="#SamplerIntegrator::SpecularReflect" class="code">SpecularReflect</a>(ray, isect, scene, sampler, arena, depth);
L += <a href="#SamplerIntegrator::SpecularTransmit" class="code">SpecularTransmit</a>(ray, isect, scene, sampler, arena, depth);</div><p>


</p>
<p>

</p>
<p></p>
<span class="anchor" id="fragment-SamplerIntegratorMethodDefinitions-1"></span><div class="fragmentname">&lt;&lt;SamplerIntegrator Method Definitions&gt;&gt;+=&nbsp;<a href="#fragment-SamplerIntegratorMethodDefinitions-0"><span class="fa fa-caret-up"></span></a></div>
<div class="fragmentcode"><a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> <span class="anchor" id="SamplerIntegrator::SpecularReflect"></span><a href="#SamplerIntegrator" class="code">SamplerIntegrator</a>::SpecularReflect(const RayDifferential &amp;ray,
        const <a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction" class="code">SurfaceInteraction</a> &amp;isect, const <a href="#Scene" class="code">Scene</a> &amp;scene,
        <a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler" class="code">Sampler</a> &amp;sampler, <a href="../Utilities/Memory_Management.html#MemoryArena" class="code">MemoryArena</a> &amp;arena, int depth) const {
    &lt;&lt;<span class="fragmentname"><a href="#fragment-ComputespecularreflectiondirectionmonowiandBSDFvalue-0">Compute specular reflection direction <tt>wi</tt> and BSDF value</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-79" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-79"><i></i></a><div id="fragbit-79" class="collapse"><div class="fragmentcode">       <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>, wi;
       Float pdf;
       BxDFType type = BxDFType(BSDF_REFLECTION | BSDF_SPECULAR);
       <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> f = isect.bsdf-&gt;<a href="../Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html#BSDF::Sample_f" class="code">Sample_f</a>(<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>, &amp;wi, sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>(), &amp;pdf, type);</div></div>
    &lt;&lt;<span class="fragmentname"><a href="#fragment-Returncontributionofspecularreflection-0">Return contribution of specular reflection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-80" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-80"><i></i></a><div id="fragbit-80" class="collapse"><div class="fragmentcode">       const <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> &amp;ns = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>;
       if (pdf &gt; 0 &amp;&amp; !f.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() &amp;&amp; <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns) != 0) {
           &lt;&lt;<span class="fragmentname"><a href="../Texture/Sampling_and_Antialiasing.html#fragment-Computeraydifferentialmonordforspecularreflection-0">Compute ray differential <tt>rd</tt> for specular reflection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-81" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-81"><i></i></a><div id="fragbit-81" class="collapse"><div class="fragmentcode">              RayDifferential rd = isect.<a href="../Shapes/Managing_Rounding_Error.html#Interaction::SpawnRay" class="code">SpawnRay</a>(wi);
              if (ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::hasDifferentials" class="code">hasDifferentials</a>) {
                  rd.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::hasDifferentials" class="code">hasDifferentials</a> = true;
                  rd.rxOrigin = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a> + isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dpdx" class="code">dpdx</a>;
                  rd.ryOrigin = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a> + isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dpdy" class="code">dpdy</a>;
                  &lt;&lt;<span class="fragmentname"><a href="../Texture/Sampling_and_Antialiasing.html#fragment-Computedifferentialreflecteddirections-0">Compute differential reflected directions</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-82" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-82"><i></i></a><div id="fragbit-82" class="collapse"><div class="fragmentcode">                     <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> dndx = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndu" class="code">dndu</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dudx" class="code">dudx</a> +
                                     isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndv" class="code">dndv</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dvdx" class="code">dvdx</a>;
                     <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> dndy = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndu" class="code">dndu</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dudy" class="code">dudy</a> +
                                     isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndv" class="code">dndv</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dvdy" class="code">dvdy</a>;
                     <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dwodx = -ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::rxDirection" class="code">rxDirection</a> - wo, dwody = -ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ryDirection" class="code">ryDirection</a> - wo;
                     Float dDNdx = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dwodx, ns) + <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, dndx);
                     Float dDNdy = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dwody, ns) + <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, dndy);
                     rd.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::rxDirection" class="code">rxDirection</a> = wi - dwodx +
                         2.f * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, ns) * dndx + dDNdx * ns);
                     rd.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ryDirection" class="code">ryDirection</a> = wi - dwody +
                         2.f * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, ns) * dndy + dDNdy * ns);</div></div>
              }</div></div>
           return f * <a href="#SamplerIntegrator::Li" class="code">Li</a>(rd, scene, sampler, arena, depth + 1) * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns) /
                  pdf;
       }
       else
           return <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);</div></div>
}</div><p>


</p>
<p>In the <tt>SpecularReflect()</tt> and <tt>SpecularTransmit()</tt>
methods, the <a href="../Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html#BSDF::Sample_f"><tt>BSDF::Sample_f()</tt></a> method returns an incident ray
direction for a given outgoing direction and a given mode of light
scattering.  This method is one of the foundations of the Monte Carlo light
transport algorithms that will be the subject of the last few chapters of
this book.  Here, we will use it to find only outgoing directions
corresponding to perfect specular reflection or refraction, using flags to
indicate to <a href="../Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html#BSDF::Sample_f"><tt>BSDF::Sample_f()</tt></a> that other types of reflection should
be ignored.  Although <a href="../Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html#BSDF::Sample_f"><tt>BSDF::Sample_f()</tt></a> can sample random directions
leaving the surface for probabilistic integration algorithms, the
randomness is constrained to be consistent with the <a href="../Materials/BSDFs.html#BSDF"><tt>BSDF</tt></a>&rsquo;s scattering
properties.  In the case of perfect specular reflection or refraction, only
one direction is possible, so there is no randomness at all.

</p>
<p>The calls to <a href="../Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html#BSDF::Sample_f"><tt>BSDF::Sample_f()</tt></a> in these functions initialize
<tt>wi</tt> with the chosen direction and return the BSDF&rsquo;s value for the
directions <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.479ex" height="2.843ex" style="vertical-align: -0.838ex;" viewBox="0 -863.1 3220 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">left-parenthesis omega Subscript normal o Baseline comma omega Subscript normal i Baseline right-parenthesis</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNMAIN-28" d="M332 -238c0 -5 -5 -10 -10 -10c-2 0 -4 1 -6 2c-110 83 -215 283 -215 454v84c0 171 105 371 215 454c2 1 4 2 6 2c5 0 10 -5 10 -10c0 -3 -2 -6 -4 -8c-104 -78 -173 -278 -173 -438v-84c0 -160 69 -360 173 -438c2 -2 4 -5 4 -8Z"></path>
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-6F" d="M471 214c0 -127 -101 -225 -222 -225c-117 0 -221 96 -221 225c0 125 97 234 222 234c121 0 221 -106 221 -234zM388 222c0 38 0 96 -26 139s-69 65 -113 65c-40 0 -87 -21 -114 -67c-24 -44 -24 -98 -24 -137c0 -36 0 -97 25 -141c27 -46 71 -67 114 -67 c50 0 94 29 116 74c22 44 22 98 22 134Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-2C" d="M203 1c0 -117 -80 -194 -91 -194c-5 0 -10 4 -10 11c0 3 0 5 11 16c33 33 68 93 68 167c0 14 -2 15 -2 15s-2 -1 -5 -3c-10 -9 -23 -13 -35 -13c-33 0 -53 26 -53 53c0 28 20 53 53 53c39 0 64 -39 64 -105Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-29" d="M288 208c0 -171 -105 -371 -215 -454c-2 -1 -4 -2 -6 -2c-5 0 -10 5 -10 10c0 3 2 6 4 8c104 78 173 278 173 438v84c0 160 -69 360 -173 438c-2 2 -4 5 -4 8c0 5 5 10 10 10c2 0 4 -1 6 -2c110 -83 215 -283 215 -454v-84Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNMAIN-28" x="0" y="0"></use>
<g transform="translate(389,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-6F" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-2C" x="1465" y="0"></use>
<g transform="translate(1911,0)">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
 <use xlink:href="#E1-LATINMODERNMAIN-29" x="2830" y="0"></use>
</g>
</svg>.  If the value of the BSDF is nonzero, the
integrator uses the <a href="#SamplerIntegrator::Li"><tt>SamplerIntegrator::Li()</tt></a> method to get the
incoming radiance along <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.135ex" height="2.009ex" style="vertical-align: -0.671ex;" viewBox="0 -576.1 919.4 865.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">omega Subscript normal i</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-LATINMODERNNORMAL-1D714" d="M604 372c0 -40 -12 -90 -23 -133c-30 -121 -93 -250 -197 -250c-67 0 -102 44 -113 106c-38 -62 -90 -106 -153 -106c-76 0 -105 62 -105 143c0 35 5 74 15 112c16 63 41 127 82 184c5 6 12 9 18 9c3 0 6 0 9 -2c5 -3 9 -8 9 -14c0 -4 -2 -9 -5 -13 c-38 -53 -74 -109 -89 -169c-5 -22 -8 -45 -8 -65c0 -63 26 -113 87 -113c55 0 103 39 136 93c1 29 5 59 13 90c5 22 15 47 34 47c14 0 19 -11 19 -26c0 -8 -2 -17 -4 -26c-7 -30 -17 -60 -30 -88c9 -52 42 -90 98 -90c79 0 137 92 160 183c3 12 4 25 4 37 c0 35 -13 66 -38 88c-7 7 -11 15 -11 25c0 11 5 22 14 32c10 10 23 16 35 16c9 0 17 -3 23 -9c15 -13 20 -35 20 -61Z"></path>
<path stroke-width="1" id="E1-LATINMODERNMAIN-69" d="M247 0c-34 1 -69 3 -104 3l-110 -3v31c67 0 78 0 78 45v269c0 49 -9 55 -74 55v31l140 11v-367c0 -39 4 -44 70 -44v-31zM192 604c0 -25 -20 -53 -54 -53c-30 0 -53 26 -53 53c0 25 20 53 54 53c30 0 53 -26 53 -53Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-LATINMODERNNORMAL-1D714" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-LATINMODERNMAIN-69" x="880" y="-213"></use>
</g>
</svg>, which in this case will in turn resolve to
the <a href="#WhittedIntegrator::Li"><tt>WhittedIntegrator::Li()</tt></a> method. 

</p>
<p></p>
<span class="anchor" id="fragment-ComputespecularreflectiondirectionmonowiandBSDFvalue-0"></span><div class="fragmentname">&lt;&lt;Compute specular reflection direction <tt>wi</tt> and BSDF value&gt;&gt;=&nbsp;</div>
<div class="fragmentcode"><a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> <a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a> = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>, wi;
Float pdf;
BxDFType type = BxDFType(BSDF_REFLECTION | BSDF_SPECULAR);
<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a> f = isect.bsdf-&gt;<a href="../Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html#BSDF::Sample_f" class="code">Sample_f</a>(<a href="../Geometry_and_Transformations/Interactions.html#Interaction::wo" class="code">wo</a>, &amp;wi, sampler.<a href="../Sampling_and_Reconstruction/Sampling_Interface.html#Sampler::Get2D" class="code">Get2D</a>(), &amp;pdf, type);</div><p>


</p>
<p>In order to use ray differentials to antialias textures that are seen in
reflections or refractions, it is necessary to know how reflection and
transmission affect the screen-space footprint of rays.  The fragments that
compute the ray differentials for these rays are defined later, in
Section&nbsp;<a href="../Texture/Sampling_and_Antialiasing.html#sec:raydiff-reflect-transmit">10.1.3</a>.  Given the fully initialized
ray differential, a recursive call to <tt>Li()</tt> provides incident
radiance, which is scaled by the value of the BSDF, the cosine term, and
divided by the PDF, as per Equation&nbsp;(<a href="../Introduction/Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html#eq:rendering-equation">1.1</a>).

</p>
<p></p>
<span class="anchor" id="fragment-Returncontributionofspecularreflection-0"></span><div class="fragmentname">&lt;&lt;Return contribution of specular reflection&gt;&gt;=&nbsp;</div>
<div class="fragmentcode">const <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> &amp;ns = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::n" class="code">n</a>;
if (pdf &gt; 0 &amp;&amp; !f.<a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum::IsBlack" class="code">IsBlack</a>() &amp;&amp; <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns) != 0) {
    &lt;&lt;<span class="fragmentname"><a href="../Texture/Sampling_and_Antialiasing.html#fragment-Computeraydifferentialmonordforspecularreflection-0">Compute ray differential <tt>rd</tt> for specular reflection</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-83" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-83"><i></i></a><div id="fragbit-83" class="collapse"><div class="fragmentcode">       RayDifferential rd = isect.<a href="../Shapes/Managing_Rounding_Error.html#Interaction::SpawnRay" class="code">SpawnRay</a>(wi);
       if (ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::hasDifferentials" class="code">hasDifferentials</a>) {
           rd.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::hasDifferentials" class="code">hasDifferentials</a> = true;
           rd.rxOrigin = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a> + isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dpdx" class="code">dpdx</a>;
           rd.ryOrigin = isect.<a href="../Geometry_and_Transformations/Interactions.html#Interaction::p" class="code">p</a> + isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dpdy" class="code">dpdy</a>;
           &lt;&lt;<span class="fragmentname"><a href="../Texture/Sampling_and_Antialiasing.html#fragment-Computedifferentialreflecteddirections-0">Compute differential reflected directions</a></span>&gt;&gt;&nbsp;<a data-toggle="collapse" href="#fragbit-84" role="button" class="fa codecarat collapsed" aria-expanded="false" aria-controls="fragbit-84"><i></i></a><div id="fragbit-84" class="collapse"><div class="fragmentcode">              <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> dndx = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndu" class="code">dndu</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dudx" class="code">dudx</a> +
                              isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndv" class="code">dndv</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dvdx" class="code">dvdx</a>;
              <a href="../Geometry_and_Transformations/Normals.html#Normal3f" class="code">Normal3f</a> dndy = isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndu" class="code">dndu</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dudy" class="code">dudy</a> +
                              isect.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading" class="code">shading</a>.<a href="../Geometry_and_Transformations/Interactions.html#SurfaceInteraction::shading::dndv" class="code">dndv</a> * isect.<a href="../Texture/Sampling_and_Antialiasing.html#SurfaceInteraction::dvdy" class="code">dvdy</a>;
              <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a> dwodx = -ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::rxDirection" class="code">rxDirection</a> - wo, dwody = -ray.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ryDirection" class="code">ryDirection</a> - wo;
              Float dDNdx = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dwodx, ns) + <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, dndx);
              Float dDNdy = <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(dwody, ns) + <a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, dndy);
              rd.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::rxDirection" class="code">rxDirection</a> = wi - dwodx +
                  2.f * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, ns) * dndx + dDNdx * ns);
              rd.<a href="../Geometry_and_Transformations/Rays.html#RayDifferential::ryDirection" class="code">ryDirection</a> = wi - dwody +
                  2.f * <a href="../Geometry_and_Transformations/Vectors.html#Vector3f" class="code">Vector3f</a>(<a href="../Geometry_and_Transformations/Vectors.html#Dot" class="code">Dot</a>(wo, ns) * dndy + dDNdy * ns);</div></div>
       }</div></div>
    return f * <a href="#SamplerIntegrator::Li" class="code">Li</a>(rd, scene, sampler, arena, depth + 1) * <a href="../Geometry_and_Transformations/Vectors.html#AbsDot" class="code">AbsDot</a>(wi, ns) /
           pdf;
}
else
    return <a href="../Color_and_Radiometry/Spectral_Representation.html#Spectrum" class="code">Spectrum</a>(0.f);</div><p>


</p>
<p>The
<tt>SpecularTransmit()</tt><span class="anchor" id="SamplerIntegrator::SpecularTransmit"></span>
method is essentially the same as <tt>SpecularReflect()</tt> but just
requests the <a href="../Reflection_Models/Basic_Interface.html#BSDF_TRANSMISSION"><tt>BSDF_TRANSMISSION</tt></a> specular component of the BSDF, if
any, rather than the <a href="../Reflection_Models/Basic_Interface.html#BSDF_REFLECTION"><tt>BSDF_REFLECTION</tt></a> component used by
<tt>SpecularReflect()</tt>.  We therefore won&rsquo;t include its implementation in
the text of the book here.

</p>
<p>

</p>
<p>

</p>
<p>

</p>
<p></p>

</div> <!-- col-md-10 col-lg-8 -->
<div class="col-md-1 col-lg-2">

</div> <!-- col-md-1 col-lg-2 -->
</div>  <!-- row -->

</div>  <!-- container-fluid -->
</div>  <!-- maincontainer -->

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <div class="container-fluid-nav">
    <!--  <ul class="nav navbar-nav navbar-center"> -->
      <span class="navbar-text" style="text-align: center;">
        Thanks to Aras Pranckevicius and 34 others for generously supporting <i>Physically
        Based Rendering</i> online
        through <a href="https://patreon.com/pbrbook">Patreon</a>.
    </span>
  </div>
</nav>

<nav class="navbar navbar-expand-md bg-light navbar-light">
  <span class="navbar-text"><i>Physically Based Rendering: From Theory To Implementation</i>, &copy; 2004-2021 Matt Pharr, Wenzel Jakob, and Greg Humphreys under the <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a> license. (<a href="https://github.com/mmp/pbr-book-website/">github</a>)</span>
  <div class="container">
    <ul class="nav navbar-nav ml-auto">
      <li class="nav-item">Next: <a href="../Introduction/Parallelization_of_pbrt.html">Introduction / Parallelization of pbrt</a></li>
    </ul>
  </div>

</nav>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script>
  $(function () {
    $('[data-toggle="popover"]').popover()
    $('[data-toggle="tooltip"]').tooltip()
   })
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

<script>
// https://stackoverflow.com/a/17535094
// The function actually applying the offset
function offsetAnchor() {
  if (location.hash.length !== 0) {
    window.scrollTo(window.scrollX, window.scrollY - window.innerHeight / 8);
  }
}

// Captures click events of all <a> elements with href starting with #
$(document).on('click', 'a[href^="#"]', function(event) {
  // Click events are captured before hashchanges. Timeout
  // causes offsetAnchor to be called after the page jump.
  window.setTimeout(function() {
    offsetAnchor();
  }, 500);
});

// Set the offset when entering page with hash present in the url
window.setTimeout(offsetAnchor, 1500);
</script>

</body>
</html>
